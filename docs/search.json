[{"path":"index.html","id":"introduction","chapter":"Introduction","heading":"Introduction","text":"這邊是總結Udemy上的python內容","code":""},{"path":"python-environmental-setting.html","id":"python-environmental-setting","chapter":"1 Python Environmental Setting","heading":"1 Python Environmental Setting","text":"要開始用python前，我們要先學如何安裝python對我的mac來說(對linux應該也是)，系統其實有預先安裝python了，只是是2.0的版本，並不適合使用。可以在terminal中輸入python --version來查看那我是用pyenv這個python版本管理工具，來進行python的安裝他的好處是，有一個統一的架構，可以安裝各種版本的python。並視專案的需要，可以輕鬆切換不同版本的python來使用那就先整理：\nOS 為 mac, terminal為zsh\n安裝方式為透過pyenv來安裝\nOS 為 mac, terminal為zsh安裝方式為透過pyenv來安裝至於其他作業系統(e.g. Linux, Windows)，或其他安裝方式(e.g. 直接安裝python, 透過anaconda安裝…)，就留待之後有空再整理以下會整理我實際的操作步驟，至於細節，可以到pyenv的官網去看: https://github.com/pyenv/pyenv","code":""},{"path":"python-environmental-setting.html","id":"mac-zsh-shell-用pyenv安裝切換-python","chapter":"1 Python Environmental Setting","heading":"1.1 [mac + zsh shell] 用pyenv，安裝/切換 python","text":"","code":""},{"path":"python-environmental-setting.html","id":"先安裝pyenv","chapter":"1 Python Environmental Setting","heading":"1.1.1 先安裝pyenv","text":"首先，在mac上，用homebrew來下載pyenv這個套件安裝完成後，確認一下目前根目錄下，有沒有 .zshrc 這個檔案應該是會有拉。如果沒有的話，就新增這個檔然後，在terminal輸入以下指令：其實上面這行，等價於你先打開.zshrc檔(.e. open / .zshrc)，然後在”最下面”，加入以下指令：這個指令的重點就是，eval \"$(pyenv init -)\"，用意是Add pyenv init shell enable shims autocompletion。那每次我們開shell時，他都會幫我們執行 pyenv init，那使用python時，就會到pyenv指定的路徑找python，而不會找到系統版的python(2.x.x版)這個指令的重點就是，eval \"$(pyenv init -)\"，用意是Add pyenv init shell enable shims autocompletion。那每次我們開shell時，他都會幫我們執行 pyenv init，那使用python時，就會到pyenv指定的路徑找python，而不會找到系統版的python(2.x.x版)restart shell，讓設定生效restart shell，讓設定生效","code":"brew update\nbrew install pyenvopen ~/.zshrctouch ~/ .zshrcecho -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n  eval \"$(pyenv init -)\"\\nfi' >> ~/.zshrcif command -v pyenv 1>/dev/null 2>&1; then\n  eval \"$(pyenv init -)\"\nfi"},{"path":"python-environmental-setting.html","id":"安裝指定版本的python","chapter":"1 Python Environmental Setting","heading":"1.1.2 安裝指定版本的python","text":"在terminal中輸入以下指令(Todo: 去確認reticulate網頁，我記得要讓R可以用的話，pyenv install 3.8.0後面還要加argument才行)安裝完成後，確認現在pyenv有哪些版本：有加*的，表示目前正在使用的版本","code":"pyenv install 3.8.0pyenv versions"},{"path":"python-environmental-setting.html","id":"切換指定-要使用的python的版本","chapter":"1 Python Environmental Setting","heading":"1.1.3 切換/指定 要使用的python的版本","text":"先學這個簡單的就好，我們用以下指令來指定我要用的版本：那確定一下有切換過去：並用系統指令再確認一下，現在在用的版本","code":"pyenv global 3.8.0pyenv versionspython --version # 看正在使用的python的版本\nwhich python # 看使用的python的路徑"},{"path":"python-environmental-setting.html","id":"先用terminal快速執行一個.py檔","chapter":"1 Python Environmental Setting","heading":"1.1.4 先用terminal快速執行一個.py檔","text":"確認沒問題後，我們在桌面新增這個myfirstpython.py檔案然後，在terminal輸入以下指令，即可執行：前面的python，他就會去找現在路徑底下的python，也就是which python的這個python後面的myfirstpython.py，他是去找現在工作目錄下的這個.py檔，也就是pwd下的myfirstpython.py所以，也可以給絕對路徑，來執行.py檔：","code":"# myfirstpython.py\nprint(\"Hello Python\")python myfirstpython.py/Users/hanklee/.pyenv/shims/python /Users/hanklee/Desktop/myfirstpython.py"},{"path":"python-environmental-setting.html","id":"pyenv-常用命理整理","chapter":"1 Python Environmental Setting","heading":"1.1.5 pyenv 常用命理整理","text":"","code":""},{"path":"python-environmental-setting.html","id":"python配置","chapter":"1 Python Environmental Setting","heading":"1.1.5.1 Python配置","text":"","code":"# 檢視系統當前安裝的python列表\npyenv versions\n\n# 列出可安裝版本\npyenv install --list \n\n# 安裝指定版本 Python\npyenv install -v 3.5.1\n\n# 解除安裝指定版本 Python\npyenv uninstall 2.7.3\n\n# 顯示當前python安裝路徑\npyenv which python \n\n# 建立墊片路徑\n# 為所有已安裝的可執行檔案建立 shims\n# 如：~/.pyenv/versions/*/bin/*\n# 每當你增刪了 Python 版本或帶有可執行檔案的包（如 pip）以後，都應該執行一次本命令\npyenv rehash"},{"path":"python-environmental-setting.html","id":"python-切換","chapter":"1 Python Environmental Setting","heading":"1.1.5.2 Python 切換","text":"","code":"#  設定全域性的 Python 版本，通過將版本號寫入 ~/.pyenv/version 檔案的方式\npyenv global <版本號>\n\n# 設定面向程式的本地版本，通過將版本號寫入當前目錄下的 .python-version 檔案的方式。通過這種方式設定的 Python 版本優先順序較 global 高。\n# pyenv 會從當前目錄開始向上逐級查詢 .python-version 檔案，直到根目錄為止。若找不到，就用 global 版本。\npyenv local <版本號>\n\n# 設定面向 shell 的 Python 版本，通過設定當前 shell 的 PYENV_VERSION 環境變數的方式。這個版本的優先順序比 local 和 global 都要高。\npyenv shell <版本號>\n\n# --unset 引數可以用於取消當前 shell 設定的版本。\npyenv shell --unset"},{"path":"python-environmental-setting.html","id":"linux-bash-shell-安裝python待整理","chapter":"1 Python Environmental Setting","heading":"1.2 [linux + bash shell] 安裝python待整理","text":"","code":""},{"path":"python-environmental-setting.html","id":"windows-gitbash-安裝python待整理","chapter":"1 Python Environmental Setting","heading":"1.3 [windows + gitbash] 安裝python待整理","text":"","code":""},{"path":"python-environmental-setting.html","id":"用pip安裝移除條列套件","chapter":"1 Python Environmental Setting","heading":"1.4 用pip安裝/移除/條列套件","text":"pip本身就是個python的package，他的用途是協助安裝python的第三方package從python 3.4以後，只要安裝python，就會幫你安裝pip這個package，但版本可能比較低，所以還要自己更新整理常用的指令如下：這邊特別注意最後一個指令pip freeze，他列出所有目前安裝過的套件與版本號，這對reproducible research很有用","code":"# 先確認版本已是最新版\npip install --upgrade pip\n\n# 安裝套件\npip install flask\nsudo pip install flask # linux\n\n# 移除套件\npip uninstall flask\n\n# 觀看目前所有安裝過的套件\npip freeze"},{"path":"python-environmental-setting.html","id":"requirements.txt","chapter":"1 Python Environmental Setting","heading":"1.5 requirements.txt","text":"假設現在我們用python開發了一個package，而開發過程中，我陸續安裝了很多package來搭配使用，那，當別人用我的package時，他也需要安裝我曾經安裝過的這些packages，才能正常使用那這時就可以這樣做：所以，我們如果去github看人家python的專案，例如ansible/ansible這個專案，就可以看到他有附”requirements.txt”這個檔案","code":"# 將目前系統有安裝過的python package條列出\n# 存成requirement.txt，提供給別人\npip freeze >> requirement.txt\n\n# 別人只要下載你的requirement.txt\n# 並執行以下指令即可reproduce你用的套件版本\npip install -r requirements.txt"},{"path":"python-environmental-setting.html","id":"用virtualenv來隔離乾淨的開發環境","chapter":"1 Python Environmental Setting","heading":"1.6 用virtualenv來隔離乾淨的開發環境","text":"剛剛用”requirements.txt”來解決package和版本問題，似乎很方便，但其實很多小問題在裡面\n例如，你的python從安裝開始，到你開發結束，早就安裝一堆package了，其中很多package是和你的專案無關的，但你用pip freeze就只能全抓\n我們常常不只開發一個專案，有可能當我們開發專案A時，install了flask，然後當我們開發專案B時，又install了flask，而這兩個flask的版本是不同的。假設前者的版本是flask 1.1.0，後者是flask 1.2.0，那當我們用pip freeze時，他只會保留最新的，也就是flask 1.2.0，那…就有可能在re-run A專案時，遇到bug，因為flask的版本已經不一樣了\n例如，你的python從安裝開始，到你開發結束，早就安裝一堆package了，其中很多package是和你的專案無關的，但你用pip freeze就只能全抓我們常常不只開發一個專案，有可能當我們開發專案A時，install了flask，然後當我們開發專案B時，又install了flask，而這兩個flask的版本是不同的。假設前者的版本是flask 1.1.0，後者是flask 1.2.0，那當我們用pip freeze時，他只會保留最新的，也就是flask 1.2.0，那…就有可能在re-run A專案時，遇到bug，因為flask的版本已經不一樣了為了解決這個問題，python的熟手，都是習慣每個專案擁有自己的虛擬環境(virtual environment)，那我的package就裝在自己的虛擬環境中，到時候要打包，要freeze灌過的package給人家，就直接在這虛擬環境中下指令就好","code":""},{"path":"python-environmental-setting.html","id":"用terminal透過virtualenv來開虛擬環境","chapter":"1 Python Environmental Setting","heading":"1.6.1 用terminal，透過virtualenv()來開虛擬環境","text":"我直接用flask課堂上的專案來做舉例\n首先，我開啟VSCode，用他的terminal功能，把工作目錄，切到以下路徑：/Volumes/GoogleDrive/我的雲端硬碟/0. codepool_python/flask_tutorial/udemy_flask_web/helloworld\n並且確認一下當前使用的python版本，與python路徑\n然後執行以下兩個指令，來建立並進入虛擬環境\n首先，我開啟VSCode，用他的terminal功能，把工作目錄，切到以下路徑：/Volumes/GoogleDrive/我的雲端硬碟/0. codepool_python/flask_tutorial/udemy_flask_web/helloworld並且確認一下當前使用的python版本，與python路徑然後執行以下兩個指令，來建立並進入虛擬環境截圖如下：進入虛擬環境後，我們可以用pip freeze觀察，目前已經安裝哪些套件了，結果發現啥都沒有(合理嘛)然後安裝flask後(pip install flask)後，再觀察一次pip freeze，就看到已經安裝許多東西進去了我們可以用pip freeze >> requirement.txt把這個結果寫出來最後，要離開時，再key入deactivate，就跳出此虛擬環境了。截圖如下：","code":"# 在當前目錄下，建立一個虛擬環境資料夾，叫`.env`\n# (要不要加`.`都無所謂，你要寫`env`或`hahaha`都可以)  \nvirtualenv .env\n\n# 進入此虛擬環境  \nsource .env/bin/activate"},{"path":"python-environmental-setting.html","id":"用terminal透過pyenv-virtualenv來開虛擬環境","chapter":"1 Python Environmental Setting","heading":"1.6.2 用terminal，透過pyenv-virtualenv來開虛擬環境","text":"這邊還沒用過，我從此網頁把操作流程copy下來，他整理的蠻清楚的。pyenv-virtualenv 是 pyenv 下基於 virtualenv 的一款外掛，通過 pyenv-virtualenv 外掛可以很好的和 virtualenv 結合。","code":""},{"path":"python-environmental-setting.html","id":"安裝","chapter":"1 Python Environmental Setting","heading":"1.6.2.1 安裝","text":"使用 homebrew 安裝 pyenv-virtualenv :安裝之後需要執行如下配置：","code":"brew install pyenv-virtualenv# 使用 zsh shell\nvim ~/.zshrc\n\n# 使用系統預設\nvim ~/.bash_profile\n\n# 在 `.zshrc` 或 `.bash_profile` 檔案最後寫入：\n# pyenv-virtualenv\nif which pyenv-virtualenv-init > /dev/null;\n  then eval \"$(pyenv virtualenv-init -)\";\nfi\n\n# 使配置生效\nsource ~/.zshrc\n# or\nsource ~/.bash_profile"},{"path":"python-environmental-setting.html","id":"使用","chapter":"1 Python Environmental Setting","heading":"1.6.2.2 使用","text":"","code":"# 建立虛擬環境\n# 若不指定 Python 版本，預設使用當前環境 Python 版本\npyenv virtualenv <Python 版本號> <虛擬環境名稱>\n\n# 列出當前虛擬環境\npyenv virtualenvs\n\n# 啟用虛擬環境\npyenv activate <虛擬環境名稱>\n\n# 退出虛擬環境\npyenv deactivate\n\n# 刪除虛擬環境\npyenv uninstall <虛擬環境名稱>"},{"path":"python-environmental-setting.html","id":"用vscode開虛擬環境專案","chapter":"1 Python Environmental Setting","heading":"1.6.3 用vscode開虛擬環境專案","text":"","code":""},{"path":"python-environmental-setting.html","id":"用pycharm開虛擬環境專案","chapter":"1 Python Environmental Setting","heading":"1.6.4 用pycharm開虛擬環境專案","text":"","code":""},{"path":"執行python的code.html","id":"執行python的code","chapter":"2 執行Python的code","heading":"2 執行Python的code","text":"","code":""},{"path":"執行python的code.html","id":"command-line","chapter":"2 執行Python的code","heading":"2.1 command line","text":"","code":""},{"path":"執行python的code.html","id":"用interactive-mode-執行","chapter":"2 執行Python的code","heading":"2.1.1 用interactive mode 執行","text":"在command line，打python或ipython，就會進入互動視窗，然後就可以互動的執行了要結束時，再按quit()，就會退出視窗","code":"ipython\nprint(\"Hello, World\")\nquit()"},{"path":"執行python的code.html","id":"寫成.py檔後執行","chapter":"2 執行Python的code","heading":"2.1.2 寫成.py檔後執行","text":"我們可以開一個script，在裡面寫code，然後存成.py檔，例如hello.py然後，在command line，用python /path///file/hello.py，就可以執行這個.py檔了","code":""},{"path":"執行python的code.html","id":"在vs-code中執行","chapter":"2 執行Python的code","heading":"2.2 在VS code中執行","text":"","code":""},{"path":"執行python的code.html","id":"設定要使用的python版本","chapter":"2 執行Python的code","heading":"2.2.1 設定要使用的python版本","text":"以下內容，整理至官方網站： https://code.visualstudio.com/docs/python/environments打開VS code後，輸入command+shift+p (⇧⌘P)，然後key入preferences: open user settings，開啟設定。然後照下面圖面做設定：打開json檔後，做以下的輸入：這邊要注意的只有裡面的兩行一定要有：\n\"python.pythonPath\": \"/Users/hanklee/....\"， 這邊的路徑，就是放你想要跑的版本。例如我都用pyenv來管理我的python version，那我可以在terminal用pyenv global 3.8.0來選定我要用3.8.0的版本後，再下which python，來得到這個版本的路徑。做完這行設定後，只要在VScode中點視窗右上角的run，他就會幫你下達這個指令：path//python/version path///file。\n\"PATH\": \"\"，這個指令，是我google到的解法(連結)，主要是要解決，在VScode中，我開視窗下面的terminal，但執行python時，還是沒有執行到python.pythonPath的版本。\n\"python.pythonPath\": \"/Users/hanklee/....\"， 這邊的路徑，就是放你想要跑的版本。例如我都用pyenv來管理我的python version，那我可以在terminal用pyenv global 3.8.0來選定我要用3.8.0的版本後，再下which python，來得到這個版本的路徑。做完這行設定後，只要在VScode中點視窗右上角的run，他就會幫你下達這個指令：path//python/version path///file。\"PATH\": \"\"，這個指令，是我google到的解法(連結)，主要是要解決，在VScode中，我開視窗下面的terminal，但執行python時，還是沒有執行到python.pythonPath的版本。","code":"{\n    \"jupyter.alwaysTrustNotebooks\": true,\n    \"python.pythonPath\": \"/Users/hanklee/.pyenv/versions/3.8.0/bin/python\",\n    \"terminal.integrated.env.osx\": {\n    \n    \"PATH\": \"\"\n    }\n}"},{"path":"執行python的code.html","id":"腳本執行","chapter":"2 執行Python的code","heading":"2.2.2 腳本執行","text":"這邊再找時間舉個例子做截圖吧。用hello-world.py這種script，示範點選畫面右上角的箭頭來run，或是底下的terminal自己key python hello-world.py都可以。","code":""},{"path":"執行python的code.html","id":"逐行執行","chapter":"2 執行Python的code","heading":"2.2.3 逐行執行","text":"逐行執行的部分，要再查一下，目前就只會在jupyter中逐行執行，但很笨","code":""},{"path":"執行python的code.html","id":"debug","chapter":"2 執行Python的code","heading":"2.2.4 debug","text":"ToDo…","code":""},{"path":"執行python的code.html","id":"在-rstudio-中執行","chapter":"2 執行Python的code","heading":"2.3 在 RStudio 中執行","text":"應該要用Reticulate的架構來整理，等有空再說吧","code":""},{"path":"執行python的code.html","id":"新增檔案python-script","chapter":"2 執行Python的code","heading":"2.3.1 新增檔案/python script","text":"只要新增一個.py的檔案，就可以像寫R一樣逐行執行","code":""},{"path":"執行python的code.html","id":"用rmarkdown","chapter":"2 執行Python的code","heading":"2.3.2 用RMarkdown","text":"開RMarkdown檔案，然後用command + option + p，開啟python的chunk，就可以執行了","code":""},{"path":"註解與indention.html","id":"註解與indention","chapter":"3 註解與indention","heading":"3 註解與indention","text":"","code":""},{"path":"註解與indention.html","id":"插入註解","chapter":"3 註解與indention","heading":"3.1 插入註解","text":"python的註解和R一樣，都是用井字號，只要記得加空格來維持PEP8代碼風格即可：另外，在Python中，如果字串沒有被assign到一個變數，那會自動被忽略。所以，需要多行註解時，可以善用字串寫法:","code":"# 有空一格就是好註解  \n#沒有空格是爛註解\nprint(\"Hello, World!\")\"\"\"\nThis is a comment\nwritten in\nmore than just one line\n\"\"\"\nprint(\"Hello, World!\")"},{"path":"註解與indention.html","id":"indention","chapter":"3 註解與indention","heading":"3.2 indention","text":"在R或其他語言，經常是用大括號來包住function body，例如：但在Python都是靠indent:","code":"\nmy_func = function(x){\n  # 有大括號就是放心\n  a = x + 1\n  return(a)\n}def my_func(x):\n  # 靠indent來營造出coding block  \n  a = x + 1\n  return(a)\n\nmy_func(4)\n#> 5"},{"path":"print.html","id":"print","chapter":"4 print","heading":"4 print","text":"print()雖然很簡單，但有一些我原本不清楚的東西，所以整理一下","code":""},{"path":"print.html","id":"print可以放多個element進去","chapter":"4 print","heading":"4.1 print可以放多個element進去","text":"例如：可以發現，他不同的element間，用空格幫你隔開。這個空格是預設的，可以改。","code":"a = \"number\"\nb = 123\nprint(a, b, \"cool\")\n#> number 123 cool"},{"path":"print.html","id":"用sep來改間隔","chapter":"4 print","heading":"4.2 用sep=來改間隔","text":"看一下help文件(?print)，可以發現有sep = ' '這個argument，預設值是空格。所以改一下就可以換了","code":"a = \"number\"\nb = 123\nprint(a, b, \"cool\", sep = \"++\")\n#> number++123++cool"},{"path":"variables.html","id":"variables","chapter":"5 Variables","heading":"5 Variables","text":"","code":""},{"path":"variables.html","id":"overview","chapter":"5 Variables","heading":"5.1 overview","text":"","code":""},{"path":"variables.html","id":"建立variable","chapter":"5 Variables","heading":"5.1.1 建立variable","text":"python和R一樣，都不用宣告資料類型，就可以assign variable了：如果想要和C/Java一樣，assign variable時同時宣告資料類型，那要用casting","code":"x = 4       # x is of type int\nx = \"Sally\" # x is now of type str\nprint(x)\n#> Sallyx = str(3)    # x will be '3'\ny = int(3)    # y will be 3\nz = float(3)  # z will be 3.0"},{"path":"variables.html","id":"用type來確認variable資料類型","chapter":"5 Variables","heading":"5.1.2 用type()來確認variable資料類型","text":"","code":"x = 5\ny = \"John\"\nprint(type(x))\n#> <class 'int'>\nprint(type(y))\n#> <class 'str'>"},{"path":"variables.html","id":"variable-names","chapter":"5 Variables","heading":"5.2 variable names","text":"","code":""},{"path":"variables.html","id":"規則","chapter":"5 Variables","heading":"5.2.1 規則","text":"python中對variable name的要求是：\n只能是由alpha-numeric + underscores所組成(-z, 0-9, _)\n開頭不能是數字，只能英文或底線\ncase-sensitive，大小寫有差拉\npython中對variable name的要求是：只能是由alpha-numeric + underscores所組成(-z, 0-9, _)開頭不能是數字，只能英文或底線case-sensitive，大小寫有差拉","code":"# 合法的variable name  \nmyvar = \"John\"\nmy_var = \"John\"\n_my_var = \"John\"\nmyVar = \"John\"\nMYVAR = \"John\"\nmyvar2 = \"John\"\n\n# 不合法的variable name\n2myvar = \"John\"\nmy-var = \"John\"\nmy var = \"John\""},{"path":"variables.html","id":"多個字的variable-name","chapter":"5 Variables","heading":"5.2.2 多個字的variable name","text":"如果variable name想由多個字組成，哪有三種習慣性寫法：\nSnake Case: 像蛇一樣一節一節的，用底線隔開，例如 my_variable_name\nPascal Case: 每個字的開頭都給他大寫，例如 MyVariableName\nCamel Case: 像駱駝一樣，頭低低，後面駝峰都高起，所以首字小寫，之後都大寫，例如 myVariableName\n如果variable name想由多個字組成，哪有三種習慣性寫法：Snake Case: 像蛇一樣一節一節的，用底線隔開，例如 my_variable_namePascal Case: 每個字的開頭都給他大寫，例如 MyVariableNameCamel Case: 像駱駝一樣，頭低低，後面駝峰都高起，所以首字小寫，之後都大寫，例如 myVariableName","code":""},{"path":"variables.html","id":"一次assign多個variables","chapter":"5 Variables","heading":"5.3 一次assign多個variables","text":"","code":""},{"path":"variables.html","id":"多個valueassign給多個variable","chapter":"5 Variables","heading":"5.3.1 多個value，assign給多個variable","text":"","code":"x, y, z = \"Orange\", \"Banana\", \"Cherry\"\nprint(x)\n#> Orange\nprint(y)\n#> Banana\nprint(z)\n#> Cherry"},{"path":"variables.html","id":"同一個valueassign給多個variable","chapter":"5 Variables","heading":"5.3.2 同一個value，assign給多個variable","text":"","code":"x = y = z = \"Orange\"\nprint(x)\n#> Orange\nprint(y)\n#> Orange\nprint(z)\n#> Orange"},{"path":"variables.html","id":"unpack-a-collection","chapter":"5 Variables","heading":"5.3.3 unpack a collection","text":"在python中，collection包含list, tuple, dictionary, set那我可以把這些collection中的各個element，assign給各個variable，例如：而這招最常用的還是用在tuple上：","code":"fruits = [\"apple\", \"banana\", \"cherry\"]\nx, y, z = fruits\nprint(x)\n#> apple\nprint(y)\n#> banana\nprint(z)\n#> cherryfruits = (\"apple\", \"banana\", \"cherry\")\nx, y, z = fruits\nprint(x)\n#> apple\nprint(y)\n#> banana\nprint(z)\n#> cherry"},{"path":"variables.html","id":"assignment-operators","chapter":"5 Variables","heading":"5.4 Assignment Operators","text":"Python有許多assignment operators，整理如下：備註：\nx % 3的意思是，我要取餘數\nx // 3的意思是，我要取商\nx ** 3的意思是，x的3次方\nx % 3的意思是，我要取餘數x // 3的意思是，我要取商x ** 3的意思是，x的3次方","code":""},{"path":"variables.html","id":"variable-scope","chapter":"5 Variables","heading":"5.5 variable scope","text":"","code":""},{"path":"variables.html","id":"global-variables","chapter":"5 Variables","heading":"5.5.1 Global Variables","text":"想把function中的variable(e.g. x這個variable)，拉到global environment，就先用global x來宣告我的x是屬於global的，之後在這個function內把value給assign到x，就會放在global environment裡：想把function中的variable(e.g. x這個variable)，拉到global environment，就先用global x來宣告我的x是屬於global的，之後在這個function內把value給assign到x，就會放在global environment裡：來看看沒宣告的例子：來看看沒宣告的例子：再看看有宣告的例子：","code":"x = \"awesome\"\n\ndef myfunc():\n  x = \"fantastic\"\n  print(\"Python is \" + x)\n\nmyfunc()\n#> Python is fantastic\nprint(\"Python is \" + x)\n#> Python is awesomex = \"awesome\"\n\ndef myfunc():\n  global x\n  x = \"fantastic\"\n  print(\"Python is \" + x)\n\nmyfunc()\n#> Python is fantastic\nprint(\"Python is \" + x)\n#> Python is fantastic"},{"path":"python-data-types.html","id":"python-data-types","chapter":"6 Python Data Types","heading":"6 Python Data Types","text":"","code":""},{"path":"python-data-types.html","id":"built-in-data-types","chapter":"6 Python Data Types","heading":"6.1 Built-in Data Types","text":"python內建的data type，我喜歡把他分成三大類：\n基本款\ncollections\nbinary\n基本款collectionsbinary","code":""},{"path":"python-data-types.html","id":"基本款","chapter":"6 Python Data Types","heading":"6.1.1 基本款","text":"基本款：\nText: str\nNumeric: int, float, complex\nBoolean: bool\nText: strNumeric: int, float, complexBoolean: bool","code":""},{"path":"python-data-types.html","id":"collections","chapter":"6 Python Data Types","heading":"6.1.2 collections","text":"collections(array):\nSequence: list, tuple, range\nmapping: dict\nset: set, frozenset\nSequence: list, tuple, rangemapping: dictset: set, frozenset","code":""},{"path":"python-data-types.html","id":"binary","chapter":"6 Python Data Types","heading":"6.1.3 binary","text":"binary types: bytes, bytearray","code":""},{"path":"python-data-types.html","id":"getting-the-data-type","chapter":"6 Python Data Types","heading":"6.2 Getting the data type","text":"用type()，可以獲取此variable的類型","code":""},{"path":"python-data-types.html","id":"setting-the-specific-data-type","chapter":"6 Python Data Types","heading":"6.3 Setting the specific data type","text":"我們只要在value的前面，加上想宣告的資料類型，就可明確的定義出這種type的value","code":"# 基本款  \nx = str(\"Hello World\")\nx = int(20)  \nx = float(20.5)  \nx = complex(1j)\nx = bool(True)\n\n# collections  \nx = list((\"apple\", \"banana\", \"cherry\"))\nx = tuple((\"apple\", \"banana\", \"cherry\"))\nx = range(6)\nx = dict(name = \"john\", age = 36)\nx = set((\"apple\", \"banana\", \"cherry\"))\nx = frozenset((\"apple\", \"banana\", \"cherry\"))\n\n# binary\nx = bytes(5)\nx = bytearray(5)\nx = memoryview(bytes(5))"},{"path":"int-float-整理與實戰.html","id":"int-float-整理與實戰","chapter":"7 int & float 整理與實戰","heading":"7 int & float 整理與實戰","text":"","code":""},{"path":"int-float-整理與實戰.html","id":"建立intfloat變數","chapter":"7 int & float 整理與實戰","heading":"7.1 建立int/float變數","text":"int是整數，float是浮點數，當你assign variable時，python基本上就是看你有沒有小數點來做type的判定：","code":"x = 1\nprint(type(x))\n#> <class 'int'>\ny = 1.0\nprint(type(y))\n#> <class 'float'>"},{"path":"int-float-整理與實戰.html","id":"宣告intfloat變數","chapter":"7 int & float 整理與實戰","heading":"7.2 宣告int/float變數","text":"我們可以用casting的方式，來直接標明我的變數類型","code":"x = int(1)\nprint(type(x))\n#> <class 'int'>\ny = float(1.0)\nprint(type(y))\n#> <class 'float'>"},{"path":"int-float-整理與實戰.html","id":"型別轉換","chapter":"7 int & float 整理與實戰","heading":"7.3 型別轉換","text":"如果把int轉成float，就幫你加小數點：e.g. 1 -> 1.0如果把float轉成int，會無條件捨去","code":"x = 1\nprint(float(x))\n#> 1.0\ny = 1.6\nprint(int(y))\n#> 1"},{"path":"string整理與實戰.html","id":"string整理與實戰","chapter":"8 string整理與實戰","heading":"8 string整理與實戰","text":"","code":""},{"path":"string整理與實戰.html","id":"字串的定義","chapter":"8 string整理與實戰","heading":"8.1 字串的定義","text":"可以用單引號、雙引號做定義如果字串中含有單引號，那就用雙引號定義，反之亦然如果字串中又有單引號，雙引號，那就用三個單引號做定義","code":"a = 'hank'\nprint(a)\n#> hank\nprint(type(a))\n#> <class 'str'>b = \"tom\"\nprint(b)\n#> tom\nprint(type(b))\n#> <class 'str'>a = 'tom is \"good\"'\nprint(a)\n#> tom is \"good\"b = \"hank is 'bad'\"\nprint(b)\n#> hank is 'bad'c = '''\ntom is \"good\", and hank is 'bad'\n'''\nprint(c)\n#> \n#> tom is \"good\", and hank is 'bad'"},{"path":"string整理與實戰.html","id":"字串的基本操作","chapter":"8 string整理與實戰","heading":"8.2 字串的基本操作","text":"","code":""},{"path":"string整理與實戰.html","id":"利用來定義逃脫字元","chapter":"8 string整理與實戰","heading":"8.2.1 利用\\來定義逃脫字元","text":"例如換行是\\n直接打a時，他給你看原始樣貌但用print時，就會給你看顯示時的樣子","code":"a = \"abc\\nabc\"\na\n#> 'abc\\nabc'print(a)\n#> abc\n#> abc"},{"path":"string整理與實戰.html","id":"把字串看成listindex時從0開始","chapter":"8 string整理與實戰","heading":"8.2.2 把字串看成list，index時從0開始","text":"","code":"a = \"hank\"\na[2]\n#> 'n'"},{"path":"string整理與實戰.html","id":"字串常用功能去空白改小寫取代","chapter":"8 string整理與實戰","heading":"8.2.3 字串常用功能：去空白、改小寫、取代","text":"假設現在我有一個字串可以發現，這個字串的最前面和最後面都有空白，蠻討厭的，可以用.strip()來去掉然後大小寫交錯，在NLP中也很擾人，所以全改成小寫最後，如果我想把”(“和”)“都取代成”#“，就用replace大功告成而實務上在做時，喜歡一條龍做下去，比較好讀：","code":"s = ' Last Checkpoint: a few seconds ago (unsaved change) '\ns\n#> ' Last Checkpoint: a few seconds ago (unsaved change) 'a = s.strip()\na\n#> 'Last Checkpoint: a few seconds ago (unsaved change)'a = a.lower()\na\n#> 'last checkpoint: a few seconds ago (unsaved change)'a = a.replace(\"(\", \"#\")\na\n#> 'last checkpoint: a few seconds ago #unsaved change)'a = a.replace(\")\", \"#\")\na\n#> 'last checkpoint: a few seconds ago #unsaved change#'s2 = a.strip().lower().replace(\"(\", \"#\").replace(\"(\", \"#\")\ns2\n#> 'last checkpoint: a few seconds ago #unsaved change#'"},{"path":"string整理與實戰.html","id":"字串的format-i.e.-r的paste功能","chapter":"8 string整理與實戰","heading":"8.3 字串的format (i.e. R的paste()功能)","text":"假設我現在有兩個字串那如果我想format出一個句子是： “我是python, 我今年27歲了”，那我可以怎麼做？在R裡面就是用paste，那現在在python裡面，就有特定的format方法","code":"name = 'python'\nage = 27"},{"path":"string整理與實戰.html","id":"直接一路加號到底","chapter":"8 string整理與實戰","heading":"8.3.1 直接一路加號到底","text":"恩，可以work，但這樣寫別人會把你當北七","code":"new_str = \"我是\" + name + \"，我今年\" + str(age) + \"歲了\"\nprint(new_str)\n#> 我是python，我今年27歲了"},{"path":"string整理與實戰.html","id":"用s-d-來做","chapter":"8 string整理與實戰","heading":"8.3.2 用%s, %d 來做","text":"直接看例子：裡面的%s的s是指string，%d的d是指double，所以他會宣告對應的type，然後最後再丟對應的object介紹這個只是為了知道有這種寫法而已，這是python 2時代的寫法，現在python3也沒人這樣寫了","code":"new_str_1 = \"我是%s, 我今年%d歲了\" % (name, age)\nprint(new_str_1)\n#> 我是python, 我今年27歲了"},{"path":"string整理與實戰.html","id":"用和.format","chapter":"8 string整理與實戰","heading":"8.3.3 用{}和.format","text":"第一種寫法，照著位子順序定義第二種寫法，括號內定義variable再對應這兩種寫法，是python2 ~ python 3.6的時代的寫法，的確比python2的寫法清楚多了但一樣的，也漸漸沒人這樣寫了，因為python 3.6以後，大家就都改用以下更直覺的寫法了","code":"new_str_2 = \"我是{}, 我今年{}歲了\".format(name, age)\nprint(new_str_2)\n#> 我是python, 我今年27歲了new_str_3 = \"我是{var1}, 我今年{var2}歲了\".format(\n        var1 = name,\n        var2 = age\n)\nprint(new_str_3)\n#> 我是python, 我今年27歲了"},{"path":"string整理與實戰.html","id":"用f吧","chapter":"8 string整理與實戰","heading":"8.3.4 用f吧!","text":"太舒服了，f放在字串外面，就等於宣告他要做format，然後中括號內直接放variable，直覺阿!!!","code":"new_str_4 = f\"我是{name}, 我今年{age}歲了\"\nprint(new_str_4)\n#> 我是python, 我今年27歲了"},{"path":"string整理與實戰.html","id":"字串的join-i.e.-r的collapse","chapter":"8 string整理與實戰","heading":"8.4 字串的join (i.e. R的collapse)","text":"剛剛介紹的format，其實就是對應到R中的paste，但R的paste還有一個很好用的功能是collapse，可以把多個字串給join在一起，例如：那用python可以怎麼做呢？先示範最笨的，用for迴圈做那實際在做時，是用 .join這個method","code":"\na = c(\"I\", \"am\", \"hank\")\npaste(a, collapse = \" \")\n#> [1] \"I am hank\"\npaste(a, collapse = \"_\")\n#> [1] \"I_am_hank\"a = [\"I\", \"am\", \"hank\"]\n\nnew = \"\"\nsep = \" \"\nfor i in a:\n        new = new + i + sep\nnew\n#> 'I am hank 'print(\" \".join(a))\n#> I am hank\nprint(\"_\".join(a))\n#> I_am_hank"},{"path":"collections-overview.html","id":"collections-overview","chapter":"9 collections overview","heading":"9 collections overview","text":"在Python中，有四種collection data types (.e. arrays)\nlist: ordered, changeable, allow duplicate members\ntuple: ordered, unchangeable, allow duplicate members\nset: unordered, changeable, duplicated members\ndictionary: unordered, changeable, duplicated members\nlist: ordered, changeable, allow duplicate memberstuple: ordered, unchangeable, allow duplicate membersset: unordered, changeable, duplicated membersdictionary: unordered, changeable, duplicated members","code":""},{"path":"list整理與實戰.html","id":"list整理與實戰","chapter":"10 list整理與實戰","heading":"10 list整理與實戰","text":"list是python內建的一種collection既然是collection，我們就可以把它當資料庫看，所以會依序介紹作為資料庫最基礎的幾個part：\n如何建立？\n如何增、刪、查、改？\n如何建立？如何增、刪、查、改？這些基礎會了後，就確認一下是否為mutable物件，來決定如何做copy接著就開始介紹如何loop他(用for, comprehension)最後就是補齊這個object還沒介紹到的methods實戰的部分，就會以”…“的方式整理常見的需求","code":""},{"path":"list整理與實戰.html","id":"list定義","chapter":"10 list整理與實戰","heading":"10.1 list定義","text":"list用中括號來建立，裡面的每個元素我們叫item，item可以是不同的type，例如：list的特性有三個，ordered, changeable, allow duplicate values：\nordered: 他是有順序的，裡面的items就像排隊取號碼牌一樣，都有自己的序號(index)，此序號由0開始排起。所以如果有新成員要加入list，只能排到隊伍的最後面，用append的方式加入。要取用某個item時，也是用叫號碼牌的方式取用\nchangeable: list裡面的item是可改變的，意思是，當我建立好一個list後，我可以改變號碼牌為x的那個item的值，我也可以新增或刪除item\nallow duplicates: item是可以重複的\nordered: 他是有順序的，裡面的items就像排隊取號碼牌一樣，都有自己的序號(index)，此序號由0開始排起。所以如果有新成員要加入list，只能排到隊伍的最後面，用append的方式加入。要取用某個item時，也是用叫號碼牌的方式取用changeable: list裡面的item是可改變的，意思是，當我建立好一個list後，我可以改變號碼牌為x的那個item的值，我也可以新增或刪除itemallow duplicates: item是可以重複的","code":"a_list = [12, 3, 67, 7, 82] #同一種type的list\nanother_list = [\"happy\", 3, True, 7] #不同type的list\n\nprint(type(a_list))\n#> <class 'list'>\nprint(type(another_list))\n#> <class 'list'>"},{"path":"list整理與實戰.html","id":"建-建立list","chapter":"10 list整理與實戰","heading":"10.2 [建] 建立list","text":"","code":""},{"path":"list整理與實戰.html","id":"建立單維list","chapter":"10 list整理與實戰","heading":"10.2.1 建立單維list","text":"剛剛講過了，就用個中括號包起來就好","code":""},{"path":"list整理與實戰.html","id":"建立多維list","chapter":"10 list整理與實戰","heading":"10.2.2 建立多維list","text":"list裡面還有list，就叫多維list","code":"a = [1,2,3,4,5] # 1*5 list  \nmulti_dim_a = [[1,2,3],\n               [2,3,4],\n               [3,4,5]]\nprint(multi_dim_a)\n#> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]"},{"path":"list整理與實戰.html","id":"查-取用list裡面的item","chapter":"10 list整理與實戰","heading":"10.3 [查] 取用list裡面的item","text":"list因為只有item，沒有name(簡單來講，就是只有value，沒有key)，所以subset時，都是用index來取index就擬人化為座號，而python的編號由左至右是從0開始，由右至左是從-1開始所以我要取list中左邊數來第n個人，他的座號是n-1，那就要取n-1的index如果我要取list中右邊數來第n個人，他的座號是-n，那就要取-n的index","code":""},{"path":"list整理與實戰.html","id":"用index-0取第一個item","chapter":"10 list整理與實戰","heading":"10.3.1 用index = 0取第一個item","text":"單維list的例子：學會單維list的subset了，那多維list的subset邏輯一模一樣","code":"my_list = [\"my\", \"list\", \"is\", \"nice\"]\nmy_list[3] # 取index=3, 那就是取element = 4\n#> 'nice'multi_dim_a = [[1,2,3], [2,3,4],[3,4,5]] \nmulti_dim_a[1] # 取index = 1，即左邊數來第2個\n#> [2, 3, 4]multi_dim_a[1][0] # 先取左邊數來第2個element，再取裡面的第1個element\n#> 2"},{"path":"list整理與實戰.html","id":"用index--2取由右數來第2個","chapter":"10 list整理與實戰","heading":"10.3.2 用index = -2取由右數來第2個","text":"","code":"my_list = [\"my\", \"list\", \"is\", \"nice\"]\nmy_list[-2] # 取index -2, 即又邊數來第二個\n#> 'is'"},{"path":"list整理與實戰.html","id":"表示從index3取到index7","chapter":"10 list整理與實戰","heading":"10.3.3 3:8表示從index3取到index7","text":"剛剛是取”某一個”element，那如果我想取”某一串”element呢？那就是指slice語法是[start_index:stop_index]，所以[1:5]是指從index=1取到index=4，那就是取第2個element到第5個所以為了方便記憶，就把stop_index當作stop_element來看，然後start_index還是start_index簡單練習，[5:9]，就是指取element = 6 ~ 9然後，如果你跳過start_index不寫，就是從頭開始；跳過stop_index不寫，就是取到最後；兩個都不寫，就是全取例如： [:9]，那就是從第一個element一路取到第9個element例如: [3:]，那就是第4個element一路取到最後一個element例如: [:]，那就是整串全取(等於複製一個)slice一律只能由左至右取，但編號系統可以用正的編號(由左至右的編號系統)或負的編號(由右至左的編號系統)[1:3]是指由左至右，取element= 2~3[-2:-3]是指由右至左，取element = 右邊數來第2個 ~ 第3個?! 他只能由左至右取，所以應該寫成[-3:-2]?! 這樣他指會取右邊數來的第3個element，到右邊數來的第2個element的”前1個”!所以如果要取右邊數來第3個element到右邊數來第2個element，那要寫成[-3:-1]","code":"my_list = [\"my\", \"list\", \"is\", \"nice\"]\nmy_list[1:3] # 取 element = 2~3\n#> ['list', 'is']my_list = [\"my\", \"list\", \"is\", \"nice\"]\nmy_list[:3] # 取element = 1~3\n#> ['my', 'list', 'is']my_list = [\"my\", \"list\", \"is\", \"nice\"]\nmy_list[1:] # 取element = 2~最後\n#> ['list', 'is', 'nice']my_list = [\"my\", \"list\", \"is\", \"nice\"]\nmy_list[-3:-1]\n#> ['list', 'is']"},{"path":"list整理與實戰.html","id":"用.indexa找出a所屬的index","chapter":"10 list整理與實戰","heading":"10.3.4 用.index('a')找出’a’所屬的index","text":"在R中，我們用 (list1 == '')來找index，那在python就是用list1.index(\"\")看例子：","code":"a_list = [\"apple\", \"orange\", \"banana\"]\nmy_index = a_list.index(\"banana\")\nprint(my_index)\n#> 2"},{"path":"list整理與實戰.html","id":"用in來確認item在不在list裡","chapter":"10 list整理與實戰","heading":"10.3.5 用in來確認item在不在list裡","text":"這邊的in，就是R的%%","code":"thislist = [\"apple\", \"banana\", \"cherry\"]\nif \"apple\" in thislist:\n  print(\"Yes, 'apple' is in the fruits list\")\n#> Yes, 'apple' is in the fruits list"},{"path":"list整理與實戰.html","id":"改-修改list裡面的item","chapter":"10 list整理與實戰","heading":"10.4 [改] 修改list裡面的item","text":"剛剛已經學會如何取出list中的特定一個element，或是一串element，那我們就可以利用這個技巧，把新值assign到指定位置：同樣的，可以一次改動多個位子的值","code":"my_list = [\"my\", \"list\", \"is\", \"nice\"]\nmy_list[3] = \"bad\"\nmy_list\n#> ['my', 'list', 'is', 'bad']my_list[1:] = [\"lists\", \"are\", \"awsome\"]\nmy_list\n#> ['my', 'lists', 'are', 'awsome']"},{"path":"list整理與實戰.html","id":"增-增加list裡面的item","chapter":"10 list整理與實戰","heading":"10.5 [增] 增加list裡面的item","text":"","code":""},{"path":"list整理與實戰.html","id":"加到最後面用.append","chapter":"10 list整理與實戰","heading":"10.5.1 加到最後面，用.append()","text":"例如下例：不要傻傻的，用[old_list, \"new_item\"]，這樣會變多維list","code":"thislist = [\"apple\", \"banana\", \"cherry\"]\nthislist.append(\"orange\")\nprint(thislist)\n#> ['apple', 'banana', 'cherry', 'orange']old_list = [\"apple\", \"banana\", \"cherry\"]\nnew_list = [old_list, \"orange\"]\nprint(new_list)\n#> [['apple', 'banana', 'cherry'], 'orange']"},{"path":"list整理與實戰.html","id":"加到指定的位置用.insert","chapter":"10 list整理與實戰","heading":"10.5.2 加到指定的位置，用.insert()","text":"","code":"thislist = [\"apple\", \"banana\", \"cherry\"]\nthislist.insert(1, \"orange\")\nprint(thislist)\n#> ['apple', 'orange', 'banana', 'cherry']"},{"path":"list整理與實戰.html","id":"增-join兩個list","chapter":"10 list整理與實戰","heading":"10.6 [增] join兩個list","text":"拜託，不要用[list1, list2]，這不是R(用c(vec1, vec2))，這樣寫會造出多維list用+是最簡單的做法：用.extend也ok而.extend其實是去loop後面的iterable，依序將後面的每個element加入到前面的list中，所以後面只要放iterable即可，不一定要放list。舉例來說，我放tuple也ok:如果你要用.append，那就得自己寫回圈：","code":"list1 = [\"a\", \"b\", \"c\"]\nlist2 = [1, 2, 3]\n[list1, list2]\n#> [['a', 'b', 'c'], [1, 2, 3]]list1 = [\"a\", \"b\", \"c\"]\nlist2 = [1, 2, 3]\n\nlist3 = list1 + list2\nprint(list3)\n#> ['a', 'b', 'c', 1, 2, 3]list1 = [\"a\", \"b\", \"c\"]\nlist2 = [1, 2, 3]\nlist1.extend(list2)\nprint(list1)\n#> ['a', 'b', 'c', 1, 2, 3]thislist = [\"apple\", \"banana\", \"cherry\"]\nthistuple = (\"kiwi\", \"orange\")\nthislist.extend(thistuple)\nprint(thislist)\n#> ['apple', 'banana', 'cherry', 'kiwi', 'orange']list1 = [\"a\", \"b\" , \"c\"]\nlist2 = [1, 2, 3]\n\nfor x in list2:\n  list1.append(x)\n\nprint(list1)\n#> ['a', 'b', 'c', 1, 2, 3]"},{"path":"list整理與實戰.html","id":"刪-刪除list裡面的item","chapter":"10 list整理與實戰","heading":"10.7 [刪] 刪除list裡面的item","text":"","code":""},{"path":"list整理與實戰.html","id":"removeitem-刪除該item","chapter":"10 list整理與實戰","heading":"10.7.1 .remove(item) 刪除該item","text":"","code":"thislist = [\"apple\", \"banana\", \"cherry\"]\nthislist.remove(\"banana\")\nprint(thislist)\n#> ['apple', 'cherry']"},{"path":"list整理與實戰.html","id":"pop-刪除最後一筆","chapter":"10 list整理與實戰","heading":"10.7.2 .pop() 刪除最後一筆","text":"","code":"thislist = [\"apple\", \"banana\", \"cherry\"]\nthislist.pop()\n#> 'cherry'\nprint(thislist)\n#> ['apple', 'banana']"},{"path":"list整理與實戰.html","id":"popindex-刪除該index","chapter":"10 list整理與實戰","heading":"10.7.3 .pop(index) 刪除該index","text":"","code":"thislist = [\"apple\", \"banana\", \"cherry\"]\nthislist.pop(1)\n#> 'banana'\nprint(thislist)\n#> ['apple', 'cherry']"},{"path":"list整理與實戰.html","id":"del-listindex-刪除該list中的此index","chapter":"10 list整理與實戰","heading":"10.7.4 del list[index] 刪除該list中的此index","text":"","code":"thislist = [\"apple\", \"banana\", \"cherry\"]\ndel thislist[0]\nprint(thislist)\n#> ['banana', 'cherry']"},{"path":"list整理與實戰.html","id":"clear-清空此list內所有item","chapter":"10 list整理與實戰","heading":"10.7.5 .clear() 清空此list內所有item","text":"","code":"thislist = [\"apple\", \"banana\", \"cherry\"]\nthislist.clear()\nprint(thislist)\n#> []"},{"path":"list整理與實戰.html","id":"mutable-copy-list","chapter":"10 list整理與實戰","heading":"10.8 [mutable] copy list","text":"在討論mutable或inmuatable的問題時，都是在討論當你把原物件copy一次後，對新copy的物件做事，會不會影響到舊物件(.e. list1_copy = list1，那對list1_copy做修改時，list1會不會跟著動？)而對list來說，就是會，因為variable name只是一個reference，指到記憶體位置，所以原物件和copy後的物件，其實都指到同一個位置，那你一改他，兩個variable就都會跟著動所以對mutable object，請愛用list1_copy = list1.copy()，或是用list1_copy = list(list1)來做copy，不要用list1_copy = list1來做copy：","code":"old_list = [1, 2, 3]\nbad_new_list = old_list\nold_list.pop()\n#> 3\nprint(old_list)\n#> [1, 2]\nprint(bad_new_list)\n#> [1, 2]old_list = [1, 2, 3]\nnew_list = old_list.copy()\n\nnew_list.pop()\n#> 3\nprint(new_list)\n#> [1, 2]\nprint(old_list)\n#> [1, 2, 3]"},{"path":"list整理與實戰.html","id":"loop-for","chapter":"10 list整理與實戰","heading":"10.9 [loop] for","text":"","code":""},{"path":"list整理與實戰.html","id":"loop-index","chapter":"10 list整理與實戰","heading":"10.9.1 loop index","text":"R的觀點來做迭代，習慣取index，那就會寫成下面這樣：len(a_list)得到他的長度=3，而range(3)表示由0開始stop在3，所以就得到0,1,2這3個index","code":"a_list = [\"apple\", \"banana\", \"cherry\"]\nfor index in range(len(a_list)): \n    print(index)"},{"path":"list整理與實戰.html","id":"loop-items","chapter":"10 list整理與實戰","heading":"10.9.2 loop items","text":"但python的觀點，都是直接取裡面的items做迭代，那就會寫成這樣：","code":"for item in a_list:\n    print(item)"},{"path":"list整理與實戰.html","id":"enumerate","chapter":"10 list整理與實戰","heading":"10.9.3 enumerate()","text":"最後，python才有的，又取index，又取item，語法是： enumerate","code":"for index, item in enumerate(a_list):\n    print(\"index = \", index, \", number in list = \", item)"},{"path":"list整理與實戰.html","id":"loop-list-comprehension","chapter":"10 list整理與實戰","heading":"10.10 [loop] list comprehension","text":"","code":""},{"path":"list整理與實戰.html","id":"simple-example","chapter":"10 list整理與實戰","heading":"10.10.1 simple example","text":"簡單講，就是把for loop簡化成一行的版本例如以下的例子，我已有一個字串list，然後我想取出每個item的第一個字母，變成新的list，那用for回圈寫會長這樣：那如果用list comprehension，就寫成以下這樣：帥…還真的一行幹掉，我們首先來教要怎麼閱讀這種code。在閱讀上，我們要先辨認出三個結構：\n要output出來的data structure，寫在最外面，也就是我們看到的中括號，告訴我們他要output成一個list\nloop要iterate的part，也就是在最後面看到的for doc doctor。其中doctor叫做iterable，doc叫iterator variable(代表iterable中的member)\n每iterate完一個，要output出什麼，也就是最前面看到的doc[0]，這部分我們叫”output expression”\n要output出來的data structure，寫在最外面，也就是我們看到的中括號，告訴我們他要output成一個listfor loop要iterate的part，也就是在最後面看到的for doc doctor。其中doctor叫做iterable，doc叫iterator variable(代表iterable中的member)每iterate完一個，要output出什麼，也就是最前面看到的doc[0]，這部分我們叫”output expression”了解一個list comprehension是由這三個組成後，閱讀的順序就會變成：\n先讀要for loop的地方，所以知道他要做的是for doc doctor\n再讀每iterate完一次，要output什麼東西出來，所以從doc[0]可知，要丟第一個字母出來\n最後，看到最外面是中括號，就知道要把這些結果，搜集成list\n先讀要for loop的地方，所以知道他要做的是for doc doctor再讀每iterate完一次，要output什麼東西出來，所以從doc[0]可知，要丟第一個字母出來最後，看到最外面是中括號，就知道要把這些結果，搜集成list所以，總結起來，list comprehension是由以下的pattern組合而成：[\"output expression\"  \"iterator variable\" \"iterable\" ]有了這個概念後，就可以開始練習把傳統的for loop轉成list comprehension了","code":"doctor = ['house', 'cuddy', 'chase', 'thirteen', 'wilson']\n\n# 目標：抓出每個element中的第一個字  \nfirst = []\nfor doc in doctor:\n    first.append(doc[0])\nprint(first)\n#> ['h', 'c', 'c', 't', 'w']list_comp = [doc[0] for doc in doctor]\nprint(list_comp)\n#> ['h', 'c', 'c', 't', 'w']"},{"path":"list整理與實戰.html","id":"nested-for-loop","chapter":"10 list整理與實戰","heading":"10.10.2 nested for loop","text":"像這種兩個for回圈，寫成list comprehension時，可以這樣寫：","code":"pairs_1 = []\nfor num1 in range(0, 2):\n    for num2 in range(6, 8):\n        pairs_1.append((num1, num2))\nprint(pairs_1)\n#> [(0, 6), (0, 7), (1, 6), (1, 7)]pairs_2 = [(num1,num2) for num1 in range(0,2) for num2 in range(6,8)]\nprint(pairs_2)\n#> [(0, 6), (0, 7), (1, 6), (1, 7)]"},{"path":"list整理與實戰.html","id":"conditional-for-loop","chapter":"10 list整理與實戰","heading":"10.10.3 conditional for loop","text":"如果for回圈裡面，有if, -else, -elif-else的話，可以寫成list comprehension嗎？答案是，if和if-else可以，但if-elif-else不行。而且if和if-else的寫法有特定pattern，兩者寫法不同，吞下去就對了","code":""},{"path":"list整理與實戰.html","id":"if","chapter":"10 list整理與實戰","heading":"10.10.3.1 if","text":"那同樣的結構，當然可以用list comprehension來寫了，就是先for，再if之前有說過第一塊要放output expression，所以，比較正確的做法，應該是寫member len(member)>=7 member fellowship才對，但…就不能這樣寫。反而，在if-else時，一定要這樣寫。","code":"fellowship = ['frodo', 'samwise', 'merry', 'aragorn', 'legolas', 'boromir', 'gimli']\n\n#我現在想重新建立一個list，裡面的element，都要是字數>=7的我才收進來，那就用for loop 加上 if吧！  \n\nfellowship_for_if = []\nfor member in fellowship:\n    if len(member) >= 7:\n        fellowship_for_if.append(member)\n\nprint(fellowship_for_if)\n#> ['samwise', 'aragorn', 'legolas', 'boromir']fellowship_list_comprehension = [member for member in fellowship if len(member)>=7]\n#                          2. output expression為member      1.iteration part        \n\n# Print the new list\nprint(fellowship_list_comprehension)\n#> ['samwise', 'aragorn', 'legolas', 'boromir']"},{"path":"list整理與實戰.html","id":"if-else","chapter":"10 list整理與實戰","heading":"10.10.3.2 if-else","text":"","code":"new_fellowship = [member if len(member) >= 7 else '' for member in fellowship]\n#               |----expression part想呈現成這樣----| |---iteration part-------|\n\n# Print the new list\nprint(new_fellowship)\n#> ['', 'samwise', '', 'aragorn', 'legolas', 'boromir', '']"},{"path":"list整理與實戰.html","id":"排序.sort","chapter":"10 list整理與實戰","heading":"10.11 排序(.sort())","text":"","code":""},{"path":"list整理與實戰.html","id":"sort","chapter":"10 list整理與實戰","heading":"10.11.1 .sort()","text":"字串型的list，就是照字母順序由小到大數值型就照大小，由小到大","code":"thislist = [\"orange\", \"mango\", \"kiwi\", \"pineapple\", \"banana\"]\nthislist.sort()\nprint(thislist)\n#> ['banana', 'kiwi', 'mango', 'orange', 'pineapple']thislist = [100, 50, 65, 82, 23]\nthislist.sort()\nprint(thislist)\n#> [23, 50, 65, 82, 100]"},{"path":"list整理與實戰.html","id":"sortreverse-true","chapter":"10 list整理與實戰","heading":"10.11.2 .sort(reverse = True)","text":"倒過來牌，用reverse = True (不是descending = TRUE)","code":"thislist = [100, 50, 65, 82, 23]\nthislist.sort(reverse = True)\nprint(thislist)\n#> [100, 82, 65, 50, 23]"},{"path":"list整理與實戰.html","id":"sortkey-my_func","chapter":"10 list整理與實戰","heading":"10.11.3 .sort(key = my_func)","text":"我們可以自己定義一個function，讓list裡面的每個item，都先做完這個運算後，再排序例如，我想讓我的list items，依照距離50這個數值的遠近排列：","code":"def myfunc(n):\n  return abs(n - 50)\n\nthislist = [100, 50, 65, 82, 23]\nthislist.sort(key = myfunc)\nprint(thislist)\n#> [50, 65, 23, 82, 100]"},{"path":"list整理與實戰.html","id":"順序倒過來.reverse","chapter":"10 list整理與實戰","heading":"10.12 順序倒過來(.reverse())","text":"如果我想把一個list，左右顛倒，就可以用.reverse","code":"my_list = [1, 2, 3, 4, 5]\nmy_list.reverse()\nprint(my_list)\n#> [5, 4, 3, 2, 1]"},{"path":"list整理與實戰.html","id":"list.counta-計算a在list中出現幾次","chapter":"10 list整理與實戰","heading":"10.13 list.count(‘a’) = 計算’a’在list中出現幾次","text":"","code":"a_list = [\"apple\", \"orange\", \"banana\", \"banana\"]\nnew = a_list.count(\"banana\")\nprint(new)\n#> 2"},{"path":"list整理與實戰.html","id":"practice","chapter":"10 list整理與實戰","heading":"10.14 Practice","text":"現在來做個簡單的練習，在tweets.csv中，有一個欄位是created_at，是說這個訊息在幾點幾分建立的，我們看一下：現在，假如我想抓出”時間”的資訊就好，也就是第12~19個element，我可以怎麼做呢？先建一個空list，然後用for回圈，對每個element都抓12~19的字元，append回這個空list？sure，當然可以，但好遜，我們用list comprehension不就好了？nice，那如果我現在龜毛一點，我想抓hh:mm:ss中的ss=17的就好，怎麼做？","code":"import pandas as pd\ndf = pd.read_csv(\"./data/tweets.csv\")\ntweet_time = df[\"created_at\"]result = [entry[11:19] for entry in tweet_time]\nprint(result[0:10])\n#> ['23:40:17', '23:40:17', '23:40:17', '23:40:17', '23:40:17', '23:40:17', '23:40:18', '23:40:17', '23:40:18', '23:40:18']result2 = [entry[11:19] for entry in tweet_time if entry[17:19]=='17']\nprint(result2)\n#> ['23:40:17', '23:40:17', '23:40:17', '23:40:17', '23:40:17', '23:40:17', '23:40:17', '23:40:17', '23:40:17', '23:40:17', '23:40:17', '23:40:17', '23:40:17']"},{"path":"tuple整理與實戰.html","id":"tuple整理與實戰","chapter":"11 tuple整理與實戰","heading":"11 tuple整理與實戰","text":"tuple是python內建的一種collection既然是collection，我們就可以把它當資料庫看，所以會依序介紹作為資料庫最基礎的幾個part：\n如何建立？\n如何增、刪、查、改？\n如何建立？如何增、刪、查、改？這些基礎會了後，就確認一下是否為mutable物件，來決定如何做copy接著就開始介紹如何loop他(用for, comprehension)最後就是補齊這個object還沒介紹到的methods實戰的部分，就會以”…“的方式整理常見的需求","code":""},{"path":"tuple整理與實戰.html","id":"建-tuple定義與創建","chapter":"11 tuple整理與實戰","heading":"11.1 [建] tuple定義與創建","text":"tuple用小括號來創建，例如：特別提醒，如果只有一個元素，那必須加上逗號才會是tupletuple的特色是\nordered: 所以他也是用index來取裡面的items\nunchangeable: 這是他最大的特色，不可修改。所以你要改裡面的item，或是要新增/刪除item，都是不允許的\nallow duplicate: tuple裡面的item可以重複\nordered: 所以他也是用index來取裡面的itemsunchangeable: 這是他最大的特色，不可修改。所以你要改裡面的item，或是要新增/刪除item，都是不允許的allow duplicate: tuple裡面的item可以重複","code":"my_tuple = (\"apple\", \"banana\", \"cherry\")\nprint(my_tuple)\n#> ('apple', 'banana', 'cherry')\nprint(type(my_tuple))\n#> <class 'tuple'>thistuple = (\"apple\",)\nprint(type(thistuple))\n\n#NOT a tuple\n#> <class 'tuple'>\nthistuple = (\"apple\")\nprint(type(thistuple))\n#> <class 'str'>"},{"path":"tuple整理與實戰.html","id":"主要用在保護數據和unpack","chapter":"11 tuple整理與實戰","heading":"11.2 主要用在保護數據和unpack","text":"已經有了list，為何還要tuple？有以下三個時機用tuple比list好\ntuple比list快，所以element爆多時，可以選tuple: tuple會比較快的原因是，他不可修改，所以建立tuple時，會開”一個”大小固定的記憶體空間給他。但如果是建立list，會開”兩個”記憶體空間，一個是給實際的list數據，另一個是拿來當擴展使用的。所以tuple較快，但list較彈性\ntuple不可修改，所以比較安全：如果我們寫程式時，有一段資料要重複使用(e.g. 已經設定好的一組黃金參數)，那就傾向用tuple，因為沒有人可以修改他。但如果用list，就很怕出亂子\n寫function時，tuple有unpack的特性，可以unpack tuple several variables!先看例子：\ntuple比list快，所以element爆多時，可以選tuple: tuple會比較快的原因是，他不可修改，所以建立tuple時，會開”一個”大小固定的記憶體空間給他。但如果是建立list，會開”兩個”記憶體空間，一個是給實際的list數據，另一個是拿來當擴展使用的。所以tuple較快，但list較彈性tuple不可修改，所以比較安全：如果我們寫程式時，有一段資料要重複使用(e.g. 已經設定好的一組黃金參數)，那就傾向用tuple，因為沒有人可以修改他。但如果用list，就很怕出亂子寫function時，tuple有unpack的特性，可以unpack tuple several variables!先看例子：這個的好處是，寫function時，要return的東西如果是多個variable，在R就會寫成list，然後之後就要用錢字號去取裡面的每個element。但在python，就喜歡return一個tuple，然後之後用unpack的特性去接這些結果：那實際使用這個function時，就會這樣做：最後講一個小trick，如果要assign的variable個數，小於吐出來的value的個數怎辦？可以把星號加在某個variable前面，就會把剩餘的value全包給那個變數:","code":"fruits = (\"apple\", \"banana\", \"cherry\")\n\ngreen, yellow, red = fruits\n\nprint(green)\n#> apple\nprint(yellow)\n#> banana\nprint(red)\n#> cherrydef raise_both(value1, value2):\n  \"\"\"\n  Raise value1 to the power of value2\n  and vice versa.\n  \"\"\"\n  \n  new_value1 = value1 ** value2\n  new_value2 = value2 ** value1\n  \n  new_tuple = (new_value1, new_value2)\n  \n  return new_tupleresult1, result2 = raise_both(2,3)\nprint(result1)\n#> 8\nprint(result2)\n#> 9fruits = (\"apple\", \"banana\", \"cherry\", \"strawberry\", \"raspberry\")\n\n(green, yellow, *red) = fruits\n\nprint(green)\n#> apple\nprint(yellow)\n#> banana\nprint(red)\n#> ['cherry', 'strawberry', 'raspberry']"},{"path":"tuple整理與實戰.html","id":"查-取用tuple中的item","chapter":"11 tuple整理與實戰","heading":"11.3 [查] 取用tuple中的item","text":"tuple在查的部分，和list是一模一樣的","code":""},{"path":"tuple整理與實戰.html","id":"用list1index取數據","chapter":"11 tuple整理與實戰","heading":"11.3.1 用list1[index]取數據","text":"","code":"thistuple = (\"apple\", \"banana\", \"cherry\")\nprint(thistuple[1])\n#> banana"},{"path":"tuple整理與實戰.html","id":"用負號往回取","chapter":"11 tuple整理與實戰","heading":"11.3.2 用負號往回取","text":"","code":"thistuple = (\"apple\", \"banana\", \"cherry\")\nprint(thistuple[-1])\n#> cherry"},{"path":"tuple整理與實戰.html","id":"是指取index2到index4","chapter":"11 tuple整理與實戰","heading":"11.3.3 2:5是指取index=2到index=4","text":"","code":"thistuple = (\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\")\nprint(thistuple[2:5])\n#> ('cherry', 'orange', 'kiwi')"},{"path":"tuple整理與實戰.html","id":"找index用.indexa","chapter":"11 tuple整理與實戰","heading":"11.3.4 找index用.index('a')","text":"","code":"thistuple = (\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\")\nthistuple.index(\"banana\")\n#> 1"},{"path":"tuple整理與實戰.html","id":"確認每個item有沒有在tuple內也是用in","chapter":"11 tuple整理與實戰","heading":"11.3.5 確認每個item有沒有在tuple內也是用in","text":"","code":"thistuple = (\"apple\", \"banana\", \"cherry\")\nif \"apple\" in thistuple:\n  print(\"Yes, 'apple' is in the fruits tuple\")\n#> Yes, 'apple' is in the fruits tuple"},{"path":"tuple整理與實戰.html","id":"改-增-刪-tuple不可修改","chapter":"11 tuple整理與實戰","heading":"11.4 [改, 增, 刪] tuple不可修改","text":"tuple是unchangable，所以不能改，不能增，也不能刪如果真的要改，就要先轉成list，再轉回tuple，但有點脫褲子放屁拉","code":"x = (\"apple\", \"banana\", \"cherry\")\nx[0] = \"orange\"\n#> Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: 'tuple' object does not support item assignment\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>x = (\"apple\", \"banana\", \"cherry\")\ny = list(x)\ny[0] = \"orange\"\nx = tuple(y)\n\nprint(x)\n#> ('orange', 'banana', 'cherry')"},{"path":"tuple整理與實戰.html","id":"immutable","chapter":"11 tuple整理與實戰","heading":"11.5 immutable","text":"tuple根本不能改，所以其實不太需要去討論tuple1_copy = tuple1之後，改動tuple1_copy會不會影響到tuple1的問題","code":""},{"path":"tuple整理與實戰.html","id":"loop-for回圈","chapter":"11 tuple整理與實戰","heading":"11.6 [loop] for回圈","text":"loop indexloop itemsloop index & items","code":"a_tuple = (\"apple\", \"banana\", \"cherry\")\nfor index in range(len(a_tuple)): \n    print(index)\n#> 0\n#> 1\n#> 2a_tuple = (\"apple\", \"banana\", \"cherry\")\nfor item in a_tuple:\n    print(item)\n#> apple\n#> banana\n#> cherrya_tuple = (\"apple\", \"banana\", \"cherry\")\nfor index, item in enumerate(a_tuple):\n    print(\"index = \", index, \", number in tuple = \", item)\n#> index =  0 , number in tuple =  apple\n#> index =  1 , number in tuple =  banana\n#> index =  2 , number in tuple =  cherry"},{"path":"tuple整理與實戰.html","id":"loop-comprehension","chapter":"11 tuple整理與實戰","heading":"11.7 [loop] comprehension","text":"tuple可以做list comprehension嗎？之後再釐清，依樣畫葫蘆的結果，竟然是吐一個generator給我！？","code":"doctor = ['house', 'cuddy', 'chase', 'thirteen', 'wilson']\n\n# 目標：抓出每個element中的第一個字  \ndoc_tuple = (doc[0] for doc in doctor)\n\nprint(doc_tuple)\n#> <generator object <genexpr> at 0x11a3f1040>"},{"path":"tuple整理與實戰.html","id":"join兩個tuple用加號","chapter":"11 tuple整理與實戰","heading":"11.8 join兩個tuple用加號","text":"","code":"tuple1 = (\"a\", \"b\" , \"c\")\ntuple2 = (1, 2, 3)\n\ntuple3 = tuple1 + tuple2\nprint(tuple3)\n#> ('a', 'b', 'c', 1, 2, 3)"},{"path":"dictionary整理與實戰.html","id":"dictionary整理與實戰","chapter":"12 dictionary整理與實戰","heading":"12 dictionary整理與實戰","text":"dictionary是python內建的一種collection既然是collection，我們就可以把它當資料庫看，所以會依序介紹作為資料庫最基礎的幾個part：\n如何建立？\n如何增、刪、查、改？\n如何建立？如何增、刪、查、改？這些基礎會了後，就確認一下是否為mutable物件，來決定如何做copy接著就開始介紹如何loop他(用for, comprehension)最後就是補齊這個object還沒介紹到的methods實戰的部分，就會以”…“的方式整理常見的需求","code":""},{"path":"dictionary整理與實戰.html","id":"dict的定義","chapter":"12 dictionary整理與實戰","heading":"12.1 dict的定義","text":"dictionary就是JSON的key-value pair資料表示法(也可想成R的list)dictionary裡面的每個element，我們仍然叫他”item”。所以一個item，就是一組key-value pairdictionary的特性:\nordered: 在python 3.7以後，dictionary是ordered; 在python 3.6以前，dictionary是unordered。事實上，我還是傾向將dict看成無順序的，因為我們取用裡面的資料還是用key，不是用座號(index)\nchangeable: 可以改裡面的內容，可以增加，可以刪除\nallow duplicates\nordered: 在python 3.7以後，dictionary是ordered; 在python 3.6以前，dictionary是unordered。事實上，我還是傾向將dict看成無順序的，因為我們取用裡面的資料還是用key，不是用座號(index)changeable: 可以改裡面的內容，可以增加，可以刪除does allow duplicatesdictionary和list的差別在於：\ndictionary用 {}表示，list用[]表示\ndictionary沒有順序性，list有\ndictionary一定是key-value的pair，他是index key(所以你要select他的element，是輸入key); list是index number(所以你要select他的element，是輸入index number)\ndictionary的key是immutable，value是mutable，而list全都是mutable\ndictionary用 {}表示，list用[]表示dictionary沒有順序性，list有dictionary一定是key-value的pair，他是index key(所以你要select他的element，是輸入key); list是index number(所以你要select他的element，是輸入index number)dictionary的key是immutable，value是mutable，而list全都是mutable","code":"my_dict = {\n  \"name\": \"Hank\",\n  \"id\": 19002329,\n  \"dept\": \"AW0010\",\n  \"dog\": True\n}\n\nprint(my_dict)\n#> {'name': 'Hank', 'id': 19002329, 'dept': 'AW0010', 'dog': True}\nprint(type(my_dict))\n#> <class 'dict'>"},{"path":"dictionary整理與實戰.html","id":"建-dict的創建","chapter":"12 dictionary整理與實戰","heading":"12.2 [建] dict的創建","text":"","code":""},{"path":"dictionary整理與實戰.html","id":"直接用","chapter":"12 dictionary整理與實戰","heading":"12.2.1 直接用","text":"創建dictionary時，key必須是immutable，所以key可以是int, string, tupple，但key不可以是list這種mutable","code":"a = {\n        1: 'a',\n        2: 'b',\n        '3': 'c',\n        (2,3,4): 'haha'\n}\na\n#> {1: 'a', 2: 'b', '3': 'c', (2, 3, 4): 'haha'}b = {\n        [2,3,4]: 'haha',\n        'two': 2\n}\n#> Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: unhashable type: 'list'\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>\nb\n#> Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'b' is not defined\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>"},{"path":"dictionary整理與實戰.html","id":"用dicta2-bhaha來建立","chapter":"12 dictionary整理與實戰","heading":"12.2.2 用dict(a=2, b=\"haha\")來建立","text":"此外，我們可以用dict()來創建空字典(初始化字典)可以看到，這種寫法就和R的 list(=2, b=3, c=\"0\")一模一樣了","code":"d = dict()\nprint(d)\n#> {}d = dict(a=2, b=3, c=\"0\")\nd\n#> {'a': 2, 'b': 3, 'c': '0'}"},{"path":"dictionary整理與實戰.html","id":"用dictiterable_pair來創建","chapter":"12 dictionary整理與實戰","heading":"12.2.3 用dict(iterable_pair)來創建","text":"我們可以給dict()一個iterable物件，然後這個物件裡都是一個一個pair舉例來說這樣：那除了用list這種iterable，我們其實更喜歡用tuple，例如這樣：有了這兩個基礎後，就可以來學用zip來建立字典了先來看看zip是什麼水喔，所以可以猜測，zip(y,x)的結果，應該就是[(‘’, 1), (‘b’, 2), (‘c’, 3), (‘d’, 4)]這種iterable object那所以，我如果想要建立dictionary，就可以：其實，最重要的重點倒不是zip，而是要學會將pair資料轉成dictionary(用dict())例如，以後看到下面這種資料結構就不要怕，一秒轉成dictionary","code":"x = [['a', 1],['b',2]] #x是list，為iterable，裡面的每個element，都是個pair\nc2 = dict(x)\nprint(c2)\n#> {'a': 1, 'b': 2}y = (('a', 1),('b',2)) #x是tuple，為iterable，且裡面的每個element，都是個pair\nc3 = dict(y)\nprint(c3)\n#> {'a': 1, 'b': 2}x = [1, 2, 3, 4]\ny = ['a', 'b', 'c', 'd']\nfor i in zip(y,x):\n        print(i)\n#> ('a', 1)\n#> ('b', 2)\n#> ('c', 3)\n#> ('d', 4)dict(zip(y,x))\n#> {'a': 1, 'b': 2, 'c': 3, 'd': 4}tup = (\n        (\"li\", 90),\n        (\"wang\", 100),\n        (\"cheng\", 73),\n        (\"chen\", 44)\n)\ndict(tup)\n#> {'li': 90, 'wang': 100, 'cheng': 73, 'chen': 44}"},{"path":"dictionary整理與實戰.html","id":"查-用d.keys-d.values-d.items查詢","chapter":"12 dictionary整理與實戰","heading":"12.3 [查] 用d.keys(), d.values(), d.items()查詢","text":"","code":""},{"path":"dictionary整理與實戰.html","id":"keys可以得到最外層的所有key值","chapter":"12 dictionary整理與實戰","heading":"12.3.1 .keys()可以得到最外層的所有key值","text":"只有一層的dictionary，不易外的就是給我他的key值但像這種nested dictionary，他只會給我最外層的key值","code":"d = dict(a=2, b=3, c=\"0\")\nprint(d.keys())\n#> dict_keys(['a', 'b', 'c'])tt = {\n        1: {\n                2: {},\n                3: {}\n        },\n        4: {\n            5:{\n                    6:{},\n                    7:{}\n            }    \n        }\n}\ntt\n#> {1: {2: {}, 3: {}}, 4: {5: {6: {}, 7: {}}}}print(tt.keys())\n#> dict_keys([1, 4])"},{"path":"dictionary整理與實戰.html","id":"values可以得到所有value","chapter":"12 dictionary整理與實戰","heading":"12.3.2 .values()可以得到所有value","text":"對於一層的dictionary，不意外的得到所有values對於nested dictionary，他就是print出第二層的東西而已(因為第二層就是第一層的value)","code":"d = dict(a=2, b=3, c=\"0\")\nprint(d.values())\n#> dict_values([2, 3, '0'])print(tt.values())\n#> dict_values([{2: {}, 3: {}}, {5: {6: {}, 7: {}}}])"},{"path":"dictionary整理與實戰.html","id":"items可以得到keyvalue的tupple","chapter":"12 dictionary整理與實戰","heading":"12.3.3 .items()可以得到(key,value)的tupple","text":"dictionary裡面的每個element，我們叫他item。一個item，就是一個key-value pair所以，不意外的，用.items()可以得到這組pair","code":"d = dict(a=2, b=3, c=\"0\")\nprint(d.items())\n#> dict_items([('a', 2), ('b', 3), ('c', '0')])"},{"path":"dictionary整理與實戰.html","id":"查-用d.getkey來取用dict裡面的item","chapter":"12 dictionary整理與實戰","heading":"12.4 [查] 用d.get(\"key\")來取用dict裡面的item","text":"通常我們在取用dictionary裡面的item時，我們都是給key，求value (因為key是唯一值)，不太會，給value，求key(因為value不唯一)那通常都是先學到用d['key']來獲取value，用 d['new_key'] = new_value來修改值但這邊衍伸兩個重點\n實務上，不會用d['key']來獲取value，而是用d.get('key')來獲取value，理由等下說明\n既然可用d['new_key'] = new_value來更改dictionary，表示dictionary也是mutable，所以他不能當另一個字典的key。例如，你不可寫e = {d: 'haha'}，因為d現在是mutable object了\n實務上，不會用d['key']來獲取value，而是用d.get('key')來獲取value，理由等下說明既然可用d['new_key'] = new_value來更改dictionary，表示dictionary也是mutable，所以他不能當另一個字典的key。例如，你不可寫e = {d: 'haha'}，因為d現在是mutable object了現在先來講第一個重點，.get的運用假設我們現在創建一個dictionary那我想獲取name所對應的value，傳統上就會這樣寫看起來沒問題。但如果今天我手殘，打成’Name”，那就會報error這在運行程式時，是一個困擾，因為有時候我們不確定有哪些key，但我就都想try try看，那一error程式就停了所以，用.get('key')時，有抓到的，他會回傳value，沒抓到的，他會回傳None(注意，None是python一個特殊的type，可以想成R的NA這種特殊type)","code":"d = {\n        \"name\": \"Hank\",\n        \"ok\": \"no problem\"\n}\nd\n#> {'name': 'Hank', 'ok': 'no problem'}d['name']\n#> 'Hank'd['Name']\n#> Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: 'Name'\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>print(d.get('name'))\n#> Hank\nprint(d.get('Name'))\n#> None"},{"path":"dictionary整理與實戰.html","id":"改-修改dict裡面的item","chapter":"12 dictionary整理與實戰","heading":"12.5 [改] 修改dict裡面的item","text":"要改dictionary裡面的值，可以指定key來改：也可以用.update()的方法，覆蓋過去","code":"thisdict = {\n  \"brand\": \"Ford\",\n  \"model\": \"Mustang\",\n  \"year\": 1964\n}\nthisdict[\"year\"] = 2018\n\nprint(thisdict)\n#> {'brand': 'Ford', 'model': 'Mustang', 'year': 2018}thisdict = {\n  \"brand\": \"Ford\",\n  \"model\": \"Mustang\",\n  \"year\": 1964\n}\nthisdict.update({\"year\": 2020})\n\nprint(thisdict)\n#> {'brand': 'Ford', 'model': 'Mustang', 'year': 2020}"},{"path":"dictionary整理與實戰.html","id":"增-增加dict的item","chapter":"12 dictionary整理與實戰","heading":"12.6 [增] 增加dict的item","text":"","code":""},{"path":"dictionary整理與實戰.html","id":"dnew_key-new_value","chapter":"12 dictionary整理與實戰","heading":"12.6.1 d[\"new_key\"] = new_value","text":"就像剛剛的修改一樣，我們可以指定”新的key”，來做到新增","code":"thisdict = {\n  \"brand\": \"Ford\",\n  \"model\": \"Mustang\",\n  \"year\": 1964\n}\nthisdict[\"color\"] = \"red\"\n\nprint(thisdict)\n#> {'brand': 'Ford', 'model': 'Mustang', 'year': 1964, 'color': 'red'}"},{"path":"dictionary整理與實戰.html","id":"update可以合併2個字典","chapter":"12 dictionary整理與實戰","heading":"12.6.2 .update()可以合併2個字典","text":"或是，用.update()，直接合併新的資料進來如果update中的字典，和之前的字典有重複的key，那會直接覆蓋過去(所以，就是做到修改)","code":"a = {\n        1: 1,\n        2: 2\n}\nb = {\n        3: 3,\n        4: 4\n}\na.update(b)\nprint(a)\n#> {1: 1, 2: 2, 3: 3, 4: 4}a = {\n        1: 1,\n        2: 2\n}\nb = {\n        1: 3,\n        4: 4\n}\na.update(b)\nprint(a)\n#> {1: 3, 2: 2, 4: 4}"},{"path":"dictionary整理與實戰.html","id":"d1-d2-d3合併多個字典","chapter":"12 dictionary整理與實戰","heading":"12.6.3 {**d1, **d2, **d3}合併多個字典","text":"當我們有多個字典時，當然還是可用.update()來兩倆合併，但有點笨：比較好的作法是這樣：","code":"d1 = {'name': 'Python', 'age': 27}\nd2 = {'version': 3.6, 'platform': 'Mac'}\nd3 = {'size': '59MB'}\n\nd1.update(d2)\nd1.update(d3)\nprint(d1)\n#> {'name': 'Python', 'age': 27, 'version': 3.6, 'platform': 'Mac', 'size': '59MB'}d1 = {'name': 'Python', 'age': 27}\nd2 = {'version': 3.6, 'platform': 'Mac'}\nd3 = {'size': '59MB'}\n{**d1, **d2, **d3}\n#> {'name': 'Python', 'age': 27, 'version': 3.6, 'platform': 'Mac', 'size': '59MB'}"},{"path":"dictionary整理與實戰.html","id":"刪-刪除dict的item","chapter":"12 dictionary整理與實戰","heading":"12.7 [刪] 刪除dict的item","text":"","code":""},{"path":"dictionary整理與實戰.html","id":"popkey會把選定的key整個砍掉並把對應的value丟出來","chapter":"12 dictionary整理與實戰","heading":"12.7.1 .pop('key')會把選定的key整個砍掉，並把對應的value丟出來","text":"","code":"b = {\n        1: 1,\n        2: 2,\n        3: 3\n}\nc = b.pop(3)\nprint(c)\n#> 3\nprint(b)\n#> {1: 1, 2: 2}"},{"path":"dictionary整理與實戰.html","id":"del-dkey會刪到這組item","chapter":"12 dictionary整理與實戰","heading":"12.7.2 del d['key']會刪到這組item","text":"","code":"thisdict = {\n  \"brand\": \"Ford\",\n  \"model\": \"Mustang\",\n  \"year\": 1964\n}\n\ndel thisdict[\"model\"]\n\nprint(thisdict)\n#> {'brand': 'Ford', 'year': 1964}"},{"path":"dictionary整理與實戰.html","id":"mutable-copy","chapter":"12 dictionary整理與實戰","heading":"12.8 [mutable] copy","text":"字典也是mutable，所以不能用dict_copy = dict這種方式做複製，因為這樣又會出現改一邊，另一邊跟著改的窘境所以，作法一樣，用dict_copy = dict.copy()這種方法來做","code":"thisdict = {\n  \"brand\": \"Ford\",\n  \"model\": \"Mustang\",\n  \"year\": 1964\n}\nmydict = thisdict.copy()\nprint(mydict)\n#> {'brand': 'Ford', 'model': 'Mustang', 'year': 1964}"},{"path":"dictionary整理與實戰.html","id":"loop-for迴圈","chapter":"12 dictionary整理與實戰","heading":"12.9 [loop] for迴圈","text":"剛剛已經學過，如果一個字典的object叫d，那\nd.keys(): 可以得到所有的key\nd.values(): 可以得到所有的value\nd.items(): 可以得到所有的(key, value)所成的tuple\nd.keys(): 可以得到所有的keyd.values(): 可以得到所有的valued.items(): 可以得到所有的(key, value)所成的tuple那迴圈時，就可以善用這三招","code":"d = {\n        'key1': 'value1',\n        'key2': 'value2',\n        'key3': 'value3'\n}\nprint(d)\n#> {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}"},{"path":"dictionary整理與實戰.html","id":"loop-over-keys","chapter":"12 dictionary整理與實戰","heading":"12.9.1 loop over keys","text":"","code":"for key in d.keys():\n  print(key)\n#> key1\n#> key2\n#> key3"},{"path":"dictionary整理與實戰.html","id":"loop-over-values","chapter":"12 dictionary整理與實戰","heading":"12.9.2 loop over values","text":"","code":"for value in d.values():\n  print(value)\n#> value1\n#> value2\n#> value3"},{"path":"dictionary整理與實戰.html","id":"loop-over-key-value","chapter":"12 dictionary整理與實戰","heading":"12.9.3 loop over (key, value)","text":"","code":"for key, value in d.items():\n  print(key + \" -- \" + str(value))\n#> key1 -- value1\n#> key2 -- value2\n#> key3 -- value3"},{"path":"dictionary整理與實戰.html","id":"loop-dictionary-comprehension","chapter":"12 dictionary整理與實戰","heading":"12.10 [loop] dictionary comprehension","text":"假設，我今天想用for迴圈來做出一個字典，做法如下那dictionary comprehension，就是較簡潔的寫法：事實上，除了寫法簡潔，performance也快很多","code":"a = [1, 2, 3, 4, 5]\nb = {}\nfor item in a:\n        b[str(item)] = item\nprint(b)\n#> {'1': 1, '2': 2, '3': 3, '4': 4, '5': 5}c = {str(item): item for item in a}\nprint(c)\n#> {'1': 1, '2': 2, '3': 3, '4': 4, '5': 5}"},{"path":"dictionary整理與實戰.html","id":"如何安全的訪問字典","chapter":"12 dictionary整理與實戰","heading":"12.11 如何安全的訪問字典","text":"這邊文長，重點也不多(就是推廣用.get()而已)，所以要不要讀都沒差在python中，如果我們想獲取某個key的value，但key又不小心key錯，或此key不在這個dictionary裡面時，會報error:那處理這種問題的方法，有三種：","code":"d = {\n  'name': 'python',\n  'age': 27,\n  'version': 3.7\n}\nprint(d['name'])\n#> python\nprint(d['nam'])\n#> Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: 'nam'\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>"},{"path":"dictionary整理與實戰.html","id":"自己寫條件判斷","chapter":"12 dictionary整理與實戰","heading":"12.11.1 自己寫條件判斷","text":"這是最hardcore的寫法，很常出現在非python族群的人會寫的內容：","code":"def safe_get(my_key, my_dic):\n  if my_key in my_dic:\n    return(my_dic[my_key])\n  else:\n    return('error for key')\n\nprint(safe_get('name', d))\n#> python\nprint(safe_get('nam', d))\n#> error for key"},{"path":"dictionary整理與實戰.html","id":"愛用.get","chapter":"12 dictionary整理與實戰","heading":"12.11.2 愛用.get()","text":"其實你用.get()，就是幫你做到上面這件事當key值不在原本的dictionary裡面，預設是return None，那你也可以改","code":"res = d.get(\"nam\")\nprint(res is None)\n#> True\nres = d.get(\"nam\", \"error for key\")\nprint(res)\n#> error for key"},{"path":"dictionary整理與實戰.html","id":"改用defaultdict這種type","chapter":"12 dictionary整理與實戰","heading":"12.11.3 改用defaultdict這種type","text":"我們可以改用這種type並事先定義好，找不到key的處理方式:defaultdict的第一個argument，就是告訴他，key不在此dictionary時，要return什麼出來","code":"from collections import defaultdict  \nd_new = defaultdict(lambda: \"error for key\", d)\nd_new['nam']\n#> 'error for key'"},{"path":"dictionary整理與實戰.html","id":"how-to","chapter":"12 dictionary整理與實戰","heading":"12.12 How to…","text":"","code":""},{"path":"dictionary整理與實戰.html","id":"如何將字典按照keyvalue大小排序","chapter":"12 dictionary整理與實戰","heading":"12.12.1 如何將字典按照key/value大小排序","text":"假設現在有一個字典如下：可以把這個字典，想成人名和考試成績的對應然後，我想照value(考試成績)由高到低排序那做法上，會先用.items()來做出(key,value) pair，然後再做排序先看一下d.items()長怎樣：可以得知，這是一個iterable object，外觀看起來像list，裡面每個element是key-value pair tuple但他真實的type不是list，是dict_items我們可以選擇用sorted(iterable, key)這種方式做排序，或把它轉成list後，用.sort(key)來做排序","code":"d = {\n        'zhao': 68,\n        'qian': 80,\n        'sun': 72,\n        'li': 90,\n        'zhou': 83\n}print(d.items())\n#> dict_items([('zhao', 68), ('qian', 80), ('sun', 72), ('li', 90), ('zhou', 83)])\nprint(type(d.items()))\n#> <class 'dict_items'>"},{"path":"dictionary整理與實戰.html","id":"用通用版的function-sorted","chapter":"12 dictionary整理與實戰","heading":"12.12.1.1 用通用版的function: sorted()","text":"從結果來看，可知道已順利依照value由小排到大如果要由大到小，就加上reverse = True這個argument就好舉一反三，如果要對key的大小做排序(依姓氏排序)，那就是：ok，那回到原來的目的，依照value由大到小排序，且轉回dictionary","code":"sorted(\n        d.items(), # 我要將此iterable做排序\n        key = lambda x: x[1] # 怎麼排？令這個iterable的一個element叫x，\n                             # 我要對他的第二個元素: x[1]做排序\n)\n#> [('zhao', 68), ('sun', 72), ('qian', 80), ('zhou', 83), ('li', 90)]sorted(d.items(), key = lambda x: x[1], reverse = True)\n#> [('li', 90), ('zhou', 83), ('qian', 80), ('sun', 72), ('zhao', 68)]sorted(d.items(), key = lambda x: x[0])\n#> [('li', 90), ('qian', 80), ('sun', 72), ('zhao', 68), ('zhou', 83)]dict(sorted(d.items(), key = lambda x: x[1], reverse = True))\n#> {'li': 90, 'zhou': 83, 'qian': 80, 'sun': 72, 'zhao': 68}"},{"path":"dictionary整理與實戰.html","id":"用list專用的method-.sortkey","chapter":"12 dictionary整理與實戰","heading":"12.12.1.2 用list專用的method: .sort(key)","text":"剛剛知道，d.items()的結果很像list，但不是list，所以我先轉成list後，再排序接著就很簡單了，用學過的.sort(key = ..., reverse = True)來處理","code":"item_list = list(d.items())\nprint(item_list)\n#> [('zhao', 68), ('qian', 80), ('sun', 72), ('li', 90), ('zhou', 83)]\nprint(type(item_list))\n#> <class 'list'>item_list.sort(\n  key = lambda x: x[1], #key就是function的意思，我先用這function算出結果，才用結果做排序\n  reverse = True\n)\n\nprint(item_list)\n#> [('li', 90), ('zhou', 83), ('qian', 80), ('sun', 72), ('zhao', 68)]"},{"path":"set應用實戰.html","id":"set應用實戰","chapter":"13 set應用實戰","heading":"13 set應用實戰","text":"set是python內建的一種collection既然是collection，我們就可以把它當資料庫看，所以會依序介紹作為資料庫最基礎的幾個part：\n如何建立？\n如何增、刪、查、改？\n如何建立？如何增、刪、查、改？這些基礎會了後，就確認一下是否為mutable物件，來決定如何做copy接著就開始介紹如何loop他(用for, comprehension)最後就是補齊這個object還沒介紹到的methods實戰的部分，就會以”…“的方式整理常見的需求","code":""},{"path":"set應用實戰.html","id":"定義set","chapter":"13 set應用實戰","heading":"13.1 定義set","text":"集合就是只有key，沒有value的dictionary例如，以下是dictionary而，以下就是setset的特點，其實和dictionary的key的特點一樣(也和數學上的集合的特點一樣)，就是’唯一’和’無序’。唯一就是key值唯一，你多給他重複的key，他也幫你刪掉。無序就是你每次print的時候，他順序都會亂跳，所以你有不能用index的方法來獲取set裡面的element","code":"my_dict = {\n  'a': 1,\n  'b': 5\n}\nprint(my_dict)\n#> {'a': 1, 'b': 5}my_set = {'a', 'b'}\nprint(my_set)\n#> {'a', 'b'}"},{"path":"set應用實戰.html","id":"查-只能用for-loop與in","chapter":"13 set應用實戰","heading":"13.2 [查] 只能用for loop與in","text":"因為set又沒有list/tuple的index，也沒有dictionary的key，所以你既不能用set1[index]來取資料，也不能用set1['key']來取資料所以，只能做兩件事：\n用for迴圈來loop看看總共有哪些item\n用in來確認，你指定的item有沒有在這個set裡面\n用for迴圈來loop看看總共有哪些item用in來確認，你指定的item有沒有在這個set裡面check “banana”是否在這個set中","code":"thisset = {\"apple\", \"banana\", \"cherry\"}\n\nfor x in thisset:\n  print(x)\n#> cherry\n#> banana\n#> applethisset = {\"apple\", \"banana\", \"cherry\"}\n\nprint(\"banana\" in thisset)\n#> True"},{"path":"set應用實戰.html","id":"改-set無法做修改","chapter":"13 set應用實戰","heading":"13.3 [改] set無法做修改","text":"set無法做修改的原因，是因為他無法取出你指定的那個item，所以他無法像list那樣，用list1[index] = new_value，也無法像dictionary那樣，用dic1['key'] = new_value來做修改但set可以做刪除和新增。所以如果一個set是{\"apple\", \"banana\", \"orange\"}，那我想把”banana”改成”kiwi”，那就是刪除”banana”，再新增”kiwi”就好","code":""},{"path":"set應用實戰.html","id":"刪-.remove與.discard","chapter":"13 set應用實戰","heading":"13.4 [刪] .remove()與.discard()","text":".remove()和.discard()的差別，是在remove一個不存在的值時，他會跳error，但discard一個不存在的值時，他就裝沒事而已","code":"thisset = {\"apple\", \"banana\", \"cherry\"}\n\nthisset.remove(\"banana\")\n\nprint(thisset)\n#> {'cherry', 'apple'}thisset = {\"apple\", \"banana\", \"cherry\"}\n\nthisset.remove(\"kiwi\")\n#> Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: 'kiwi'\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>thisset = {\"apple\", \"banana\", \"cherry\"}\n\nthisset.discard(\"banana\")\n\nprint(thisset)\n#> {'cherry', 'apple'}thisset = {\"apple\", \"banana\", \"cherry\"}\n\nthisset.discard(\"kiwi\")\n\nprint(thisset)\n#> {'cherry', 'banana', 'apple'}"},{"path":"set應用實戰.html","id":"增-.add與.update","chapter":"13 set應用實戰","heading":"13.5 [增] .add()與.update()","text":"","code":""},{"path":"set應用實戰.html","id":"增加一個item用.add","chapter":"13 set應用實戰","heading":"13.5.1 增加一個item用.add()","text":"","code":"thisset = {\"apple\", \"banana\", \"cherry\"}\n\nthisset.add(\"orange\")\n\nprint(thisset)\n#> {'cherry', 'banana', 'orange', 'apple'}"},{"path":"set應用實戰.html","id":"增加多個item用.update","chapter":"13 set應用實戰","heading":"13.5.2 增加多個item用.update()","text":"如果update的東西，裡面有和原本重複的值，那就只會留一個，因為set就是unique","code":"thisset = {\"apple\", \"banana\", \"cherry\"}\ntropical = {\"pineapple\", \"mango\", \"papaya\"}\n\nthisset.update(tropical)\n\nprint(thisset)\n#> {'banana', 'pineapple', 'mango', 'apple', 'cherry', 'papaya'}thisset = {\"apple\", \"banana\", \"cherry\"}\ntropical = {\"apple\", \"banana\", \"papaya\"}\n\nthisset.update(tropical)\n\nprint(thisset)\n#> {'banana', 'apple', 'cherry', 'papaya'}"},{"path":"set應用實戰.html","id":"mutable-請愛用.copy","chapter":"13 set應用實戰","heading":"13.6 [mutable] 請愛用.copy()","text":"set也是mutable，所以以下慘劇會重現：記得用.copy()來解決問題","code":"set1 = {\"apple\", \"banana\", \"orange\"}\nset1_copy = set1  \n\nset1_copy.remove(\"apple\")\n\nprint(set1_copy)\n#> {'orange', 'banana'}\nprint(set1)\n#> {'orange', 'banana'}set1 = {\"apple\", \"banana\", \"orange\"}\nset1_copy = set1.copy()  \n\nset1_copy.remove(\"apple\")\n\nprint(set1_copy)\n#> {'orange', 'banana'}\nprint(set1)\n#> {'orange', 'banana', 'apple'}"},{"path":"set應用實戰.html","id":"loop-for-1","chapter":"13 set應用實戰","heading":"13.7 [loop] for","text":"這邊就沒什麼，你只能loop他的item:","code":"set1 = {\"apple\", \"banana\", \"orange\"}\nfor item in set1:\n  print(item)\n#> orange\n#> banana\n#> apple"},{"path":"set應用實戰.html","id":"loop-comprehension-1","chapter":"13 set應用實戰","heading":"13.8 [loop] comprehension","text":"set可以看成簡化版的dictionary，那既然可以做dictionary comprehension，就應該可以做set comprehension","code":"set1 = {\"apple\", \"banana\", \"orange\"}\nset2 = {item for item in set1}\n\nprint(set2)\n#> {'orange', 'apple', 'banana'}"},{"path":"set應用實戰.html","id":"特殊技-集合運算","chapter":"13 set應用實戰","heading":"13.9 [特殊技] 集合運算","text":"set可以做數學上的交集(&)、聯集(|)、差集(-)、補集(^)","code":"s1 = {1,2,3,4}\ns2 = {3,4,5,6}\n\nprint(s1 & s2)\n#> {3, 4}\nprint(s1 | s2)\n#> {1, 2, 3, 4, 5, 6}\nprint(s1 - s2) #是s1，但不是s2\n#> {1, 2}\nprint(s1 ^ s2)\n#> {1, 2, 5, 6}"},{"path":"set應用實戰.html","id":"特殊技-對list取unique","chapter":"13 set應用實戰","heading":"13.10 [特殊技] 對list取unique","text":"例如我有一個list，我想取出unique的值：","code":"l = [1,2,3,2,4,5,2]\nl_unique = list(set(l))\nprint(l_unique)\n#> [1, 2, 3, 4, 5]"},{"path":"set應用實戰.html","id":"特殊技-將字串中unique-character轉成list","chapter":"13 set應用實戰","heading":"13.11 [特殊技] 將字串中unique character轉成list","text":"這招蠻牛的，看一下例子就會了","code":"my_string = \"aabbcdefg\"\nstring_to_set = set(my_string)\nprint(string_to_set)\n#> {'c', 'a', 'd', 'e', 'g', 'b', 'f'}"},{"path":"none.html","id":"none","chapter":"14 None","heading":"14 None","text":"","code":""},{"path":"none.html","id":"定義","chapter":"14 None","heading":"14.1 定義","text":"沒有value的變數，我們叫他沒有值(None)，我們可以把它想成excel中的空白，或是R中的NULL與他對比的叫空值，空值還是有值，只是他的值是空白\n= None，這個a是沒有值，因為他沒有value\n= ''，這個a是空值，因為他還是有value，他的value是空的string\n= []，這個a也是空值，他的值是空的list\n= 0，這個a就不是空值了，因為他的值是0\n= None，這個a是沒有值，因為他沒有valuea = ''，這個a是空值，因為他還是有value，他的value是空的stringa = []，這個a也是空值，他的值是空的lista = 0，這個a就不是空值了，因為他的值是0","code":""},{"path":"none.html","id":"is-none","chapter":"14 None","heading":"14.2 is None","text":"要確認一個變數，是None還是空值，就用is None做確認(就像R得is.null()一樣)或是，你用print()也可以發現差別：","code":"a = None  \nprint(a is None)  \n#> True\nb = ''\nprint(b is None)\n#> Falsea = None\na # 他啥都不會顯示  \n\nb = ''  \nb # 會顯示 ''\n#> ''"},{"path":"none.html","id":"使用時機","chapter":"14 None","heading":"14.3 使用時機","text":"這邊我覺得還要再補充，目前先寫下udemy舉到的應用(但我覺得不是很滿意)","code":""},{"path":"none.html","id":"與資料庫互動","chapter":"14 None","heading":"14.3.1 與資料庫互動","text":"假設我們今天在和資料庫互動時，想把query後的結果存在result這個變數，那有可能我query後的結果，是個空值(e.g. 我查過年期間，工廠有在生產的model名稱，可能查出空集合，所以回傳給我一個空值)，也有可能我query的時候，資料庫根本沒連線成功，所以回我error那為了讓程式繼續跑下去，不要因為error而停下，那我們就會在error的時候，把query的結果定為None，那我就知道： “result = 空值”表示沒資料，“result = None”表示連線失敗見以下的程式範例：接下來，開始使用這個function了，我們想回傳給user訊息：\n如果連線成功，回傳query到的結果\n如果連線失敗，回傳”connection error”\n如果連線成功，回傳query到的結果如果連線失敗，回傳”connection error”","code":"def test_connection():\n  # 寫些條件判斷，來確認有沒有順利和DB連接上\n  # 有的話，回傳True\n  # 現在先假設判斷完的結果是True\n  return True\n\ndef get():\n  # 寫個statement，去DB中抓取我要的user名單\n  # 例如這兩天有登入我們網站的人員名單\n  # 那假設抓完的結果，就很不巧，沒有條件符合，所以是： []  \n  return []\n\ndef get_user_list():\n  # 完整的抓user名單的function\n  # 會先判斷DB有沒有連線成功，有的話，才抓\n  if not test_connection():\n    return None\n  else:\n    return get()query_result = get_user_list()\nif query_result is None:\n  print(\"connection error\")\nelse:\n  print(\"user list: \", query_result)\n#> user list:  []"},{"path":"boolean整理與實戰.html","id":"boolean整理與實戰","chapter":"15 boolean整理與實戰","heading":"15 boolean整理與實戰","text":"boolean就True/False兩種，主要用在條件判斷時使用雖然只有True/False兩種，聽起來很簡單，但還是蠻多細節可以講的","code":""},{"path":"boolean整理與實戰.html","id":"大部分的value轉成boolean都是true","chapter":"15 boolean整理與實戰","heading":"15.1 大部分的value，轉成boolean都是True","text":"str轉成boolean會是True，除非是空的stringint, float轉成boolean會是True，除非是0list, tuple, set, dic轉成boolean都是True，除非是空值","code":"bool(\"abc\")\n#> True\nbool(123)\n#> True\nbool(123.123)\n#> True\nbool([\"apple\", \"cherry\", \"banana\"])\n#> True"},{"path":"boolean整理與實戰.html","id":"少部分value轉成boolean會是false","chapter":"15 boolean整理與實戰","heading":"15.2 少部分value，轉成boolean會是False","text":"就如同上面的舉例，你是以下三種狀況，那轉成boolean，會是False\n沒有值(None)\n空值(e.g. ““, [], {},…)\n0\n沒有值(None)空值(e.g. ““, [], {},…)0","code":"example = [\n  None, \"\", [], (), {}, 0\n]\n\nfor i in example:\n  res = bool(i)\n  print(f\"{i} transform to boolean will be {res}\")\n#> None transform to boolean will be False\n#>  transform to boolean will be False\n#> [] transform to boolean will be False\n#> () transform to boolean will be False\n#> {} transform to boolean will be False\n#> 0 transform to boolean will be False"},{"path":"boolean整理與實戰.html","id":"搭配if-statement","chapter":"15 boolean整理與實戰","heading":"15.3 搭配if statement","text":"如果要做： “一個list是空值，我就…”，那可以這樣寫：當然，你還是可以用土法煉鋼的寫法，但在Python社群就很少人這樣寫了：","code":"a = []\nif not a: # a 是[]時，轉成 boolean 會是False，所以加個not就變True了  \n  print(\"a is empty\")  \n#> a is emptya = []\nif a == []:\n  print(\"a is empty\")  \n#> a is empty"},{"path":"conditional-operators.html","id":"conditional-operators","chapter":"16 Conditional Operators","heading":"16 Conditional Operators","text":"可以製作出True/False結果的operations有很多，這邊整理一下：","code":""},{"path":"conditional-operators.html","id":"section","chapter":"16 Conditional Operators","heading":"16.0.1 ==, !=, >=, <=","text":"這些operator，我們稱為comparison operators，適用於數值型資料：這些operator，我們稱為comparison operators，適用於數值型資料：比大小： == b, != b, < b, <= b, > b, >=b比大小： == b, != b, < b, <= b, > b, >=b餘數類： % 3 == 0餘數類： % 3 == 0只想看商： // 3 == 1只想看商： // 3 == 1","code":"a = 33\nb = 200\nif b > a:\n  print(\"b is greater than a\")\n#> b is greater than a"},{"path":"conditional-operators.html","id":"and-or-not","chapter":"16 Conditional Operators","heading":"16.0.2 and, or, not","text":"這種operator，我們稱為logical operators，適用於連接多個conditionlogical operators就是 , , ，對應到R的&, |, !","code":"a = 200\nb = 33\nc = 500\nif a > b and c > a:\n  print(\"Both conditions are True\")\n#> Both conditions are True\nif a > b or a > c:\n  print(\"At least one of the conditions is True\")\n#> At least one of the conditions is True\nif not(b > a):\n  print(\"a is greater or equal to b\")\n#> a is greater or equal to b"},{"path":"conditional-operators.html","id":"in-not-in","chapter":"16 Conditional Operators","heading":"16.0.3 in, not in","text":"這種operator稱為membership operator，適用於判斷某個item是否是別人的子集x y, x y","code":""},{"path":"conditional-operators.html","id":"is-is-not","chapter":"16 Conditional Operators","heading":"16.0.4 is, is not","text":"這種operator，我們稱為identity operator，適用於判斷資料是不是某種資料類型，或是兩個object是否相同看x和y是否為相同的object，可以用 x y","code":""},{"path":"if-statement.html","id":"if-statement","chapter":"17 If statement","heading":"17 If statement","text":"if在python中有三種寫法\n…\n…else…\n…elif…else…\n一行的if\n一行的if…else…\n……else……elif…else…一行的if一行的if…else…","code":""},{"path":"if-statement.html","id":"if-1","chapter":"17 If statement","heading":"17.1 if…","text":"","code":"a = 88\nif a > 8:\n  print('yeah')\n#> yeah"},{"path":"if-statement.html","id":"ifelse","chapter":"17 If statement","heading":"17.2 if…else…","text":"","code":"a = 7\nif a > 8:\n  print('yeah')\nelse:\n  print('no')\n#> no"},{"path":"if-statement.html","id":"ifelifelse","chapter":"17 If statement","heading":"17.3 if…elif…else…","text":"","code":"a = 200\nb = 33\nif b > a:\n  print(\"b is greater than a\")\nelif a == b:\n  print(\"a and b are equal\")\nelse:\n  print(\"a is greater than b\")\n#> a is greater than b"},{"path":"if-statement.html","id":"一行的if","chapter":"17 If statement","heading":"17.4 一行的if","text":"","code":"a = 200\nb = 33\nif a > b: print(\"a is greater than b\") # 就是不要換行就好，其他不變\n#> a is greater than b"},{"path":"if-statement.html","id":"一行的ifelse","chapter":"17 If statement","heading":"17.5 一行的if…else…","text":"這招在list comprehension時又會用到，訣竅就是要倒裝： 做這個 if這樣，不然(else)就做那個…","code":"a = 2\nb = 330\nprint(\"A\") if a > b else print(\"B\")\n#> B"},{"path":"if-statement.html","id":"善用pass","chapter":"17 If statement","heading":"17.6 善用pass","text":"這個技巧也可以學一下，if裡面不可以是空的，但如果因為some reason，你就是需要寫if，那你就塞一個pass在裡面，就不會報error了","code":"a = 33\nb = 200\n\nif b > a:\n  pass"},{"path":"if-statement.html","id":"if-條件太多時怎麼優化","chapter":"17 If statement","heading":"17.7 if 條件太多時，怎麼優化","text":"我覺得這邊可以補充”地表最簡單Python”那門課的練習，有講到寫多個if時比較好的做法","code":""},{"path":"for-loop.html","id":"for-loop","chapter":"18 for loop","heading":"18 for loop","text":"","code":""},{"path":"for-loop.html","id":"寫法","chapter":"18 for loop","heading":"18.1 寫法","text":"","code":"for i in range(10):\n  print(i)\n#> 0\n#> 1\n#> 2\n#> 3\n#> 4\n#> 5\n#> 6\n#> 7\n#> 8\n#> 9"},{"path":"for-loop.html","id":"善用break終止迴圈","chapter":"18 for loop","heading":"18.2 善用break終止迴圈","text":"直接看例子：","code":"for i in range(10):\n  if i < 5:\n    print(i)\n  else:\n    print(f\"i = {i}, value >=5, stop!!\")\n    break\n#> 0\n#> 1\n#> 2\n#> 3\n#> 4\n#> i = 5, value >=5, stop!!"},{"path":"for-loop.html","id":"善用continue跳入下一個迴圈","chapter":"18 for loop","heading":"18.3 善用continue跳入下一個迴圈","text":"有時候我們不希望直接跳出迴圈，而是ignore這一圈，直接進入下一圈，例如下例：","code":"for i in range(10):\n  if i % 2 == 0: # 除以2的餘數==0\n    continue\n  print(i)\n#> 1\n#> 3\n#> 5\n#> 7\n#> 9"},{"path":"while-loop.html","id":"while-loop","chapter":"19 while loop","heading":"19 while loop","text":"","code":""},{"path":"while-loop.html","id":"while-寫法","chapter":"19 while loop","heading":"19.1 while 寫法","text":"","code":"a = 10\nwhile a > 5:\n  print(f\"'a' is {a} currently\")\n  a -= 1\n#> 'a' is 10 currently\n#> 'a' is 9 currently\n#> 'a' is 8 currently\n#> 'a' is 7 currently\n#> 'a' is 6 currently\nprint('end')\n#> end"},{"path":"while-loop.html","id":"確認每次都有更新內容","chapter":"19 while loop","heading":"19.2 確認每次都有更新內容","text":"while最怕的就是無限迴圈，所以寫while時，條件中的內容，在每次的循環中，通常都會更新，例如以下：","code":"a = 10\nwhile a > 5:\n  print(a)\n  a = a - 1 # 若沒做這個更新，那就會陷入無限迴圈  \n#> 10\n#> 9\n#> 8\n#> 7\n#> 6\nprint('end')\n#> end"},{"path":"while-loop.html","id":"善用break","chapter":"19 while loop","heading":"19.3 善用break","text":"為了避免進入無限迴圈，while裡面也常常加入break，來強制停止它例如做參數更新時，可能可以寫成以下這樣：","code":"i = 0\nest_value = 10\ntrue_value = 10000\nwhile true_value - est_value > 0.01:\n  est_value +=1\n  i +=1\n  if i == 100:\n    break\n\nprint(est_value)\n#> 110\nprint(i)\n#> 100"},{"path":"function101.html","id":"function101","chapter":"20 function101","heading":"20 function101","text":"","code":""},{"path":"function101.html","id":"function的結構","chapter":"20 function101","heading":"20.1 function的結構","text":"function的 3+1 個part\nfunction header: 這個function的名稱\nDocstrings: 開頭註解，用三引號夾起來，並照PEP8格式，寫下Purpose, Args, Returns, Raises這四個component (其中的Raises是指，什麼狀況下要給error)\nfunction body: 這個function的內容\noutput出什麼: 這是optional，你可以只做side-effect(e.g. 寫入資料庫)，但不output出東西。若要output出東西，可以output一個int, float, string, 或一個collection(e.g. list, tuple, dictionary, set), 或一個新的function(.e. clousure，見nested function那章)\nfunction header: 這個function的名稱Docstrings: 開頭註解，用三引號夾起來，並照PEP8格式，寫下Purpose, Args, Returns, Raises這四個component (其中的Raises是指，什麼狀況下要給error)function body: 這個function的內容output出什麼: 這是optional，你可以只做side-effect(e.g. 寫入資料庫)，但不output出東西。若要output出東西，可以output一個int, float, string, 或一個collection(e.g. list, tuple, dictionary, set), 或一個新的function(.e. clousure，見nested function那章)以下是一個簡單但完整的function","code":"def square(value): # <- Function header\n  # <- Docstrings are below\n  \"\"\"\n  Purpose: \n    Return the square of a value\n  Args:\n    value (int/float): the number to be squared\n  Returns:\n    int/float\n  Raises:\n    ValueError: If `value` is not int/float\n  \"\"\"\n  \n  # Function body\n  if (not type(value) is int) and (not type(value) is float):\n    raise TypeError(\"`value` must be the type of int/float\")\n  \n  new_value = value**2 \n  \n  # output\n  return new_value"},{"path":"function101.html","id":"function的內容","chapter":"20 function101","heading":"20.2 function的內容","text":"","code":""},{"path":"function101.html","id":"docstring的標準格式","chapter":"20 function101","heading":"20.2.1 Docstring的標準格式","text":"從上例可以看到docstring的標準格式對開發者來說，他看到你的source code，就可以很清楚的知道function的目的, 參數, output, 以及什麼時候會給error對user來說，他雖然看不到你寫的註解，但他只要下help，就可以輕易看到這些內容：或是，用這個function的.__doc__屬性，也可以看到：","code":"help(square)\n#> Help on function square in module __main__:\n#> \n#> square(value)\n#>     Purpose: \n#>       Return the square of a value\n#>     Args:\n#>       value (int/float): the number to be squared\n#>     Returns:\n#>       int/float\n#>     Raises:\n#>       ValueError: If `value` is not int/floatprint(square.__doc__)\n#> \n#>   Purpose: \n#>     Return the square of a value\n#>   Args:\n#>     value (int/float): the number to be squared\n#>   Returns:\n#>     int/float\n#>   Raises:\n#>     ValueError: If `value` is not int/float\n#> "},{"path":"function101.html","id":"先檢驗argument的合法性","chapter":"20 function101","heading":"20.2.2 先檢驗argument的合法性","text":"此外，也可以看到比較professional的function寫法，會在一開始就檢驗你丟進來的arguments是否符合要求，不符合就報錯，來避免不必要的bug所以，我們測試一下就知道了：詳細的error handling寫法，會在下一個章節介紹","code":"print(square(3))\n#> 9\nprint(square(1.4))\n#> 1.9599999999999997\nprint(square('haha'))\n#> Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: `value` must be the type of int/float\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>\n#>   File \"<string>\", line 16, in square"},{"path":"function101.html","id":"記得寫return","chapter":"20 function101","heading":"20.2.3 記得寫return","text":"特別注意，如果要return value出來，最後一定要加return，不能像R偷懶，以為最後一行就會自己return出來","code":""},{"path":"function101.html","id":"default-argument","chapter":"20 function101","heading":"20.2.4 default argument","text":"這很easy拉，就簡單給個例子就好要特別注意的是，default argument一定要放到最後面，不可以放到前面","code":"def power(number, pow = 1):\n  \"\"\"Raise number to the power of pow.\"\"\"\n  new_value = number ** pow\n  return new_value\n\nprint(power(9, 2))\n#> 81\nprint(power(9))\n#> 9"},{"path":"function101.html","id":"function就是一個object","chapter":"20 function101","heading":"20.3 function就是一個object","text":"剛剛定義好square這個function，他其實就是個object，直接key函數名稱，可以看到他的記憶體位置：但如果你打square(3)，那他會call這個函數：所以，記得這兩個重點：\nsquare是一個函數物件\nsquare()是call這個函數後的運算結果\nsquare是一個函數物件square()是call這個函數後的運算結果也因為square他現在就是個function物件，所以你要把他assign到別的variable也沒問題：有關把function當一個物件來使用的詳細介紹，請見Function就是另一種type的object的章節。","code":"square\n#> <function square at 0x139a72ee0>square(3)\n#> 9new = square\nnew(3)\n#> 9"},{"path":"function101.html","id":"高階函數","chapter":"20 function101","heading":"20.4 高階函數","text":"定義： 如果一個函數，他滿足以下其中一個條件，我們就稱此函數為高階函數\ninput argument也是函數\noutput的東西是一個函數\ninput argument也是函數output的東西是一個函數例如以下的函數high_level_hello，他的input argument也是一個函數(hello)：或是以下的函數high_level_goodbye，他的output會是一個函數(goodbye):有關高階函數中，把input argument也放function的部分，請看Function就是另一種type的object章節有關高階函數中，把output放function的部分，請看closure章節","code":"def hello():\n  print(\"hello!!\")\n\ndef high_level_hello(func):\n  func()\n\nhigh_level_hello(hello)\n#> hello!!def high_level_goodbye(msg):\n  def goodbye():\n    print(f\"goodbye!! {msg}\")\n  return goodbye\n    \nf = high_level_goodbye(\"hank!!\")\nf()\n#> goodbye!! hank!!\ng = high_level_goodbye(\"sunny!!\")\ng()\n#> goodbye!! sunny!!"},{"path":"exception-handling.html","id":"exception-handling","chapter":"21 Exception Handling","heading":"21 Exception Handling","text":"在python中，我們看到的Error，就叫異常(exception)異常分兩種：\n系統內建的異常： 例如ValueError(), TypeError(),…\n自己定義的異常\n系統內建的異常： 例如ValueError(), TypeError(),…自己定義的異常那總結一下這章要講的重點：\n[異常] 先介紹各種異常\n[處理] function在運行時，我想主動卡控東西，若違反我的規則，我要主動丟error出去 -> raise XXXError(\"error message \")\n[處理] function在運行時，若出現不可預知的error，我們該怎麼處理？ -> try: ..., except: ...\n[異常] 先介紹各種異常[處理] function在運行時，我想主動卡控東西，若違反我的規則，我要主動丟error出去 -> raise XXXError(\"error message \")[處理] function在運行時，若出現不可預知的error，我們該怎麼處理？ -> try: ..., except: ...","code":""},{"path":"exception-handling.html","id":"各種異常介紹","chapter":"21 Exception Handling","heading":"21.1 各種異常介紹","text":"","code":""},{"path":"exception-handling.html","id":"attributeerror","chapter":"21 Exception Handling","heading":"21.1.1 AttributeError","text":"在python中，所有東西都是object，都有自己的屬性(attribute)。那如果你今天call某個object一個不屬於他的屬性，那就會丟AttributeError例如下例，os裡面沒有.test這個屬性，所以你call他就會報錯：","code":"import os\nos.test\n#> Error in py_call_impl(callable, dots$args, dots$keywords): AttributeError: module 'os' has no attribute 'test'\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>"},{"path":"exception-handling.html","id":"modulenotfounderror","chapter":"21 Exception Handling","heading":"21.1.2 ModuleNotFoundError","text":"如果我們在import一個module時，沒有這個module，那就會報ModuleNotFoundError","code":"import hank_module\n#> Error in py_call_impl(callable, dots$args, dots$keywords): ModuleNotFoundError: No module named 'hank_module'\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>\n#>   File \"/Users/hanklee/Library/Application Support/renv/cache/v5/R-4.1/x86_64-apple-darwin17.0/reticulate/1.22/b34a8bb69005168078d1d546a53912b2/reticulate/python/rpytools/loader.py\", line 39, in _import_hook\n#>     module = _import("},{"path":"exception-handling.html","id":"indexerror","chapter":"21 Exception Handling","heading":"21.1.3 IndexError","text":"如果某個list的長度只有1，你卻要取用他index=2，那就會報IndexError","code":"a = [\"hank\"]\na[2]\n#> Error in py_call_impl(callable, dots$args, dots$keywords): IndexError: list index out of range\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>"},{"path":"exception-handling.html","id":"keyerror","chapter":"21 Exception Handling","heading":"21.1.4 KeyError","text":"訪問字典時，key寫錯了，沒有這個key","code":"a = {\"name\": \"hank\"}\na['salary']\n#> Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: 'salary'\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>"},{"path":"exception-handling.html","id":"nameerror","chapter":"21 Exception Handling","heading":"21.1.5 NameError","text":"call一個沒有被定義過的變數","code":"a = hank * 2\n#> Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'hank' is not defined\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>"},{"path":"exception-handling.html","id":"zerodivisionerror","chapter":"21 Exception Handling","heading":"21.1.6 ZeroDivisionError","text":"把0當除數時，會報的error","code":"3/0\n#> Error in py_call_impl(callable, dots$args, dots$keywords): ZeroDivisionError: division by zero\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>"},{"path":"exception-handling.html","id":"自定義的error","chapter":"21 Exception Handling","heading":"21.1.7 自定義的error","text":"其實剛剛介紹的各種Error，都是繼承自Exception這個class，簡單驗證一下：如果我們在pycharm裡，按ctrl/command，再把滑鼠點到程式碼中的TypeError，他會開啟TypeError的source code，就可以看到第一行他就在做繼承所以，要寫我自己定義的error，就依樣畫葫蘆就好：","code":"a = TypeError(\"type is wrong\")\nprint(isinstance(a, TypeError))\n#> True\nprint(isinstance(a, Exception))\n#> Trueclass TypeError(Exception):\n  # ...class MyException(Exception):\n  pass\n\nraise MyException(\"這是我定義的異常\")\n#> Error in py_call_impl(callable, dots$args, dots$keywords): MyException: 這是我定義的異常\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>"},{"path":"exception-handling.html","id":"raise-xxxerrorerror-message-herer","chapter":"21 Exception Handling","heading":"21.2 raise XXXError(\"error message herer\")","text":"上一章講function時，有建議養成習慣，在function的一開始，都先確認input argument是否合法，若不合法，直接報error，不用再繼續做下去那這在R裡面，就是寫個條件判斷，若不合法，就做stop(\"error message\")而在Python裡面，我們已經知道Error都要加上error type才完整，所以大概會寫成這樣： raise XXXError(\"error message\")可以看到，和R的差別，就是多個raise，以及XXX來看例子：可以看到上例，如果輸入的value，不是數值型資料(.e. int/float)，那就報錯這邊可以注意，你要報什麼類型的錯，其實隨你高興，你要寫raise ValueError(\"error message\")，python也不會管你，這只是你要寫給user看得東西而已。來試試看管不管用：","code":"def square(value): \n  \n  if (not type(value) is int) and (not type(value) is float):\n    raise TypeError(\"`value` must be the type of int/float\")\n  \n  new_value = value**2 \n  \n  # output\n  return new_valueprint(square(3))\n#> 9\nprint(square(1.4))\n#> 1.9599999999999997\nprint(square('haha'))\n#> Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: `value` must be the type of int/float\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>\n#>   File \"<string>\", line 4, in square"},{"path":"exception-handling.html","id":"try...except...","chapter":"21 Exception Handling","heading":"21.3 try...except...","text":"就像if…else…有多種寫法一樣，try…except也是，以下寫出最複雜的例子，記得除了try和except一定要以外，其他都是可有可無","code":"try:\n  # 執行一段可能報error的code\nexcept:\n  # 如果發生error，執行此處的code\nelse:\n  # 如果沒發生error，執行此處的code\nfinally:\n  # 不管有沒有發生error，最後都得執行此處的code"},{"path":"exception-handling.html","id":"基本款只寫except","chapter":"21 Exception Handling","heading":"21.3.1 基本款：只寫except","text":"try...except...其實就是R裡面的tryCatch，通常是碰到我們不想停下來的錯誤時，而做的處理(如果是嚴重錯誤，必須直接跳出的話，就會用raise XXError(\"error message\"))舉個例子，我如果沿用剛剛square function，去算大量的數據時：會發現報了error之後，後面的東西全都停掉了但我更傾向，不要報error，而是隨便塞個東西進去，然後print個message讓我知道哪裡出錯就好，那我就可以改成這樣寫：那我的程序就可以順利跑完，得到result，並把發生錯誤的項目print在log裡讓我們知道。那我的程序就可以順利跑完，得到result，並把發生錯誤的項目print在log裡讓我們知道。再舉個例子，我有個function，想要input一串數字，然後output出哪些數是100的因數：再舉個例子，我有個function，想要input一串數字，然後output出哪些數是100的因數：從上面的例子可以看到，第二次嘗試時，因為丟了0進去，所以誘發了ZeroDivisionError，表示0不可以放分母。但…，我們其實不希望丟這個error出來，因為對於0這種數，他就不會是因數，所以我希望碰到error就跳過","code":"input_list = [2, 3.5, 7, '4', 8, 10]\nres = []\nfor item in input_list:\n  temp_res = square(item)\n  res.append(temp_res)\n#> Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: `value` must be the type of int/float\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 2, in <module>\n#>   File \"<string>\", line 4, in squareinput_list = [2, 3.5, 7, '4', 8, 10]\nres = []\nfor item in input_list:\n  try:\n    temp_res = square(item)\n    res.append(temp_res)\n  except:\n    res.append(None)\n    print(f\"input = {item} occurs error!!\")\n#> input = 4 occurs error!!\nprint(\"The result is: \", res)\n#> The result is:  [4, 12.25, 49, None, 64, 100]def factor_100(my_list):\n  res = []\n  for item in my_list:\n    if 100 % item == 0:\n      res.append(item)\n  return(res)\n\n\nprint(factor_100([2, 5, 7]))\n#> [2, 5]\nprint(factor_100([2, 5, 7, 0]))\n#> Error in py_call_impl(callable, dots$args, dots$keywords): ZeroDivisionError: integer division or modulo by zero\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>\n#>   File \"<string>\", line 4, in factor_100def factor_100(my_list):\n  res = []\n  for item in my_list:\n    try:\n      # 可能發生error的那句statement放這\n      if 100 % item == 0:\n        res.append(item)\n    except:\n      # 碰到error時，run這裡\n      print(\"0不能當除數拉！！\")\n  return(res)\n\n\nprint(factor_100([2, 5, 7]))\n#> [2, 5]\nprint(factor_100([2, 5, 7, 0]))\n#> 0不能當除數拉！！\n#> [2, 5]"},{"path":"exception-handling.html","id":"進階款-except-xxerror","chapter":"21 Exception Handling","heading":"21.3.2 進階款： except XXerror","text":"剛剛這樣寫好像很棒了，但如果你試試run以下的code:會發現…wtf，我input的東西哪裡有0？問題是出在我丟一個字串(“hank”)進去了所以，except後面其實還可以接：碰到哪種error時，執行我。那我就可以寫”碰到ZeroDivisionError時，怎樣怎樣”; “碰到TypeError時，怎樣怎樣”","code":"print(factor_100([2, 5, 7, 'hank']))\n#> 0不能當除數拉！！\n#> [2, 5]def factor_100(my_list):\n  res = []\n  for item in my_list:\n    try:\n      # 可能發生error的那句statement放這\n      if 100 % item == 0:\n        res.append(item)\n    except ZeroDivisionError:\n      # 碰到error時，run這裡\n      print(\"0不能當除數拉！！\")\n    except TypeError:\n      # 碰到error時，run這裡\n      print(\"請你輸入int/float的資料類型\")\n    except:\n      print(\"我實在不知道哪裡出錯了，但反正跳過\")\n      \n  return(res)\n\n\nprint(factor_100([2, 5, 7]))\n#> [2, 5]\nprint(factor_100([2, 5, 7, 0]))\n#> 0不能當除數拉！！\n#> [2, 5]\nprint(factor_100([2, 5, 7, \"hank\"]))\n#> 請你輸入int/float的資料類型\n#> [2, 5]"},{"path":"exception-handling.html","id":"懶人款-except-exception-as-e","chapter":"21 Exception Handling","heading":"21.3.3 懶人款: except Exception as e","text":"剛剛的except，把各種type的error都考慮進去了，很棒棒沒錯，但實務上，我們常常也不知道會碰到什麼error所以，我們可以改成這樣寫：except Exception e，意思是，我要except掉所有的Exception object，也就是所有type的Error，並且，e表示我還把這個object給存起來，那我後續搭配print(e)，就可以看到所屬的type和所屬的error message了：但我現在想要給user更多資訊，讓user知道，到底我遇到哪種type的error","code":"def factor_100(my_list):\n  res = []\n  for item in my_list:\n    try:\n      # 可能發生error的那句statement放這\n      if 100 % item == 0:\n        res.append(item)\n    except Exception as e:\n      print(e)\n      \n  return(res)\n\n\nprint(factor_100([2, 5, 7]))\n#> [2, 5]\nprint(factor_100([2, 5, 7, 0]))\n#> integer division or modulo by zero\n#> [2, 5]\nprint(factor_100([2, 5, 7, \"hank\"]))\n#> unsupported operand type(s) for %: 'int' and 'str'\n#> [2, 5]"},{"path":"flexible-arguments.html","id":"flexible-arguments","chapter":"22 flexible arguments","heading":"22 flexible arguments","text":"","code":""},{"path":"flexible-arguments.html","id":"args","chapter":"22 flexible arguments","heading":"22.1 *args","text":"*args是flexible arguments的縮寫，星號就把它翻譯成flexible就對了他的意思是，你可以很彈性的，要丟幾個argument進來，就丟幾個進來。舉例來說，我想寫一個加總的function，user丟3個數字進來，我就幫他加總3個，user丟9個數字進來，我就幫他加總9個，所以其實一開始我沒辦法訂好我的function要幾個參數，那我就把參數名稱定義成*args，來代表user想丟幾個進來都可以(事實上，只要星號開頭即可，星號後你要寫啥都沒關係，例如*, *abcd都可以，因為星號就代表flexible，只是習慣上大家喜歡寫*args，因為照字面意義就知道他是flexible arguments)一旦你把參數定成*args，它吃進function後，就會先把這堆args串成list，並命名為args，所以在你的function內，可以調用args這個object直接看例子：","code":"def add_all(*args):\n  \"\"\"Sum all values in *args together.\"\"\"\n  \n  ### Initialize sum\n  sum_all = 0\n  \n  # Accumulate the sum\n  for num in args: # args就是把user丟的所有arguments串成一個list，讓你使用\n    sum_all = sum_all + num\n  \n  return sum_all\n\nprint(add_all(1,2,3))\n#> 6\nprint(add_all(1,2,3,4,5))\n#> 15"},{"path":"flexible-arguments.html","id":"kwargs","chapter":"22 flexible arguments","heading":"22.2 **kwargs","text":"**kwargs是flexible keyword arguments 的縮寫剛剛的*args，都是直接丟argument進來，沒有寫明他是哪個參數，而**kwargs，就會寫成key-value pair的輸入也因為現在的input都是key-value pair了，所以python會把user丟進來的東西，先存成kwargs這個dictionary，然後我們再用這個dictionary來工作：如果今天定義的是：**haha，那dictionary就會存在haha裡","code":"def print_all(**kwargs):\n  \"\"\"Print out key-value pairs in **kwargs.\"\"\"\n  \n  # Print out the key-value pairs\n  for key, value in kwargs.items():\n    print(key + \": \" + value)\n    \nprint_all(\n  name = \"Hank Lee\", \n  job = \"Data Scientist\", \n  height = \"184\", \n  weight = \"80\"\n)\n#> name: Hank Lee\n#> job: Data Scientist\n#> height: 184\n#> weight: 80"},{"path":"flexible-arguments.html","id":"使用時機-1","chapter":"22 flexible arguments","heading":"22.2.1 使用時機","text":"**kwargs其實就類比於R的...參數，他特別適用在，你的function中要去call別的function，但不想逐一寫下別的function的arguments例如，我先定義一個function叫my_sum那我如果現在定義一個新的function，叫conditional_sum，要給他一個參數x，如果x是True，我才要做sum:特別注意的是，**kwargs一定要放在arguments的最後面，如果寫：def conditional_sum(**kwargs, x)，那會直接error給你看","code":"def my_sum(a, b):\n  return(a+b)def conditional_sum(x, **kwargs):\n  if x:\n    return(my_sum(**kwargs))\n  else:\n    return(\"do not calculate\")\n  \nprint(conditional_sum(x = True, a = 3, b = 5))\n#> 8\nprint(conditional_sum(x = False, a = 3, b = 5))\n#> do not calculate"},{"path":"recursion.html","id":"recursion","chapter":"23 recursion","heading":"23 recursion","text":"recursion(遞迴)在programming中的意思是：在函數中，呼叫函數自己，比如這樣：寫recursion時要很小心，因為他是個雙面刃：\n寫的好：code很簡潔，執行效率又高\n寫不好：無限迴圈無法停止(如上例)，耗費所有電腦資源\n寫的好：code很簡潔，執行效率又高寫不好：無限迴圈無法停止(如上例)，耗費所有電腦資源recursion有兩個經典例子，一個是n!的計算，另一個是費氏數列，我們來看看：","code":"def my_func(num):\n  3 + my_func(num)"},{"path":"recursion.html","id":"n-計算","chapter":"23 recursion","heading":"23.1 n! 計算","text":"如果今天想做個n!的function，我們可以用for來做但如果你用recursion，就會很簡單我們先看recursion的第一個重點，也就是n * test2(n-1)這一行所以當我輸入n=3時，他會做3 * test2(2) = 3 * 2 * test2(1) = 3*2*1*test2(0) = 3*2*1*0*test2(-1) = …看起來，前面都做對了，但等到test2(0)時就錯了所以，recursion會需要加上何時跳出這個條件。所以前面加了if n == 1: return n，那上面的遞迴式，就變成: 3 * test2(2) = 3 * 2 * test2(1) = 3*2*1 ，沒辦法再遞迴了，結束在這","code":"def test(n):\n  result = 1\n  for item in range(1, n+1):\n    result = result * item\n  return result\n\ntest(3)\n#> 6def test2(n):\n  if n == 1:\n    return n\n  else:\n    return n * test2(n-1)\n\n\nprint(test2(3))\n#> 6"},{"path":"recursion.html","id":"費氏數列","chapter":"23 recursion","heading":"23.2 費氏數列","text":"費氏數列的定義是:\n\\(a_1 = 0, \\ a_2 = 1\\)\n\\(a_n = a_{n-1} + a_{n-2}\\)，n >3\n也就是前兩項是0,1，之後各項的值，是前兩項的和。\n比如說： 0, 1, 1, 2, 3, 5, 8, …\n\\(a_1 = 0, \\ a_2 = 1\\)\\(a_n = a_{n-1} + a_{n-2}\\)，n >3也就是前兩項是0,1，之後各項的值，是前兩項的和。比如說： 0, 1, 1, 2, 3, 5, 8, …那我想寫一個function，告訴我第k項的值是多少：","code":"def fibo(k):\n  if k == 1:\n    return 0\n  elif k == 2:\n    return 1\n  else:\n    return fibo(k-1) + fibo(k-2)\n\nprint(fibo(5))\n#> 3"},{"path":"function就是另一種type的object.html","id":"function就是另一種type的object","chapter":"24 Function就是另一種type的object","heading":"24 Function就是另一種type的object","text":"之前我們看到x = [1,2,3]，我們會說x是list; 看到y = {'foo': 42}，我們會說y是dictionary那，看到function時：my_func是什麼？my_func就是另一種type的object，我們會說my_func是function這種type特別注意，my_func是function物件，但my_func()是去call這個function，得到return value","code":"def my_func():\n  print(\"hello\")type(my_func)\n#> <class 'function'>my_func\n#> <function my_func at 0x111df2ee0>\nmy_func()\n#> hello"},{"path":"function就是另一種type的object.html","id":"把function-assing給一個變數","chapter":"24 Function就是另一種type的object","heading":"24.1 把function assing給一個變數","text":"那既然my_func是一個物件，我就可以把這個物件assign到一個variable:","code":"f = my_func\nf()\n#> hello"},{"path":"function就是另一種type的object.html","id":"把function丟到listdictionary裡面","chapter":"24 Function就是另一種type的object","heading":"24.2 把function丟到list/dictionary裡面","text":"既然可以把function給assign到一個variable，那我們當然也可以把function加到各種collections裡面例如，把funciton加到list裡面：然後取出對應的位子後，call這個function的功能：或是把function加到dictionary裡面：然後，一樣取出對應的element後，再用他的功能：","code":"list_of_functions = [my_func, print, sum]list_of_functions[0]()\n#> hellodict_of_funcs = {\n  'func1': my_func,\n  'func2': print,\n  'func3': sum\n}dict_of_funcs.get('func2')(\"this is print function\")\n#> this is print function"},{"path":"function就是另一種type的object.html","id":"把function當成argument","chapter":"24 Function就是另一種type的object","heading":"24.3 把function當成argument","text":"假設我們現在已經寫好兩個function如下：那我們可以再寫一個function，來判斷某個定義的function是否含有docstring:這個function的argument就是一個function了，來試試看：","code":"def no_docstring_func():\n  return(43)\n\ndef yes_docstring_func():\n  \"\"\"\n  Docstring here hahaha\n  \"\"\"\n  return(42)def has_docstring(func):\n  \"\"\"\n  purpose: \n    check whether `func` has docstring or not\n  Args:\n    func (callable): A function\n  Returns:\n    bool\n  \"\"\"\n  return func.__doc__ is not Noneprint(has_docstring(no_docstring_func))\n#> False\nprint(has_docstring(yes_docstring_func))\n#> True"},{"path":"nested-function.html","id":"nested-function","chapter":"25 Nested Function","heading":"25 Nested Function","text":"把一個function，定義在另一個function內，那這個內部的function，我們就叫nested function，或是叫inner function，或是叫helper function，或叫child function就像我們在main script上，同一種pattern的code，複製貼上三次，就會想寫一個function一樣，如果我今天在自己定義的function中，同一種pattern的code，也複製貼上三次，那我就會想寫一個inner function先來看醜醜的例子：改寫成nested function的例子所以nested function的主要用途，就是節省力氣拉，沒什麼特別的","code":"def mult2plus5(x1, x2, x3):\n    \"\"\"multiply 2 thenplus 5 for input three values.\"\"\"\n    new_x1 = x1 * 2 + 5\n    new_x2 = x2 * 2 + 5\n    new_x3 = x3 * 2 + 5\n    return (new_x1, new_x2, new_x3)\n\nprint(mult2plus5(2,3,4))\n#> (9, 11, 13)def mult2plus5_nested(x1, x2, x3):\n    \n    def inner(x):\n      value = x*2 + 5\n      return value\n    \n    return (inner(x1), inner(x2), inner(x3))\n\nprint(mult2plus5_nested(2,3,4))    \n#> (9, 11, 13)"},{"path":"variable-scope-1.html","id":"variable-scope-1","chapter":"26 Variable Scope","heading":"26 Variable Scope","text":"","code":""},{"path":"variable-scope-1.html","id":"intro","chapter":"26 Variable Scope","heading":"26.1 Intro","text":"在我們寫python script時，每個variable都有自己所屬的scope(.e. 我是在哪個scope中被定義的)。那我們在呼叫這個變數時，系統就會先看你是在哪個scope做呼叫的，然後去找這個scope中有沒有你要的這個變數。例如下例：num = 4是在global scope中被定義的; num = 3是在local scope被定義的。所以在function中，你要他retun num，他就會先看他目前在哪個scope? -> local scope。所以他先去local scope中找找看有沒有num，結果找到num = 3，那他就會用num = 3但你在外面call print(num) 時，因為你是在global scope去call的，所以他會在global scope中有沒有num，結果找到num = 4，所以他會print 4出來","code":"num = 4 # 在global scope中被定義\nprint(num) # 在global scope中呼叫num\n#> 4\ndef func1():\n    num = 3 # 在local scope中被定義\n    return num # 在local scope中呼叫num\n\nprint(func1()) # 在global scope中呼叫func1\n#> 3\nprint(num) # 在global scope中呼叫num\n#> 4"},{"path":"variable-scope-1.html","id":"legb-scope","chapter":"26 Variable Scope","heading":"26.2 LEGB scope","text":"那接下來講更細一點，variable這個詞，可以把它一般化成object。而python的scope其實有四種，由低至高分別為LEGB。搜尋object時，先從呼叫的scope開始做搜尋，如果搜尋不到，就往上一個階層做搜尋。所以如果你從local scope呼叫一個變數的話，他就會這樣搜：\n先搜Local scope: 就是你define一個function時，他的body就是個local scope\n再搜Enclosing function scope: 晚點再定義\n再搜Global scope: 就是寫main script的地方\n最後Built-scope: 一些pre-define好的functions，例如sum。\n先搜Local scope: 就是你define一個function時，他的body就是個local scope再搜Enclosing function scope: 晚點再定義再搜Global scope: 就是寫main script的地方最後Built-scope: 一些pre-define好的functions，例如sum。所以，如果更改一下剛剛的例子：會發現在local scope中呼叫num時，因為local scope裡沒有num，所以他往上一層找(global scope)，找到num = 4，所以就用了這個4會發現在local scope中呼叫num時，因為local scope裡沒有num，所以他往上一層找(global scope)，找到num = 4，所以就用了這個4那再看個例子：那再看個例子：看到出現error了，因為我們在global scope中呼叫val時，他會先從global scope中找有沒有val，沒有的話，他會往built-scope找val，當然也是沒找到val，所以最後就給你error","code":"num = 4 # 在global scope中被定義\nprint(num) # 在global scope中呼叫num\n#> 4\ndef func1():\n    return num # 在local scope中呼叫num\n\nprint(func1()) # 在global scope中呼叫func1\n#> 4\nprint(num) # 在global scope中呼叫num\n#> 4def func1():\n    val = 3 # 在local scope中被定義\n    return val # 在local scope中呼叫num\n\nprint(func1()) # 在global scope中呼叫func1\n#> 3\nprint(val) # 在global scope中呼叫num\n#> Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'val' is not defined\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>"},{"path":"variable-scope-1.html","id":"用global這個keyword把local-scope的object給推到global-scope","chapter":"26 Variable Scope","heading":"26.3 用global這個keyword，把local scope的object給推到global scope","text":"","code":"def func1():\n    global num\n    num = 3\n    print(num)\n    \nprint(func1())\n#> 3\n#> None\nprint(num)\n#> 3"},{"path":"variable-scope-1.html","id":"enclosing-function-scope的例子","chapter":"26 Variable Scope","heading":"26.4 Enclosing function scope的例子","text":"剛剛講到python的scope分為LEGB四種，現在來講E這個Enclosing function scope首先，我們來看看以下的nested function。他的目的是，給我一串數字，我幫你把每個數字都乘上2再加5，然後吐出來。以下是demo:那剛剛講過，function內的scope，我們叫local，那現在function內還有function，該怎麼叫？答案是，最內層的function的scope，我們叫local，他外面的scope，我們叫enclosing function scope所以，標上註解後如下：那所以，維持剛剛搜尋時依照LEGB的順序，應該猜得出以下範例的答案：可以看到，先print出的inner()，用的n是local scope的n，所以是n=2後print出的n，用的n是enclosing function的n，所以是n=1","code":"def mult2plus5_nested(x1, x2, x3):\n    \n    def inner(x):\n      value = x*2 + 5\n      return value\n\n    return (inner(x1), inner(x2), inner(x3))\n\nprint(mult2plus5_nested(2,3,4))    \n#> (9, 11, 13)def mult2plus5_nested(x1, x2, x3):\n    # 這邊是enclosing function scope\n    def inner(x):\n      # 這邊是local\n      value = x*2 + 5 \n      return value\n    # 這邊又回到enclosing function scope\n    return (inner(x1), inner(x2), inner(x3))def outer1():\n    n = 1\n    def inner():\n        n = 2\n        print(n)\n    inner()\n    print(n)\n\nouter1()\n#> 2\n#> 1"},{"path":"variable-scope-1.html","id":"用nonlocal這個keyword","chapter":"26 Variable Scope","heading":"26.5 用nonlocal這個keyword…","text":"如同我們想把local的variable，推到global時，會用global，那現在，要把local的variable，推到enclosing function scope，會加入nonlocal：cool~ 最後要print出的n，他在enclosing function scope中找，他不是找到一開始定義的n=1，而是找到在local端定義好，然後被推到enclosing function scope的n=2","code":"def outer2():\n    n = 1\n    def inner():\n        nonlocal n\n        n = 2\n        print(n)\n    inner()\n    print(n)\n\nouter2()\n#> 2\n#> 2"},{"path":"closure.html","id":"closure","chapter":"27 closure","heading":"27 closure","text":"","code":""},{"path":"closure.html","id":"把function當成output","chapter":"27 closure","heading":"27.1 把function當成output","text":"之前講nested function，是在強調他可以簡化原function內部的計算(我把原function內一直重複出現的pattern，寫成一個inner function，讓他在裡面可以重複使用)。但有時候我們寫nested function的目的，是為了要output出這個nested function例如這樣：酷…我input東西後，可以製作出各式各樣的function那，為啥要這麼做呢？ 其實很簡單啊，還是在偷懶啊。想想看，如果今天你要寫個2次方的function，3次方的function，4次方的function…，你要一直重複定義這些一樣pattern的寫法(def function(x) x**2)，你不累嗎？所以我就寫個general function，然後你只要輸入n，我就給你n次方的function","code":"def raise_val(n):\n    \"\"\"Return the inner function.\"\"\"\n    \n    def inner(x):\n        \"\"\"Raise x to the power of n.\"\"\"\n        raised = x ** n\n        return raised\n      \n    return inner\n\n\nsquare = raise_val(2)\ncube = raise_val(3)\nprint(square(2), cube(4))\n#> 4 64"},{"path":"closure.html","id":"closure-1","chapter":"27 closure","heading":"27.2 closure","text":"剛剛講了nested function，以及把nested function給output出來那現在要講的是，這個output的nested function，可以攜帶他外層的資訊(nonlocal variables)一起出來，這種行為我們叫closure看以下這個簡單的例子：可以看到，當我們call f的時候，其實是在callbar這個函數，那bar這個函數會需要用到a，那a從哪裡來？我又沒定義，他怎麼知道？答案是，你如果只看bar這個函數，你當然沒有a的資訊，但如果你是用foo()所造出的bar函數，那他就帶有enclosing scope的a = 5這個資訊了。這個a就是nonlocal variable。驗證一下，f這個函數是用foo()所output出的function，所以他應該會帶有closure性質，那我就可以用以下語法檢驗：發現，f果然存有.__closure__這個attribute如果你只是一般的function物件，是不會有.__closure__這個attribute的那回到f.__closure__，我現在看不到他的長相，但可以看他的type:發現是一個tuple，他裡面其實就存有所有要用到的一對一對的(nonlocal variable, value) pair比如剛剛這個例子，就是(, 5)這個pair所以我們可以驗證一下，f.__closure__這個tuple是不是只有一個pair:如果要抓出來看，用以下語法：打鐵趁熱，看以下的例子：從這邊可以看到，我們要output出來的child function，他會攜帶arg1, arg2, my_dict, value這四個nonlocal variable(照字母順序排列)驗證一下：果然帶有4個nonlocal variables，我們一一把它們叫出來看：","code":"def foo():\n  a = 5\n  def bar():\n    print(a)\n  return bar\n\nf = foo()\nf()\n#> 5f.__closure__\n#> (<cell at 0x1378c3f10: int object at 0x10c64a960>,)def bar():\n    print(a)\n\ndir(bar)\n#> ['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']type(f.__closure__)\n#> <class 'tuple'>len(f.__closure__)\n#> 1f.__closure__[0].cell_contents\n#> 5f.__closure__[0].cell_contents\n#> 5def parent(arg1, arg2):\n  value = 22\n  my_dict = {\"chocolate\": \"yummy\"}\n  \n  def child():\n    print(2*value) # 這邊就用到nonlocal variable: value\n    print(my_dict['chocolate']) # 這邊就用到nonlocal variable: my_dict\n    print(arg1+arg2) # 這邊用到nonlocal variable: arg1, arg2\n  \n  return childnew_function = parent(3, 4)\nlen(new_function.__closure__)\n#> 4for element in new_function.__closure__:\n  print(element.cell_contents)\n#> 3\n#> 4\n#> {'chocolate': 'yummy'}\n#> 22"},{"path":"decorator.html","id":"decorator","chapter":"28 decorator","heading":"28 decorator","text":"","code":""},{"path":"decorator.html","id":"先備知識","chapter":"28 decorator","heading":"28.1 先備知識","text":"在講decorator前，我們先複習decorator會用到的4個先備知識\nfunctions objects\nnested functions\nnonlocal scope\nclosure\nfunctions objectsnested functionsnonlocal scopeclosure","code":""},{"path":"decorator.html","id":"function-as-object","chapter":"28 decorator","heading":"28.1.1 function as object","text":"定義好的function，他本身就是一個object，例如：my_func是一個object，但my_func()是call這個函數我們可以把函數object拿去assign成一個variable、放在list/dictionary裡面、或當成其他函數的一個argument","code":"def my_func():\n  print(\"hello\")\n\ntype(my_func)\n#> <class 'function'>my_func\n#> <function my_func at 0x10cef4ee0>\nmy_func()\n#> hellodef my_func():\n  print(\"hello\")\n\n# assign成一個variable\nf = my_func\nf()\n\n# 放在list, dictionary裡面\n#> hello\nmy_list = [my_func, print]\nmy_list[0]()\n\n# 當其他函數的argument\n#> hello\ndef second_function(func):\n  func()\n\nsecond_function(my_func)\n#> hello"},{"path":"decorator.html","id":"nested-function-1","chapter":"28 decorator","heading":"28.1.2 nested function","text":"定義： 在一個function底下，又定義一個function，這個內層的function，我們叫inner function/ nested function/ helper function/ child function 都可以此外，我們可以把這個nested function給output出來","code":"# outer function/ parent function\ndef parent():\n  # nested/inner/child/helper function\n  def child():\n    pass\n  return child"},{"path":"decorator.html","id":"nonlocal-variable","chapter":"28 decorator","heading":"28.1.3 nonlocal variable","text":"定義： local variable是指最內層的scope所定義的variable，而nonlocal scope，就是最內層的外面一層(仍在函數的scope內)所定義的variablenonlocal scope就是LEGB中的E(Enclosing scope)上例中，child內的scope，叫local scope; child外但是是parent內的scope，叫nonlocal scope/ enclosing scope所以，arg1, arg2, my_dict, value為四個nonlocal variable(照字母順序排列)","code":"def parent(arg1, arg2):\n  value = 22\n  my_dict = {\"chocolate\": \"yummy\"}\n  \n  def child():\n    print(2*value) # 這邊就用到nonlocal variable: value\n    print(my_dict['chocolate']) # 這邊就用到nonlocal variable: my_dict\n    print(arg1+arg2) # 這邊用到nonlocal variable: arg1, arg2\n  \n  return child"},{"path":"decorator.html","id":"closure-2","chapter":"28 decorator","heading":"28.1.4 closure","text":"output的nested function，所攜帶的nonlocal variables，我們叫closure例如下例：","code":"new_function = parent(3, 4)\n# new_function會帶有closure屬性，且type是tuple，裡面的每個element，都是(nonlocal_var, value)的pair\ntype(new_function.__closure__)\n# 長度會是4，因為有四組pair\n#> <class 'tuple'>\nlen(new_function.__closure__)\n# 看closure的內容\n#> 4\nfor element in new_function.__closure__:\n  print(element.cell_contents)\n#> 3\n#> 4\n#> {'chocolate': 'yummy'}\n#> 22"},{"path":"decorator.html","id":"intro-to-decorator","chapter":"28 decorator","heading":"28.2 Intro to decorator","text":"decorator就字面上的意思就是裝飾子，裝飾什麼東西呢？裝飾一個已經存在的funciton例如下例：在此例中，@double_args就是一個decorator，他裝飾的東西，就是下面的function: multiply他如何裝飾的呢？他會把multiply的arguments，都先乘以2，再丟到multiply這個function裡面這也是為什麼multiply(1, 5)會變成 2x10 = 20 的原因那@double_args的背後到底是什麼？為什麼可以有這種效果呢？其實 @double_args的寫法，等同於在做下面這件事：所以可以發現，@dobule_args的作用，其實是在做這件事：他把被裝飾的function(.e. multiply)，丟到裝飾function(.e. double_args)，然後assign成和被裝飾的function一樣的名字，那之後用這個function，就都會是被裝飾後的版本了他把被裝飾的function(.e. multiply)，丟到裝飾function(.e. double_args)，然後assign成和被裝飾的function一樣的名字，那之後用這個function，就都會是被裝飾後的版本了所以重點在於@double_args的寫法，是func = double_args(func)的簡潔寫法，而func可以放任何要被裝飾的函數所以重點在於@double_args的寫法，是func = double_args(func)的簡潔寫法，而func可以放任何要被裝飾的函數打鐵趁熱，練習一下。我想寫一個decorator，讓每個被他裝飾的function，都會自動print出”hahaha”：打鐵趁熱，練習一下。我想寫一個decorator，讓每個被他裝飾的function，都會自動print出”hahaha”：從這個例子中，我們已經可以很快看到decorator的一個使用時機：\n當我們想新增一個功能到已經寫好的多個函數中時(e.g. 這邊的func1, func2)，我不用再一一去改這些已經定義過的函數，我只要寫個decorator，然後把他加上在這些函數上就好。\n而且，如果之後決定拿掉這些功能，那也只要拔掉decorator的標籤即可，我都不用動到我之前定義好的func1, func2, …\n當我們想新增一個功能到已經寫好的多個函數中時(e.g. 這邊的func1, func2)，我不用再一一去改這些已經定義過的函數，我只要寫個decorator，然後把他加上在這些函數上就好。而且，如果之後決定拿掉這些功能，那也只要拔掉decorator的標籤即可，我都不用動到我之前定義好的func1, func2, …","code":"def double_args(func):\n  def wrapper(a, b):\n    return func(2*a, 2*b)\n  return(wrapper)@double_args\ndef multiply(a, b):\n  return a * b\n\nmultiply(1, 5)\n#> 20# 定義一個function，讓他的input argument是要裝飾的function\ndef double_args(func):\n  # 定義一個nested function，來改變`func`的行為\n  def wrapper(a, b):\n    return func(2*a, 2*b) # 把func的arguments都先乘上2，再evaluate\n  \n  # 回傳這個修改好的function\n  return(wrapper)\n\n# 準備要被裝飾的function如下\ndef multiply(a, b):\n  return a * b\n\nmultiply = double_args(multiply)\nmultiply(1,5)\n#> 20multiply = double_args(multiply)def haha(func):\n  def wrapper(*args, **kwargs):\n    print(\"hahaha\")\n    return func(*args, **kwargs)\n  return wrapper\n\n@haha\ndef func1():\n  print(\"this is function 1\")\n\nfunc1()\n#> hahaha\n#> this is function 1\n@haha\ndef func2():\n  print(\"this is function 2\")\n\nfunc2()\n#> hahaha\n#> this is function 2"},{"path":"decorator.html","id":"decorators-and-metadata","chapter":"28 decorator","heading":"28.3 Decorators and metadata","text":"decorator有一個問題是，他會讓我們原始function的metadata(e.g. docstring)消失：例如，我的原始function叫sleep_n_seconds，如下：那我是看得到他的docstring的：但如果我把timer這個decoratro加上去，就會變成看不到為什麼會這樣？這是因為，我們現在以為的sleep_n_seconds，其實是decorator中，被吐出來的wrapper而這個wrapper，很明顯的沒寫docstring，所以才會讓你看不到原本sleep_n_seconds的docstring如果要讓wrapper也呈現原本sleep_n_seconds的docstring，我們可以再加一個decorator@wraps(func)在前面：上面的code中，注意：\n一開始先引用了： functools import wraps\nwrapper的前面，加上了有參數的decorator，@wraps(func)，參數的func就是一開始丟入timer的func，所以他會把func的docstring加進來\n一開始先引用了： functools import wrapswrapper的前面，加上了有參數的decorator，@wraps(func)，參數的func就是一開始丟入timer的func，所以他會把func的docstring加進來事實上，他加進來的是所有的meta-data，不只docstring，還包括：\ndefault argument的值是多少\nwrap進來的原始function長怎樣(.e. 還沒被裝飾前的sleep_n_seconds)\ndefault argument的值是多少wrap進來的原始function長怎樣(.e. 還沒被裝飾前的sleep_n_seconds)在實務上，這個original function蠻有用的。比如說，你原本寫了一堆function，也都運作得好好的，但你老闆突然神來一筆，寫了一個decorator，強迫你要加到你目前的所有function上但你一加上這個decorator後，發現運算速度慢好多…那為了說服老闆，你就可以做這個實驗：\n計算加入decorator”前”的計算時間\n計算加入decorator”後”的計算時間\n看一下差多少就知道了\n計算加入decorator”前”的計算時間計算加入decorator”後”的計算時間看一下差多少就知道了如果加入decorator以後，計算速度變慢超多，那表示這個decorator太肥，要評估看看是不是真的有需要用這個decorator","code":"def sleep_n_seconds(n=10):\n  \"\"\"\n  Purpose:\n    Pause processing for n seconds.\n  Args:\n    n (int): The number of seconds to pause for.\n  \"\"\"\n  time.sleep(n)print(sleep_n_seconds.__doc__)\n#> \n#>   Purpose:\n#>     Pause processing for n seconds.\n#>   Args:\n#>     n (int): The number of seconds to pause for.\n#> import time\n\ndef timer(func):\n  def wrapper(*args, **kwargs):\n    t_start = time.time()\n    result = func(*args, **kwargs)\n    t_total = time.time() - t_start\n    print(f\"{func.__name__} took {t_total} seconds to run\")\n    return result\n  \n  return wrapper\n\n@timer\ndef sleep_n_seconds(n=10):\n  \"\"\"\n  Purpose:\n    Pause processing for n seconds.\n  Args:\n    n (int): The number of seconds to pause for.\n  \"\"\"\n  time.sleep(n)\n\n\nprint(sleep_n_seconds.__doc__)\n#> Noneprint(sleep_n_seconds.__name__)\n#> wrapperdef wrapper(*args, **kwargs):\n    t_start = time.time()\n    result = func(*args, **kwargs)\n    t_total = time.time() - t_start\n    print(f\"{func.__name__} took {t_total} seconds to run\")\n    return resultimport time\nfrom functools import wraps # 加入這行，引用wraps\n\ndef timer(func):\n  @wraps(func) # 加入這行，有參數的decorator，參數的func就是一開始丟入timer的func\n               # 所以他會把func的docstring加進來\n  def wrapper(*args, **kwargs):\n    t_start = time.time()\n    result = func(*args, **kwargs)\n    t_total = time.time() - t_start\n    print(f\"{func.__name__} took {t_total} seconds to run\")\n    return result\n  \n  return wrapper\n\n@timer\ndef sleep_n_seconds(n=10):\n  \"\"\"\n  Purpose:\n    Pause processing for n seconds.\n  Args:\n    n (int): The number of seconds to pause for.\n  \"\"\"\n  time.sleep(n)\n\nprint(sleep_n_seconds.__name__)\n#> sleep_n_seconds\nprint(sleep_n_seconds.__doc__)\n#> \n#>   Purpose:\n#>     Pause processing for n seconds.\n#>   Args:\n#>     n (int): The number of seconds to pause for.\n#> # default argument的值\nprint(sleep_n_seconds.__defaults__)\n\n# original function，可以直接使用這個裝飾前的function\n#> None\nsleep_n_seconds.__wrapped__\n#> <function sleep_n_seconds at 0x10d079c10>"},{"path":"decorator.html","id":"有arguments的decorators","chapter":"28 decorator","heading":"28.4 有arguments的decorators","text":"剛剛介紹的decorator，在定義的時候，都只有func一個參數，表示他即將要裝飾的function。但有的時候，我會希望還能再加上其他參數。例如，我想寫一個decorator，叫run_n_times，他會將要裝飾的那個function，重複run n次，那這時候就需要n這個argument了那寫法的邏輯其實是這樣：\n寫個function，他的input argument只有n，然後他的output是一個decorator!!\n我們再用這個output出來的decorator，去裝飾我要裝飾的function\n寫個function，他的input argument只有n，然後他的output是一個decorator!!我們再用這個output出來的decorator，去裝飾我要裝飾的function所以，現在我如果用run_n_times(3)，那就可以做出一個讓被修飾的function run 3次的decorator：cool，但實務在用時，@run_three_time，可以直接簡化成@run_n_times(3)就好！！我們以run 5次來當範例試試：打鐵趁熱，來寫個html的generator，讓我輸入的文字，自動加上指定的tag:加上粗體的tag:加上斜體的tag加上div的tag","code":"def run_n_times(n):\n  \"\"\"\n  Define and return a decorator\n  \"\"\"\n  # 之前寫好的decorator放這邊，然後讓他吃我的參數n，讓他變成新的decorator\n  def decorator(func):\n    def wrapper(*args, **kwargs):\n      for i in range(n): # 重複進行n次\n        func(*args, **kwargs)\n    return wrapper\n  # 把這個定義好的，新的decorator，給丟出來\n  return decoratorrun_three_time = run_n_times(3)\n@run_three_time\ndef say_hello():\n  print(\"hello\")\n\nsay_hello()\n#> hello\n#> hello\n#> hello@run_n_times(5)\ndef say_hello():\n  print(\"hello\")\n\nsay_hello()\n#> hello\n#> hello\n#> hello\n#> hello\n#> hellodef html(open_tag, close_tag):\n  def decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n      msg = func(*args, **kwargs)\n      return f'{open_tag}{msg}{close_tag}'\n    return wrapper\n  return decorator@html(\"<b>\", \"<\/b>\")\ndef hello(name):\n  return f'Hello {name}!'\n  \nprint(hello('Alice'))\n#> <b>Hello Alice!<\/b>@html(\"<i>\", \"<\/i>\")\ndef goodbye(name):\n  return f'Goodbye {name}.'\n  \nprint(goodbye('Alice'))\n#> <i>Goodbye Alice.<\/i># Wrap the result of hello_goodbye() in <div> and <\/div>\n@html(\"<div>\", \"<\/div>\")\ndef hello_goodbye(name):\n  return f'\\n{hello(name)}\\n{goodbye(name)}\\n'\n  \nprint(hello_goodbye('Alice'))\n#> <div>\n#> <b>Hello Alice!<\/b>\n#> <i>Goodbye Alice.<\/i>\n#> <\/div>"},{"path":"decorator.html","id":"real-world-examples","chapter":"28 decorator","heading":"28.5 Real-world examples","text":"decorator的使用時機: add common behavior multiple functions","code":""},{"path":"decorator.html","id":"time-a-function","chapter":"28 decorator","heading":"28.5.1 time a function","text":"我想寫一個timer的decorator，來print出該function要花多少時間run那我現在寫一個sleep_n_seconds的function，就可以測測是不是可以work","code":"import time\n\ndef timer(func):\n  \"\"\"\n  Purpose:\n    A decorator that prints how long a function took to run\n  Args:\n    func (callable): The function being decorated  \n  Returns:\n    callable: the decorated function\n  \"\"\"\n  def wrapper(*args, **kwargs):\n    t_start = time.time()\n    result = func(*args, **kwargs)\n    t_total = time.time() - t_start\n    print(f\"{func.__name__} took {t_total} seconds to run\")\n    return result\n  \n  return wrapper@timer\ndef sleep_n_seconds(n):\n  time.sleep(n)\n\nsleep_n_seconds(2)\n#> sleep_n_seconds took 2.0100839138031006 seconds to run\nsleep_n_seconds(5)\n#> sleep_n_seconds took 5.004548072814941 seconds to run"},{"path":"decorator.html","id":"counter","chapter":"28 decorator","heading":"28.5.2 counter","text":"假設我們今天寫了一個新的web app，然後想看看各支function被call了幾次那過了一陣子後，我們就可以看一下是不是有些function可以被remove，反正user根本都沒在用那我就可以寫個decorator，加在我所有想觀察的function的上面，就可以做到這件事：","code":"def counter(func):\n  def wrapper(*args, **kwargs):\n    wrapper.count += 1\n    # Call the function being decorated and return the result\n    return func(*args, **kwargs)\n  wrapper.count = 0\n  # Return the new decorated function\n  return wrapper\n\n# Decorate foo() with the counter() decorator\n@counter\ndef foo():\n  print('calling foo()')\n  \nfoo()\n#> calling foo()\nfoo()\n#> calling foo()\nprint(f'foo() was called {foo.count} times.')\n#> foo() was called 2 times."},{"path":"decorator.html","id":"print-the-return-type","chapter":"28 decorator","heading":"28.5.3 print the return type","text":"在debug的時候，常常會懷疑，原本寫好的function，吐出來的value的資料類型，到底是不是我心中想的那樣例如，我以為我寫的這個function，會吐tuple出來，但結果他是吐list那常見的作法，就是進到這個function去debug，或是在這個function中，叫他多print一下return的type但只要有這個需求的function一多，你就又會覺得很煩了，所以這時候，就又可以用decorator了： 我只要寫個decorator，那我想裝飾哪些function就看哪些function：現在來試試效果：","code":"def print_return_type(func):\n  # Define wrapper(), the decorated function\n  def wrapper(*args, **kwargs):\n    # Call the function being decorated\n    result = func(*args, *kwargs)\n    print(f'{func.__name__}() returned type {type(result)}')\n    return result\n  # Return the decorated function\n  return wrapper@print_return_type\ndef foo(value):\n  return value\n  \nprint(foo(42))\n#> foo() returned type <class 'int'>\n#> 42\nprint(foo([1, 2, 3]))\n#> foo() returned type <class 'list'>\n#> [1, 2, 3]\nprint(foo({'a': 42}))\n#> foo() returned type <class 'dict'>\n#> {'a': 42}"},{"path":"decorator.html","id":"memorize-results","chapter":"28 decorator","heading":"28.5.4 memorize results","text":"有時候我們寫了一個function，他每做一次運算，都要花很久的時間。那我就希望，把input, output給記下來，例如我如果call過n次這個function，我就累積了n筆input和output，可記成這樣：那之後call這個function時，我就先去查之前有沒有做過這組input，如果有，我就直接給你output的結果，根本不用再跑一次這個function那要達成這個目的，我就可以寫個decorator:來試試看他的效果(報error，之後再debug吧)","code":"cache = {\n  (arg1_1, arg2_1): result_1,\n  (arg1_2, arg2_2): result_2,\n  ...,\n  (arg1_n, arg2_n): result_n\n}def memorize(func):\n  \"\"\"\n  Purpose:\n    store the results of the decorated function for fast lookup\n  \"\"\"\n  \n  cache = {}\n  def wrapper(*args, **kwargs):\n    if (args, kwargs) not in cache:\n      cache[(args, kwargs)] = func(*args, **kwargs)\n    return cache.get(args, kwargs)\n  \n  return wrapper@memorize\ndef slow_function(a, b):\n  print(\"sleeping...\")\n  time.sleep(5)\n  return a + b\n\nslow_function(a = 3, b = 4)\nslow_function(a = 3, b = 4)"},{"path":"decorator.html","id":"timeout","chapter":"28 decorator","heading":"28.5.5 timeout","text":"這邊要寫一個decorator，他會去監控我的function的運行時間，如果超過我的忍耐，我就直接停到這個function這會是一個有argument的decorator，參數是n_seconds，也就是我可以容忍的運行秒數這邊注意到，使用到了沒學過的signal module，那它的作用是，你用signal.alarm(3)，，來開起計時器，如果3秒後還沒結束，他就會跳timeout error出來那我們試試看以下例子：運行時間，小於3秒，所以ok那如果運行時間大於3秒，會show timeout error (這邊就不執行了，因為session會斷掉)","code":"import time\nimport signal\n\ndef timeout(n_seconds):\n  def decorator(func):\n    def wrapper(*args, **kwargs):\n      # set an alarm for n seconds\n      signal.alarm(n_seconds)\n      try:\n        return func(*args, **kwargs)\n      finally:\n        # cancel alarm\n        signal.alarm(0)\n    return wrapper\n  return decorator@timeout(3)\ndef foo():\n  time.sleep(2)\n  print(\"foo!\")\n\nfoo()\n#> foo!@timeout(3)\ndef foo():\n  time.sleep(5)\n  print(\"foo!\")\n\nfoo()"},{"path":"functional-programming.html","id":"functional-programming","chapter":"29 functional programming","heading":"29 functional programming","text":"","code":""},{"path":"functional-programming.html","id":"lambda-function","chapter":"29 functional programming","heading":"29.1 lambda function","text":"假設我們現在有一個function如下：那定義完成後，就建立了一個test物件，此物件佔有記憶體空間我們可以call此function做事那lambda function，是一種簡便的寫法，他可以把上面這個function，改成用以下方式定義：可以看到寫法就是 lambda {arg1},{arg2},...,{arg_n}: …`那這邊把函數定義的結果，assign到f這個變數上，我們就可以使用它了：那實務上，lambda function不會這樣用，而是會和map, reduce, filter這類的高階函數搭配使用還記得高階函數的定義，就是input argument有function，或output有function。那map, reduce, filter都是input argument有function，啥function？lambda function!!接下來就分別介紹這些高階函數與lambda的搭配使用","code":"def test(x, y):\n  return x + 2*ytest\n#> <function test at 0x1160a8ee0>test(1,2)\n#> 5f = lambda x, y: x + 2*yf(1,2)\n#> 5"},{"path":"functional-programming.html","id":"map-with-lambda","chapter":"29 functional programming","heading":"29.2 map with lambda","text":"map要吃兩個參數:\nlambda function: 準備要工作的function\niterable object: 某個iterable object，例如一個list\nlambda function: 準備要工作的functioniterable object: 某個iterable object，例如一個list那map就會逐一取出iterable裡面的每個element，然後對他做lambda function舉例來說，我有一個list，裡面每個element都是一個單詞，然後我想用map function去對此list的每個element做以下的運算：算單詞字長+2。那我就可以這樣寫：從這個例子可以看到以下用法：\nmap在python中，是先定義函數，再放iterable object進去。但在R裡面是倒過來，先給iterable object，才放自定義函數\n自定義函數這邊，我們其實只想放個用完即丟的函數，不想先在外面定義好，才拿進來用。這時候，就會用到lambda function\n這個lambda function的寫法，就是先宣告他是lambda function & 提供input parameter，加上冒號後，寫下function body就完成。所以他不用在一開始寫def，也不用在結束後寫return，省去很多麻煩。更重要的是，沒有額外在main script定義函數，所以減少了記憶體空間(因為不需要開個記憶體空間來存這個定義的函數)\nmap後的結果，是一個map object，要用list()把他轉成list，才看得到最後的結果\n從這個例子可以看到以下用法：map在python中，是先定義函數，再放iterable object進去。但在R裡面是倒過來，先給iterable object，才放自定義函數自定義函數這邊，我們其實只想放個用完即丟的函數，不想先在外面定義好，才拿進來用。這時候，就會用到lambda function這個lambda function的寫法，就是先宣告他是lambda function & 提供input parameter，加上冒號後，寫下function body就完成。所以他不用在一開始寫def，也不用在結束後寫return，省去很多麻煩。更重要的是，沒有額外在main script定義函數，所以減少了記憶體空間(因為不需要開個記憶體空間來存這個定義的函數)map後的結果，是一個map object，要用list()把他轉成list，才看得到最後的結果","code":"voc_list = [\"Hank\", \"statistics\", \"basketball\", \"nice guy\"]\nresult_map = map(lambda x: len(x)+2, voc_list)\nprint(result_map)\n#> <map object at 0x1160f21c0>\nprint(list(result_map))\n#> [6, 12, 12, 10]"},{"path":"functional-programming.html","id":"reduce-with-lambda","chapter":"29 functional programming","heading":"29.3 reduce with lambda","text":"reduce要吃兩個參數:\nlambda function: 準備要工作的function\niterable object: 某個iterable object，例如一個list\nlambda function: 準備要工作的functioniterable object: 某個iterable object，例如一個listreduce的作用直接舉例比較快我有一個iterable object，是x = [1,2,3,4,5]，然後我有一個lambda function，是相加，lambda x, y: x+y，那做reduce時，會寫成reduce(lambda x, y: x+y, list)，他就是在做：\n1 + 2 = 3 (前兩個element相加，得到3)\n3 + 3 = 6 (把剛剛計算的結果，和下一個element相加)\n6 + 4 = 10 (把剛剛計算的結果，和下一個element相加)\n10 + 5 = 15 (把剛剛計算的結果，和下一個element相加)\n1 + 2 = 3 (前兩個element相加，得到3)3 + 3 = 6 (把剛剛計算的結果，和下一個element相加)6 + 4 = 10 (把剛剛計算的結果，和下一個element相加)10 + 5 = 15 (把剛剛計算的結果，和下一個element相加)小提醒是，reduce這個function住在functools這個package裡，所以要先import他：","code":"from functools import reduce\nimport numpy as np\nnum_list = [1,2,3,4,5]\nresult_reduce = reduce(lambda x, y: x+y, num_list)\nprint(result_reduce)\n#> 15\nprint(sum(num_list))\n#> 15"},{"path":"functional-programming.html","id":"filter-with-lambda","chapter":"29 functional programming","heading":"29.4 filter with lambda","text":"filter的寫法是這樣：filter(lambda function, iterable)，其中，這個lambda function的回傳值要是True/False，而filter的回傳值，就是把iterable所對應到的True給回傳出來所以很符合R的filter的用法：符合的，篩選出來看個例子：我想篩選出iterable中，字長+2後>9的：那舉一反三，我如果有一個字串list，我想抓出”ha”開頭的字，我也可以用filter","code":"print(voc_list)\n#> ['Hank', 'statistics', 'basketball', 'nice guy']\nresult_filter = filter(lambda x: len(x)+2 > 9, voc_list)\nprint(list(result_filter))\n#> ['statistics', 'basketball', 'nice guy']str_list = [\"hahaha\", \"hank\", \"hamonica\", \"balabala\", \"nonononono\"]\nresult = filter(lambda x: x[0:2]==\"ha\", str_list)\nprint(list(result))\n#> ['hahaha', 'hank', 'hamonica']"},{"path":"oop-fundamentals.html","id":"oop-fundamentals","chapter":"30 OOP Fundamentals","heading":"30 OOP Fundamentals","text":"","code":""},{"path":"oop-fundamentals.html","id":"what-is-oop","chapter":"30 OOP Fundamentals","heading":"30.1 What is OOP?","text":"OOP是一種programming的設計思維，他以object為coding的最小單位。OOP是一種programming的設計思維，他以object為coding的最小單位。那到底什麼是object？要回答這個問題，我們要先學會什麼是class。那到底什麼是object？要回答這個問題，我們要先學會什麼是class。之前在寫code的時候，我們都會命名出很多variable，那現在，我們用分類問題的角度去想，是不是某一群variable，可以一起被歸為一類？如果可以的話，那我要要定義的，就不會是一個variable，而是要定義出一種類別(class)！之前在寫code的時候，我們都會命名出很多variable，那現在，我們用分類問題的角度去想，是不是某一群variable，可以一起被歸為一類？如果可以的話，那我要要定義的，就不會是一個variable，而是要定義出一種類別(class)！舉例來說，今天我想定義出顧客(Customer)這個class，那我該怎麼定義呢？我們會用state和behavior這兩個方向來定義一個class。舉例來說，今天我想定義出顧客(Customer)這個class，那我該怎麼定義呢？我們會用state和behavior這兩個方向來定義一個class。state指的是這個class所具備的特徵，behavior是指這個class所能施展的行為。state指的是這個class所具備的特徵，behavior是指這個class所能施展的行為。所以，回到顧客這個class的例子，state我就可以定義成email和phone這兩個特徵(因為每個顧客，應該都具備這兩個特徵)，behavior我就定義成”跟我下單”和”跟我取消訂單”這兩種行為。那做到這邊，我就算完成了Customer class的定義。所以，回到顧客這個class的例子，state我就可以定義成email和phone這兩個特徵(因為每個顧客，應該都具備這兩個特徵)，behavior我就定義成”跟我下單”和”跟我取消訂單”這兩種行為。那做到這邊，我就算完成了Customer class的定義。接下來，我只要填入state特定的value，就可以realize出各式各樣的客戶。例如我想realize出A客戶，那我就把A客戶的email和phone填入就好。而這樣realize完後，我們就稱這個A客戶是一個object。此時，我們知道他的states(email和phone都有)，也知道他有可能對我們施展的behavior(下訂單 & 取消訂單)接下來，我只要填入state特定的value，就可以realize出各式各樣的客戶。例如我想realize出A客戶，那我就把A客戶的email和phone填入就好。而這樣realize完後，我們就稱這個A客戶是一個object。此時，我們知道他的states(email和phone都有)，也知道他有可能對我們施展的behavior(下訂單 & 取消訂單)所以，我可以realize各式各樣的object specific state value(在此例，就是realize各式各樣的客戶)所以，我可以realize各式各樣的object specific state value(在此例，就是realize各式各樣的客戶)以圖來描述，可以畫成下面這張圖：\n所以總結一下，Class和Object可以這樣定義：\nClass 就是一個object製造機，他是一個抽象的概念。這個製造機像個藍圖一樣，告訴我們怎麼具體化一個實例(instance)出來。而藍圖裡面寫的東西，就是有關這個class該有的states以及behavior.\nObject 就是instance，他是該class所建造出來的一個具體實例。\n所以總結一下，Class和Object可以這樣定義：Class 就是一個object製造機，他是一個抽象的概念。這個製造機像個藍圖一樣，告訴我們怎麼具體化一個實例(instance)出來。而藍圖裡面寫的東西，就是有關這個class該有的states以及behavior.Object 就是instance，他是該class所建造出來的一個具體實例。與OOP對比的另一種設計思維，是R的procedural programming。R code的寫法，就像一步又一步的步驟，把結果給做出來。與OOP對比的另一種設計思維，是R的procedural programming。R code的寫法，就像一步又一步的步驟，把結果給做出來。但OOP不是這樣，OOP的寫法強調的不是步驟，而是object間的互動(e.g. 繼承/多形)。兩者的比較如下表：但OOP不是這樣，OOP的寫法強調的不是步驟，而是object間的互動(e.g. 繼承/多形)。兩者的比較如下表：","code":""},{"path":"oop-fundamentals.html","id":"oop-in-python","chapter":"30 OOP Fundamentals","heading":"30.2 OOP in Python","text":"在python裡面，所有東西，都是object!!例如，你隨便key個6，6就是一個object，你只要把它存成變數，就可以看到他所屬的class隨便整理python裡面的各式各樣object，以及他所屬的class:\nObject\nClass\nremark\n5\nint\n\n“Hello”\nstr\n\npd.DataFrame()\nDataFrame\n\nnp.mean\nfunction\n\n…\n…\n\n隨便整理python裡面的各式各樣object，以及他所屬的class:既然所有東西都是object，那我應該有他的state和behavior訊息吧？在python中，state的訊息，被存在attribute中，behavior的訊息，被存在method中。\nAttributes encode state object represented variables. 例如，.shape就是numpy.ndarray object的一個attribute，注意到他是用variable的形式存在的，所以shape後面沒有括號。\nMethods encode behavior object represented functions. 例如，.reshape()就是numpy.ndarray的method。注意到他是用function的形式存在的，所以會看到括號，括號內也可能要輸入argument\n既然所有東西都是object，那我應該有他的state和behavior訊息吧？在python中，state的訊息，被存在attribute中，behavior的訊息，被存在method中。Attributes encode state object represented variables. 例如，.shape就是numpy.ndarray object的一個attribute，注意到他是用variable的形式存在的，所以shape後面沒有括號。Methods encode behavior object represented functions. 例如，.reshape()就是numpy.ndarray的method。注意到他是用function的形式存在的，所以會看到括號，括號內也可能要輸入argument來看個numpy object例子：來看個numpy object例子：最後，提醒一下，一個程式語言可以是OOP，或是procedural，或是both。例如Python就是both，我們可以用procedural的寫法，一步一步的做完data analysis，但也可以用OOP的寫法來做。R也是如此，只是R的OOP要借助第三方套件R6","code":"a = 6\nprint(type(a)) #class\n#> <class 'int'>import numpy as np\na = np.array([1,2,3,4])\n# 看a是哪種class\nprint(type(a))\n#> <class 'numpy.ndarray'># shape attribute\na.shape\n#> (4,)# reshape method\na.reshape(2,2)\n#> array([[1, 2],\n#>        [3, 4]])"},{"path":"oop-fundamentals.html","id":"my-first-class","chapter":"30 OOP Fundamentals","heading":"30.3 My first class","text":"開始來寫我的第一個class，就用剛剛customer的例子上面這個例子，我們最一開始就宣告他是個class接著，分別定義attribute和method我們先看method的部分就好。這個method，其實就是我們寫過的function，只是第一個參數要幫他寫`self`，這是規定的，原因等等會談。這樣就算定義完Customer這個class了。我要realize他的話，我就直接call他，並assign到一個variable上，也就是cust1 = Customer()。此時，cust1被我們稱為instance。然後，我就可以使用他的method了。例如：那現在回過頭來看，self到底是啥那現在回過頭來看，self到底是啥我們知道class只是一個template，他需要refer data particular object。而這個self，就是這個particular object的代名詞。我們知道class只是一個template，他需要refer data particular object。而這個self，就是這個particular object的代名詞。以剛剛的例子來說，這個particular object就是我的cust1，而self就會是cust1的代名詞，所以當我們寫cust1.identify(\"Laura\")的時候，其實python在內部的翻譯是Customer.identify(cust1, \"Laura\")，也就是說，我要用Customer這個class裡的identify method，然後第一個argument是指我要refer cust1這個particular object。以剛剛的例子來說，這個particular object就是我的cust1，而self就會是cust1的代名詞，所以當我們寫cust1.identify(\"Laura\")的時候，其實python在內部的翻譯是Customer.identify(cust1, \"Laura\")，也就是說，我要用Customer這個class裡的identify method，然後第一個argument是指我要refer cust1這個particular object。nice，現在我們把attribute捕進去，並且稍微改寫method的地方，變成以下這樣：nice，現在我們把attribute捕進去，並且稍微改寫method的地方，變成以下這樣：可以看到在attribute的地方，也是用定義funciton的方式去寫，但function body是直接用assign變數的方式，把他assign到self下面。實際使用時，變成以下這樣：快速的來個類似的練習，我現在想定義Employee這個class，然後這個class的state包括name和salary(合理嘛，描述一個employee的狀態，就用名字和薪水這樣)。接著，我要realize出第一位員工，他的名字叫”Korel Rossi”，他的薪水是50000快速的來個類似的練習，我現在想定義Employee這個class，然後這個class的state包括name和salary(合理嘛，描述一個employee的狀態，就用名字和薪水這樣)。接著，我要realize出第一位員工，他的名字叫”Korel Rossi”，他的薪水是50000第一步，定義出此class，以及所屬attribute第一步，定義出此class，以及所屬attribute第二步，realize出這位員工第三步，看看這員工的attribute是不是設對了so far good. 對現在這個Employee來說，state已經有了，但behavior還沒。一個員工可能可以做哪些行為？我先幫他定義一個：被加薪！所以，現在我們來寫一個method叫get_raise(amount)，然後他的結果可以去更新原本state中的salarygood，現在多寫一個method，是幫我們算他的月薪是多少You might wondering: write methods operations performed object attributes directly? code simple, methods deal attribute values often pre-processing checks built : example, maybe company maximal allowable raise amount. prudent add clause give_raise() method checks whether raise amount within limits.","code":"class Customer_old:\n  # attribute\n    \n  # mehod: function definition within class\n  #        use 'self' as the first argument\n  def identify(self, name):\n        print(\"I am Customer \" + name)cust1 = Customer_old()\ncust1.identify(\"Laura\")\n#> I am Customer Lauraclass Customer_new:\n  # attribute\n  # set the name attribute of an object to new_name\n  def set_name(self, new_name):\n    # create an attribute by assigning a value\n    self.name = new_name # <- will create .name when set_name is called\n        \n  # mehod: function definition within class\n  #        use 'self' as the first argument\n  def identify(self):\n        print(\"I am Customer \" + self.name)cust2 = Customer_new() # <- .name doesn't exist here yet\ncust2.set_name(\"Lara de Silva\") # <- .name is created and set to \"Lara de Silva\"\nprint(cust2.name)\n#> Lara de Silva\nprint(cust2.identify())\n#> I am Customer Lara de Silva\n#> Noneclass Employee:\n  \n  # attribute\n  def set_name(self, new_name):\n    self.name = new_name\n  \n  def set_salary(self, new_salary):\n    self.salary = new_salaryemp = Employee()\nemp.set_name('Korel Rossi')\nemp.set_salary(50000)print(emp.name)\n#> Korel Rossi\nprint(emp.salary)\n#> 50000class Employee:\n  \n  # attribute\n  def set_name(self, new_name):\n    self.name = new_name\n  \n  def set_salary(self, new_salary):\n    self.salary = new_salary\n    \n  # method\n  def give_raise(self, amount):\n    self.salary = self.salary + amountemp = Employee()\nemp.set_name('Korel Rossi')\nemp.set_salary(50000)\n\nemp.give_raise(10000)\nprint(emp.salary)\n#> 60000class Employee:\n  \n  # attribute\n  def set_name(self, new_name):\n    self.name = new_name\n  \n  def set_salary(self, new_salary):\n    self.salary = new_salary\n    \n  # method\n  def give_raise(self, amount):\n    self.salary = self.salary + amount\n    \n  def monthly_salary(self):\n    return self.salary/12emp = Employee()\nemp.set_name('Korel Rossi')\nemp.set_salary(50000)\n\nemp.give_raise(22000)\nmon_sal = emp.monthly_salary()\nprint(mon_sal)\n#> 6000.0"},{"path":"oop-fundamentals.html","id":"the-__init__-constructor","chapter":"30 OOP Fundamentals","heading":"30.4 the __init__ constructor","text":"剛剛學了這幾招：\n在class內定義function，就叫method，且第一個argument要設self\nattribute也是用define function的方式做定義，只是最終都是assignment的方式，塞到self.___的變數中\n在class內，要用到attribute時，都是用self.___的方式來call\nrealize一個object時，先call class name，再用attribute的function來做設定(例如設定Employee的name和salary)\n剛剛學了這幾招：在class內定義function，就叫method，且第一個argument要設selfattribute也是用define function的方式做定義，只是最終都是assignment的方式，塞到self.___的變數中在class內，要用到attribute時，都是用self.___的方式來callrealize一個object時，先call class name，再用attribute的function來做設定(例如設定Employee的name和salary)關於最後一點，其實有更好的作法，就是我們幹麻先realize完，又再用attribute的function去設定？何不在realize一個object的時候，就直接把這些attribute設定進去呢？這其實是可以的，就是使用__init__這個constructor，看個例子就懂了：關於最後一點，其實有更好的作法，就是我們幹麻先realize完，又再用attribute的function去設定？何不在realize一個object的時候，就直接把這些attribute設定進去呢？這其實是可以的，就是使用__init__這個constructor，看個例子就懂了：現在，只要我用這個class去create一個object時，他就會自動啟動__init__()這個function，而這個function要用的argument，也是在你create object時就要傳入了：nice! 這其實才是最常用的作法。之前的作法，被稱為”Attributes methods”，也就是我在class裡面，用定義method的方式(也就是定義function的方式)，來定義一個設定attribute的function。然後create object後，再去call這些function來一一設定attribute。而現在的方式，叫做”Attribute constructor”，就是我直接寫一個initialize的function在最前面：__init__(self, all_attribute_list_here)，然後逼迫我們在create object的時候，就要把這些設定值填進去，那你其實就是在一一create出各個獨特的object。這種作法更可讀(在class內，找init，就可以一次全覽所有attribute), 更快速(create object時同步搞定), 也更容維護。","code":"class Customer:\n  # attribute\n  def __init__(self, name):\n    self.name = name # <- Create the .name attribute and set it to name parameter\n    print(\"The __init__ method was called\")cust_lara = Customer(name = \"Lara de Silvia\")\n#> The __init__ method was called\nprint(cust_lara.name)\n#> Lara de Silvia"},{"path":"oop-fundamentals.html","id":"寫class的sop","chapter":"30 OOP Fundamentals","heading":"30.5 寫Class的SOP","text":"最後，講一下寫class的best practices:\nInitialize attributes __init__()\n命名時，class的命名都用CamelCase，就是單字在組合時，都是字首大寫，例如class EmployeeWistron:，class內定義function時，function name都是全小寫用底線串，例如def employee_wistron():\nKeep self self。在class內定義function時，第一個argument都是留給self用的，如果你不寫self，要寫別的，例如kitty，也是可以work，你在class內要call這些attribute時，就記得用kitty.___就ok，但這樣別人看你的code時會很容易亂，所以還是建議，你就乖乖寫self就好。\n最後，就像寫function一樣，寫class的時候，第一行也都會寫docstrings(功能註解)，幫助自己也幫助別人了解這個class的主要功能在幹麻\n最後，講一下寫class的best practices:Initialize attributes __init__()命名時，class的命名都用CamelCase，就是單字在組合時，都是字首大寫，例如class EmployeeWistron:，class內定義function時，function name都是全小寫用底線串，例如def employee_wistron():Keep self self。在class內定義function時，第一個argument都是留給self用的，如果你不寫self，要寫別的，例如kitty，也是可以work，你在class內要call這些attribute時，就記得用kitty.___就ok，但這樣別人看你的code時會很容易亂，所以還是建議，你就乖乖寫self就好。最後，就像寫function一樣，寫class的時候，第一行也都會寫docstrings(功能註解)，幫助自己也幫助別人了解這個class的主要功能在幹麻接下來，我們就用學到的這些技巧，來重寫Employee的class。我們要用__init__()來設定name和salary這兩個attribute，而且，因為__init__就是寫function，所以，我們也可以給salary一個default值，例如GG的45000：接下來，我們就用學到的這些技巧，來重寫Employee的class。我們要用__init__()來設定name和salary這兩個attribute，而且，因為__init__就是寫function，所以，我們也可以給salary一個default值，例如GG的45000：nice，這邊又提醒，__init__()很適合拿來做data preprocessing。例如，這邊的薪水一定要>=0，所以，如果在create object的時候，輸入負的薪水，我想要print出你key錯了，薪水要正的，並主動先幫他把薪水設成0最後，如果我想使用其他package的function時怎麼辦？我要import在class外面還是裡面？答案是：外面！！以下舉個例子，我想要多加一個attribute叫hire_date，他可以在我建立這個employee的object時，直接assign當天日期進去。所以，我需要用到datetime這個package裡面的function，叫today()。請見以下範例：","code":"class Employee:\n    # Create __init__() method\n    def __init__(self, name, salary=45000):\n        # Create the name and salary attributes\n        self.name = name\n        self.salary = salary\n    \n    # From the previous lesson\n    def give_raise(self, amount):\n        self.salary += amount\n\n    def monthly_salary(self):\n        return self.salary/12emp = Employee(\"Korel Rossi\")\nprint(emp.name)\n#> Korel Rossi\nprint(emp.salary)\n#> 45000class Employee:\n  \n    def __init__(self, name, salary=0):\n        self.name = name\n        # Modify code below to check if salary is positive\n        if salary>=0:\n            self.salary = salary\n        else:\n            self.salary = 0\n            print(\"Invalid salary\")\n   \n   # From the previous lesson\n    def give_raise(self, amount):\n        self.salary += amount\n\n    def monthly_salary(self):\n        return self.salary/12emp = Employee(\"Korel Rossi\", -1000)\n#> Invalid salary\nprint(emp.name)\n#> Korel Rossi\nprint(emp.salary)\n#> 0# Import datetime from datetime\nfrom datetime import datetime\n\nclass Employee:\n    \n    def __init__(self, name, salary=0):\n        self.name = name\n        if salary > 0:\n          self.salary = salary\n        else:\n          self.salary = 0\n          print(\"Invalid salary!\")\n          \n        # Add the hire_date attribute and set it to today's date\n        self.hire_date = datetime.today()\n        \n   # From the previous lesson\n    def give_raise(self, amount):\n        self.salary += amount\n\n    def monthly_salary(self):\n        return self.salary/12\n      \nemp = Employee(\"Korel Rossi\", -1000)\n#> Invalid salary!\nprint(emp.name)\n#> Korel Rossi\nprint(emp.salary)\n#> 0\nprint(emp.hire_date)\n#> 2022-01-08 17:45:51.802810"},{"path":"class-level-vs-instance-level.html","id":"class-level-vs-instance-level","chapter":"31 Class-level vs Instance-level","heading":"31 Class-level vs Instance-level","text":"","code":""},{"path":"class-level-vs-instance-level.html","id":"instance-level-attribute-vs-class-level-attribute","chapter":"31 Class-level vs Instance-level","heading":"31.1 Instance-level attribute vs Class-level attribute","text":"","code":""},{"path":"class-level-vs-instance-level.html","id":"簡介實例屬性與類屬性","chapter":"31 Class-level vs Instance-level","heading":"31.1.1 簡介實例屬性與類屬性","text":"首先我們看一下這個例子：在這個例子中，self.name叫做instance-level attribute(實例屬性)，因為他有一個instance的代名詞self放在前面，我們在調用這個attribute時，都是先寫instance name，才寫此屬性，例如：而count叫做class-level attribute，他前面沒有擺self，所以他是屬於Class下面的屬性，而不是屬於self下面的屬性。在調用這個attribute時，要先寫class name，才寫此屬性，例如：","code":"class Student:\n  \n  count = 0 # class-level attribute\n  \n  def __init__(self, name):\n    self.name = name # instance-level attributehank = Student(name = \"hank\")\nprint(hank.name)\n#> hankprint(Student.count)\n#> 0"},{"path":"class-level-vs-instance-level.html","id":"實例屬性可以繼承類屬性","chapter":"31 Class-level vs Instance-level","heading":"31.1.2 實例屬性可以繼承類屬性","text":"那由於階層上是class為第一層，instance為第二層，所以instance會繼承class的屬性，但class不會有instance的屬性：","code":"# class下，沒有name這個屬性，要instance下才會有\nprint(Student.name)\n# instance會繼承class的屬性，所以還是看得到count\n#> Error in py_call_impl(callable, dots$args, dots$keywords): AttributeError: type object 'Student' has no attribute 'name'\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>\nprint(hank.count)\n#> 0"},{"path":"class-level-vs-instance-level.html","id":"實例屬性與類屬性的修改","chapter":"31 Class-level vs Instance-level","heading":"31.1.3 實例屬性與類屬性的修改","text":"剛剛講到，instance會繼承class的attribute:Student.count是在講Student這個抽象的類別，他所屬的count。我們覺得，不管是哪個學生(hank aaron sunny…)，只要是學生，一開始的count應該都是0所以，我們realize一個instance叫做hank時，hank.count就繼承了這個student的class給他的count，現在hank.count已經是hank專屬的count了。那可以想像，如果我去修改instance中的count(e.g. 這邊的hank.count)，那就只是修改instance中的count，不會影響到class的count:我也可以想像，如果我去改class中的count，並不會影響到instance中的count。因為改class中的count，等於只是改模板，他只會影響到”之後”我創建出來的instance而已：","code":"print(Student.count)\n#> 0\nprint(hank.count)\n#> 0print(Student.count)\n#> 0\nprint(hank.count)\n#> 0\nhank.count = 1\n\nprint(Student.count)\n#> 0\nprint(hank.count)\n#> 1print(Student.count)\n#> 0\nprint(hank.count)\n#> 1\nStudent.count = 100\n\nprint(Student.count)\n#> 100\nprint(hank.count)\n#> 1\nsunny = Student(name = 'sunny')\nprint(sunny.count)\n#> 100"},{"path":"class-level-vs-instance-level.html","id":"類屬性用在哪","chapter":"31 Class-level vs Instance-level","heading":"31.1.4 類屬性用在哪","text":"對於instance-level attribute(實例屬性)我們蠻熟了，他主要就是給method做使用。那class-level attribute是用在哪呢？這邊舉兩個實例：","code":""},{"path":"class-level-vs-instance-level.html","id":"統計這個class被用過幾次","chapter":"31 Class-level vs Instance-level","heading":"31.1.4.1 統計這個class被用過幾次","text":"有時候我們會想統計一下，某個class被實體化過幾次，那就可以像下面這樣寫：從上面這段code，可以看到我們把Student.count = Student.count + 1放在__init__的下面。那每次在實體化一個instance時，count數就會增加：","code":"class Student:\n  count = 0\n  def __init__(self, name):\n    Student.count = Student.count + 1\n    self.name = names1 = Student(\"A\")\ns2 = Student(\"B\")\ns3 = Student(\"C\")\n\nprint(Student.count)\n#> 3"},{"path":"class-level-vs-instance-level.html","id":"跨instance都應該一樣的特徵","chapter":"31 Class-level vs Instance-level","heading":"31.1.4.2 跨instance都應該一樣的特徵","text":"舉例來說，今天我要做一個Employee的class，裡面有個attribute叫MIN_SALARY。那這個最低薪資，其實是法律規範的22k，只要你是員工，不管你叫阿貓還是阿狗，最低薪資都應該一樣。那這種attribute我們就會寫在class下面。這樣做的一個優點是省力，另一個優點是可以幫我們做卡控: 以下舉個例子，當我們實體化一個employee時，要輸入該員工的name與salary。但只要這個salary小於MIN_SALARY，我就要用MIN_SALARY做取代：來做個實驗吧：","code":"class Employee:\n  MIN_SALARY = 22000\n  def __init__(self, name, salary):\n    self.name = name\n    if salary < Employee.MIN_SALARY:\n      print(\"Please respect people. The salary you give is lower than 22K !!\")\n      self.salary = Employee.MIN_SALARY\n    else:\n      self.salary = salarysunny = Employee(name = \"sunny\", salary = 10000)\n#> Please respect people. The salary you give is lower than 22K !!\nprint(sunny.salary)\n#> 22000\nhank = Employee(name = \"sunny\", salary = 60000)\nprint(hank.salary)\n#> 60000"},{"path":"class-level-vs-instance-level.html","id":"instance-level-method-vs-class-level-method","chapter":"31 Class-level vs Instance-level","heading":"31.2 Instance-level method vs Class-level method","text":"","code":""},{"path":"class-level-vs-instance-level.html","id":"簡介類方法和實例方法","chapter":"31 Class-level vs Instance-level","heading":"31.2.1 簡介類方法和實例方法","text":"首先我們複習一下實例方法(instance-level method)裡面的sayhi(self, v1)就是一實例方法，因為他需要傳入self這個參數，好讓他在method裡面可以呼叫self.name, self.age這兩個instance-level attribute而sayhi2(self, v1)同樣是個實例方法，這邊就顯示我們要呼叫實例方法時，也得用self，如同這邊用到self.sayhi這個method那舉一反三，class-level method，傳入的參數就該從self改成class? 答案很接近了，用的參數名稱叫cls而不是class。而且，還要在定義method的前面，加個decorator: @classmethod看例子：那定義好這個類方法後，我們從外部就不需要先realize一個instance，就可以用這個方法了:而且，如同實例屬性會繼承類屬性一樣，實例方法也會繼承類方法，所以當我realize一個instance後，我還是可以調用這個method:那最後講一下，instance-level method時，你傳入self參數，是為了用self.name, self.age這些instance-level attribute，或是用self.sayhi()這種instance-level method。那class-level method時，你傳入cls參數，是為了調用cls.XXX的class-level attribute嗎？顯然不是，因為class-level attribute的調用，是用{class名稱}.{attribute名稱}。所以，cls參數要調用的，是其他class method!!例如下例：從這個例子可以看到，我的test2，調用了cls.test1這個class-level method。來看看結果對不對：最後，我們無法在類方法中，去調用實例方法。例如我現在寫個test3，裡面想要調用self.sayhi實驗一下：如同預期，報error了，而且error message也很合理：沒找到self拉！啊廢話，你這是class-level method，給的參數是cls又不是self，當然無法去吃self.sayhi()這個instance-level method而且，就算你實體化這個class，還是不能調用self.sayhi()，因為你的self從頭到尾都沒被當作參數丟入test3裡面：","code":"class People:\n  def __init__(self, name, age):\n    self.name = name\n    self.age = age\n  \n  def sayhi(self, v1):\n    return(f\"Hi, my name is {self.name}, and I'm {self.age} year's old. {v1} is here\")\n  \n  def sayhi2(self, v1):\n    res = self.sayhi(v1)\n    return(res)class People:\n  def __init__(self, name, age):\n    self.name = name\n    self.age = age\n  \n  def sayhi(self, v1):\n    return(f\"Hi, my name is {self.name}, and I'm {self.age} year's old. {v1} is here\")\n  \n  def sayhi2(self, v1):\n    res = self.sayhi(v1)\n    return(res)\n  \n  @classmethod\n  def test1(cls):\n    return(\"這是一個類方法\")print(People.test1())\n#> 這是一個類方法p1 = People(name = \"hank\", age = 28)\nprint(p1.test1())\n#> 這是一個類方法class People:\n  def __init__(self, name, age):\n    self.name = name\n    self.age = age\n  \n  def sayhi(self, v1):\n    return(f\"Hi, my name is {self.name}, and I'm {self.age} year's old. {v1} is here\")\n  \n  def sayhi2(self, v1):\n    res = self.sayhi(v1)\n    return(res)\n  \n  @classmethod\n  def test1(cls):\n    return(\"這是一個類方法\")\n  \n  @classmethod\n  def test2(cls):\n    res = cls.test1()\n    return(res)\n  print(People.test2())\n#> 這是一個類方法class People:\n  def __init__(self, name, age):\n    self.name = name\n    self.age = age\n  \n  def sayhi(self, v1):\n    return(f\"Hi, my name is {self.name}, and I'm {self.age} year's old. {v1} is here\")\n  \n  def sayhi2(self, v1):\n    res = self.sayhi(v1)\n    return(res)\n  \n  @classmethod\n  def test1(cls):\n    return(\"這是一個類方法\")\n  \n  @classmethod\n  def test2(cls):\n    res = cls.test1()\n    return(res)\n  \n  @classmethod\n  def test3(cls, v1):\n    res = self.sayhi(v1)\n    return(res)print(People.test3(v1 = \"hahaha\"))\n#> Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'self' is not defined\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>\n#>   File \"<string>\", line 24, in test3p2 = People(name = \"hank\", age = 28)\np2.test3(v1 = \"hahaha\")\n#> Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'self' is not defined\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>\n#>   File \"<string>\", line 24, in test3"},{"path":"class-level-vs-instance-level.html","id":"實例屬性的使用時機","chapter":"31 Class-level vs Instance-level","heading":"31.2.2 實例屬性的使用時機","text":"那到底class method可以拿來幹麻？其實最常是拿來作為initialize instance的另一種方式，例如，我的class如果本來要initialize一個instance時，要輸入year, month, day這三個參數，但我現在希望提供另一種initialize的方式，是直接給字串(e.g. “2020-10-20”)就好，我該怎麼做？只有一個__init__可以用，又不能寫兩個，這時候，就會用class method直接看例子。今天我想寫一個class叫BetterDate，有year, month, day三個attribute。那我現在想寫一個class method，只要給字串，我一樣initialize instance給你：注意到最後的cls(year, month, day)，他的意思就是會把這三個參數傳回__init__來initialize instance的意思。所以，現在試試看結果：","code":"class BetterDate:    \n    # Constructor\n    def __init__(self, year, month, day):\n      # Recall that Python allows multiple variable assignments in one line\n      self.year, self.month, self.day = year, month, day\n    \n    # Define a class method from_str\n    @classmethod\n    def from_str(cls, datestr):\n        # Split the string at \"-\" and convert each part to integer\n        parts = datestr.split(\"-\")\n        year, month, day = int(parts[0]), int(parts[1]), int(parts[2])\n        # Return the class instance\n        return cls(year, month, day)bd = BetterDate.from_str('2020-04-30')   \nprint(bd.year)\n#> 2020\nprint(bd.month)\n#> 4\nprint(bd.day)\n#> 30"},{"path":"class-level-vs-instance-level.html","id":"小結","chapter":"31 Class-level vs Instance-level","heading":"31.3 小結","text":"剛剛講了類屬性和實例屬性，我們學到類屬性在實體化之前就可以調用，調用的方式是{class名稱}.{attribute名稱}類屬性當然也可以在class的內部去調用它，一樣是用{class名稱}.{attribute名稱}實例屬性，在內部的調用是用self.{attribute名稱}，因為在內部時還不知道實體化後的名稱，所以都用self來當代名詞實例屬性，在外部的調用是用{instance名稱}.{attribute名稱}類方法和實例方法概念也都一樣：\n實例方法：內部的調用是用self.{method名稱}(參數)，外部的調用是{instance名稱}.{method名稱}(參數)\n類方法：內部的調用適用cls.{method名稱}(參數)，外部調用是{class名稱}.{method名稱}(參數)\n實例方法：內部的調用是用self.{method名稱}(參數)，外部的調用是{instance名稱}.{method名稱}(參數)類方法：內部的調用適用cls.{method名稱}(參數)，外部調用是{class名稱}.{method名稱}(參數)","code":""},{"path":"attribute-protection.html","id":"attribute-protection","chapter":"32 Attribute Protection","heading":"32 Attribute Protection","text":"這節要來講如何保護我們的attribute，更精確的說，是保護instance-level attribute要做到實例屬性的保護，由淺至深可分為以下四種：\n[放任型] 開發者啥都不做，user想做啥都可以。\n[信任型] 我希望initialize後，提醒你這些屬性小心使用，盡量不要修改\n[中庸型] 我希望initialize後，你要改屬性，要先經過我的審核機制才能改： 用decorator(@property, setter)\n[嚴父型] 我希望initialize後，你不准修改和查詢屬性：那就用私有屬性的做法，我也不給你set和get method。\n[放任型] 開發者啥都不做，user想做啥都可以。[信任型] 我希望initialize後，提醒你這些屬性小心使用，盡量不要修改[中庸型] 我希望initialize後，你要改屬性，要先經過我的審核機制才能改： 用decorator(@property, setter)[嚴父型] 我希望initialize後，你不准修改和查詢屬性：那就用私有屬性的做法，我也不給你set和get method。","code":""},{"path":"attribute-protection.html","id":"naming-convention","chapter":"32 Attribute Protection","heading":"32.1 Naming Convention","text":"在python中，instance-level attribute的命名是有慣例的(naming convention)：\n一般的變數型態，表不保護，user想做啥都可以。這被我歸類在[放任型]\n單底線開頭，表受保護屬性，用來提醒user，不要調用和修改。但只有提醒功能，user還是可用可改。這被我歸類在[信任型]\n雙底線開頭，表私有屬性(private variable)，這種命名規則會告訴系統，這個attribute只給class在內部使用，不讓user從外部去找到和使用這個屬性。這被我歸類在[嚴父型]。那如果再搭配可用來修改的decorator(e.g. @property, .setter)，就被我歸類為[中庸型]\n一般的變數型態，表不保護，user想做啥都可以。這被我歸類在[放任型]單底線開頭，表受保護屬性，用來提醒user，不要調用和修改。但只有提醒功能，user還是可用可改。這被我歸類在[信任型]雙底線開頭，表私有屬性(private variable)，這種命名規則會告訴系統，這個attribute只給class在內部使用，不讓user從外部去找到和使用這個屬性。這被我歸類在[嚴父型]。那如果再搭配可用來修改的decorator(e.g. @property, .setter)，就被我歸類為[中庸型]","code":""},{"path":"attribute-protection.html","id":"放任型-不保護","chapter":"32 Attribute Protection","heading":"32.2 [放任型] 不保護","text":"","code":""},{"path":"attribute-protection.html","id":"信任型-用單底線提醒","chapter":"32 Attribute Protection","heading":"32.3 [信任型] 用單底線提醒","text":"以下我們舉個例子，此例我要在__init__()裡面，加上一個受保護的屬性，叫做._protect_var這樣的做法，用意只是提醒user，這個屬性你不要用，也不要改。但他只有提醒功能，如果user要用要改，都還是可以做到：","code":"class People:\n  def __init__(self, name, age):\n    self.name = name\n    self.age = age\n    # 受保護屬性，用單底線開頭，提醒user不要用不要改\n    self._protect_var = 10someone = People(name = \"hank\", age = \"28\")\n\n# user還是可以調用這個屬性\nprint(someone._protect_var)\n# user還是可以修改這個屬性\n#> 10\nsomeone._protect_var = 20\nprint(someone._protect_var)\n#> 20"},{"path":"attribute-protection.html","id":"嚴父型-用雙底線不給動","chapter":"32 Attribute Protection","heading":"32.4 [嚴父型] 用雙底線不給動","text":"接下來我們舉雙底線開頭的例子，下例中我們新增一個.__private_var的私有屬性：這樣做以後，如果user從外部要調用這個屬性，會得到error但如果我們寫個method來調用這個屬性就ok，因為private variable就是專for class內部使用的那為什麼我們不能用someone.__private_var這個指令？我們可以用dir()來看一下有哪些attribute/method可以用：從上面可以看到，我們可以用的屬性和method中，有看到我定義的保護屬性_protect_var，但根本沒出現我定義的私有屬性__priate_var，所以，當你用someone.__private_var，python才會跟你說，沒有這個attribute或method但，你可以看到第一個attribute的名稱叫：_People__private_var，表示，python是自動幫你把private variabe和class名稱給黏在一起，變成一個新的attribute供user調用，所以其實user還是可以藉由這個方法，取得和修改private variable所以講白了，python的理念，還是給user很大的自由度。即使是最嚴格的類型，user還是可以找到方法去修改。最後，來釐清個觀念：user不能調用someone.__private_var，但卻可以藉由這種方式修改(someone.__private_var = xxx)!?看起來好像做到修改了，但其實，這樣做是在”新增”一個attribute，而不是”修改”我們舊有的私有屬性，我們看系統內部在讀self.__private是讀到誰就知道了：我們發現，系統讀到的還是舊的.__private_var(40)，而不是剛剛assign的這筆(30)因為someone.__private_var = 40的意思，其實是create了一個新attribute給這個instance，只是他的名稱剛好也叫.__private_var而已。但系統在讀self.__private_var時，還是讀一開始設好的那個.__private_var也因為剛剛這種直接assign attribute的做法，讓我們現在可以直接調用這筆新增的.__private_var了","code":"class People:\n  def __init__(self, name, age):\n    self.name = name\n    self.age = age\n    self._protect_var = 10\n    # 私有屬性用雙底線開頭，只能在class內部使用\n    self.__private_var = 10\n  \n  def show_private(self):\n    return(self.__private_var)someone = People(name = \"hank\", age = \"28\")\nprint(someone.__private_var)\n#> Error in py_call_impl(callable, dots$args, dots$keywords): AttributeError: 'People' object has no attribute '__private_var'\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>\nprint(someone.show_private())\n#> 10print(dir(someone))\n#> ['_People__private_var', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_protect_var', 'age', 'name', 'show_private']print(someone._People__private_var)\n#> 10\nsomeone._People__private_var = 30\nprint(someone._People__private_var)\n#> 30print(someone.__private_var) # 會報error\n#> Error in py_call_impl(callable, dots$args, dots$keywords): AttributeError: 'People' object has no attribute '__private_var'\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>\nsomeone.__private_var = 40 # 不會報errorprint(someone.show_private())\n#> 30someone.__private_var\n#> 40"},{"path":"attribute-protection.html","id":"中庸型-雙底線-property-.setter","chapter":"32 Attribute Protection","heading":"32.5 [中庸型] 雙底線 + @property + .setter","text":"有時候，我們設private variable，並不是不讓別人修改，而是希望別人修改的時候，能符合我們設定好的遊戲規則如果要做到這個，我們就會用以下的寫法來做首先介紹old-school的做法(加入get和set的method)，因為比較好理解到底在做什麼。但這種寫法沒人再寫了，所以我們還是要學標準版的寫法：加decorator的寫法","code":""},{"path":"attribute-protection.html","id":"old-school-作法","chapter":"32 Attribute Protection","heading":"32.5.1 old-school 作法","text":"假設我們要寫一個People的class，在initialize的時候，會用到name和age兩個attribute，而我們希望user initialize後，就盡可能不要改他。那我們會寫成這樣：可以看到，name和age現在都無法調用了那如果，我可以允許user做修改，但必須符合我的遊戲規則，那我可以寫個get和set method來卡空：有了set這道防線後，user就不能亂設attribute了：由此例可以發現，我們新增兩個方法讓user去調用(.e. get_name)和修改(.e. set_name)藉由這種不便利性，來減少user去使用和修改這些private variable的頻率，也藉由寫method，加入一些卡空機制進去","code":"class People:\n  def __init__(self, name, age):\n    self.__name = name\n    self.__age = age\n\nhank = People(name = \"hank\", age = 28)\nprint(hank.name)\n#> Error in py_call_impl(callable, dots$args, dots$keywords): AttributeError: 'People' object has no attribute 'name'\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>\nprint(hank.age)\n#> Error in py_call_impl(callable, dots$args, dots$keywords): AttributeError: 'People' object has no attribute 'age'\n#> \n#> Detailed traceback:\n#>   File \"<string>\", line 1, in <module>class People:\n  def __init__(self, name, age):\n    self.__name = name\n    self.__age = age\n  \n  def get_name(self):\n    return self.__name  \n  def set_name(self, new_name):\n    if type(new_name) is str:\n      self.__name = new_name\n    else:\n      print(\"new_name should be the type of string.\")\n  \n  def get_age(self):\n    return self.__age  \n  def set_age(self, new_age):\n    if type(new_age) is int:\n      self.__age = new_age\n    else:\n      print(\"new_age should be the type of integer.\")hank = People(name = \"hank\", age = \"28\")\n\nprint(hank.get_name())\n#> hank\nhank.set_name(12345)\n#> new_name should be the type of string.\nprint(hank.get_name())\n#> hank\nhank.set_name(\"hank lee\")\nprint(hank.get_name())\n#> hank lee"},{"path":"attribute-protection.html","id":"正規作法","chapter":"32 Attribute Protection","heading":"32.5.2 正規作法","text":"那正規作法，其實是把get_name()和get_age()這兩個method，換成@property的寫法，見下例：由這種寫法可以發現，我們加@property這個decorator在method的上面，用來宣告說我要使用property的功能。然後底下用來取代get_name method的東西，要直接用private variable的名稱，所以會是name或age那這種寫法的好處是，user現在可以用熟悉的{instance名稱}.{attribute名稱}來調用這些private variable，不用再寫get_name()或get_age()從此例也可看出，我們剛剛寫的name和age兩個method，再加上@property後，他就不再是method了(你看我是用hank.name來取得name，而不是用hank.name()來取得name，但我在class中，name()明明是以method的方式存在的，我還有return勒！)從此例也可看出，我們剛剛寫的name和age兩個method，再加上@property後，他就不再是method了(你看我是用hank.name來取得name，而不是用hank.name()來取得name，但我在class中，name()明明是以method的方式存在的，我還有return勒！)再來，我們要改造set_name()這個method，也是用decorator(xx.setter)，見下例:再來，我們要改造set_name()這個method，也是用decorator(xx.setter)，見下例:可以看到，差別就是加上name.setter和age.setter，然後method name維持原來的private variable name來試試看能不能work可以發現，可以work而且，藉由decorator，我們又把method變成attribute了。注意到現在是寫hank.name = 12345，就會跑我定義的method並檢查合法性，而不是寫hank.name(12345)。所以，這樣做，可以讓user用起來更直覺的同時，又兼顧到資料的正確性","code":"class People:\n  def __init__(self, name, age):\n    self.__name = name\n    self.__age = age\n  \n  # def get_name(self):\n  #   return self.__name\n  @property\n  def name(self):\n    return self.__name\n  \n  # def get_age(self):\n  #   return self.__age  \n  @property\n  def age(self):\n    return self.__agehank = People(name = \"hank\", age = 28)\nprint(hank.name)\n#> hank\nprint(hank.age)\n#> 28class People:\n  def __init__(self, name, age):\n    self.__name = name\n    self.__age = age\n  \n  @property\n  def name(self):\n    return self.__name\n  \n  # def set_name(self, new_name):\n  #   if type(new_name) is str:\n  #     self.__name = new_name\n  #   else:\n  #     print(\"new_name should be the type of string.\")\n  @name.setter\n  def name(self, new_name):\n    if type(new_name) is str:\n      self.__name = new_name\n    else:\n      print(\"new_name should be the type of string.\")\n  \n  \n  @property\n  def age(self):\n    return self.__age\n  \n  # def set_age(self, new_age):\n  #   if type(new_age) is int:\n  #     self.__age = new_age\n  #   else:\n  #     print(\"new_age should be the type of integer.\")\n  @age.setter\n  def age(self, new_age):\n    if type(new_age) is int:\n      self.__age = new_age\n    else:\n      print(\"new_age should be the type of integer.\")\n  \n  hank = People(name = \"hank\", age = \"28\")\n\nprint(hank.name)\n#> hank\nhank.name = 12345\n#> new_name should be the type of string.\nprint(hank.name)\n#> hank\nhank.name = \"hank lee\"\nprint(hank.name)\n#> hank lee"},{"path":"isinstance-equality-與-string-representation.html","id":"isinstance-equality-與-string-representation","chapter":"33 isinstance, equality, 與 string representation","heading":"33 isinstance, equality, 與 string representation","text":"","code":""},{"path":"isinstance-equality-與-string-representation.html","id":"type-與-isinstance","chapter":"33 isinstance, equality, 與 string representation","heading":"33.1 type 與 isinstance","text":"之前已經用過很多次type()，例如下例：可以看到，顯示出來的type是list而且，我們終於看懂前面的class是什麼意思了：在python中萬物都是object，所以你去問一個object的type，就是在問他的class是誰拉！！那現在多教一個指令，叫isinstance()，他的用法如下：所以蠻好懂的，第一個argument就是放你要驗證的object(e.g. 此例的a)，第二個argument就是去看看他是不是這個class的instance再來個練習，我自己寫的class，用type會長怎樣：cool，他的type就是A。那用用看isinstance","code":"a = [1,2]\nprint(type(a))\n#> <class 'list'>a = [1,2]\nprint(isinstance(a, list))\n#> Trueclass A:\n  pass\n\na = A()\nprint(type(a))\n#> <class '__main__.A'>print(isinstance(a, A))\n#> True"},{"path":"isinstance-equality-與-string-representation.html","id":"繼承與isinstance","chapter":"33 isinstance, equality, 與 string representation","heading":"33.1.1 繼承與isinstance","text":"重點來了，如果今天有繼承的話，那子類的instance，也會是父類的instance可以明顯看到，雖然b的type是B，但在判斷instance時，他仍是A的instance!!因為我們要判斷b是不是A的instance時，就是看A的instance該有的attribute和method他是不是都有。而因為B繼承A，所以A有的，B都有，B做出來的instance全都繼承過去了，所以他仍是A的instance但a就不會是B的instance了，道理很簡單，B的instance該有的attribute和method，a未必都有(因為B就是繼承A後，要加了他獨有的attribute和methods)","code":"class A:\n  pass\n\nclass B(A):\n  pass\n\na = A()\nb = B()\n\nprint(type(b))\n#> <class '__main__.B'>\nprint(isinstance(b, B))\n#> True\nprint(isinstance(b, A))\n#> True\nprint(type(a))\n#> <class '__main__.A'>\nprint(isinstance(a, A))\n#> True\nprint(isinstance(a, B))\n#> False"},{"path":"isinstance-equality-與-string-representation.html","id":"eq__-object-equality","chapter":"33 isinstance, equality, 與 string representation","heading":"33.2 __eq__ (object equality)","text":"用我們現在學到的方法來寫class的話，會碰到以下問題：兩個instance的attribute完全相同，但比較結果卻說不同：為什麼會這樣？因為在比相不相同時，是比記憶體位置一不一樣：很明顯的看到，兩個記憶體位置不同，所以才說不相等聽起來很合理，但很難用啊，兩個object的attribute相同，我就希望他們比較的結果是一樣啊。其實python內建的class，就有做這種處理了，比如說：可以看到，兩個object的記憶體位置不同，但比較結果是True，這怎麼辦到的？這其實就是要多寫一個”equality constructor”。對比於”initial constructor”是__init__(self, ...)，這個equality constructor是寫成__eq__(self, )，其中”self”, “”就是固定的參數，不要去換寫法如下：這邊就看到，我們得條件是，兩個比較的instance的name和id若完全相同，我就認定他是equal的。裡面的self和other就各指稱兩個instance，最後的return結果一定要是True/Fale。這邊就看到，我們得條件是，兩個比較的instance的name和id若完全相同，我就認定他是equal的。裡面的self和other就各指稱兩個instance，最後的return結果一定要是True/Fale。除了equality operator外，其實還有其他的comparison，比如：\nOperator\nMethod\n==\n`__eq__`: equal\n!=\n`__ne__`: equal\n>=\n`__ge__`: greater equal \n<=\n`__le__`: less equal \n>\n`__gt__`: greater \n<\n`__lt__`: less \n除了equality operator外，其實還有其他的comparison，比如：接下來講兩個細節：\n不同class的instance，能不能比啊？會錯亂嗎？\nParent class的instance和Child class的instance在比時，用誰的equality constructor？\n接下來講兩個細節：不同class的instance，能不能比啊？會錯亂嗎？Parent class的instance和Child class的instance在比時，用誰的equality constructor？先講答案，第一點是，只要equality constructor一樣，就可以比，所以會造錯亂。解決方式是，再多比一個type(self)==type()就好先講答案，第一點是，只要equality constructor一樣，就可以比，所以會造錯亂。解決方式是，再多比一個type(self)==type()就好第二點的答案是，always用child class的equality constructor第二點的答案是，always用child class的equality constructor先來看第一點的範例吧先來看第一點的範例吧我建了兩個class，第一個是客戶的class，他的attribute是number，指的是他的編號；第二個是電話號碼的class，他的attribute也是number，但指的是電話號碼。結果這兩個不一樣的東西，就剛好都有number，就被比成一樣了。所以實務上在比較時，equality constructor，都會再加上type的條件：接著就講到parent class和child class的比較。always用child class的equality constructor：","code":"class Customer:\n  def __init__(self, name, id):\n    self.name = name\n    self.id = id\n\ncust1 = Customer(\"Hank\", 19002329)\ncust2 = Customer(\"Hank\", 19002329)\n\ncust1 == cust2\n#> Falseprint(cust1)\n#> <__main__.Customer object at 0x10f0e3220>\nprint(cust2)\n#> <__main__.Customer object at 0x10f0e3400>import numpy as np\na = np.array([1])\nb = np.array([1])\nid(a)\n#> 4547578096\nid(b)\n#> 4547578336\nprint(a == b)\n#> [ True]class Customer:\n  def __init__(self, name, id):\n    self.name = name\n    self.id = id\n  def __eq__(self, other):\n    print(\"__eq__() is called\")\n    return (self.name == other.name) & (self.id == other.id)\n\ncust1 = Customer(\"Hank\", 19002329)\ncust2 = Customer(\"Hank\", 19002329)\n\ncust1 == cust2\n#> __eq__() is called\n#> Trueclass Buyer:\n  def __init__(self, number):\n    self.number = number\n    \n  def __eq__(self, other):\n    return self.number == other.number\n\nclass Phone:\n  def __init__(self, number):\n    self.number = number\n    \n  def __eq__(self, other):\n    return self.number == other.number\n    \nbuyer1 = Buyer(19002329)\nphone_number = Phone(19002329)\n\nbuyer1 == phone_number\n#> Truetype(buyer1)\n#> <class '__main__.Buyer'>\ntype(phone_number)\n#> <class '__main__.Phone'>class Buyer:\n  def __init__(self, number):\n    self.number = number\n    \n  def __eq__(self, other):\n    return (self.number == other.number) & (type(self)==type(other))\n\nclass Phone:\n  def __init__(self, number):\n    self.number = number\n    \n  def __eq__(self, other):\n    return (self.number == other.number) & (type(self)==type(other))\n    \nbuyer1 = Buyer(19002329)\nphone_number = Phone(19002329)\n\nbuyer1 == phone_number\n#> Falseclass Parent:\n    def __eq__(self, other):\n        print(\"Parent's __eq__() called\")\n        return True\n\nclass Child(Parent):\n    def __eq__(self, other):\n        print(\"Child's __eq__() called\")\n        return True\n\np = Parent()\nc = Child()\n\np == c \n#> Child's __eq__() called\n#> True"},{"path":"isinstance-equality-與-string-representation.html","id":"str__與__repr__","chapter":"33 isinstance, equality, 與 string representation","heading":"33.3 __str__與__repr__","text":"接下來的議題，是有關object的printing我們目前對class的寫法，會讓我們每次去print一個instance的時候，他都只給我們記憶體位置，例如：damn…這麼簡單的class，我當然希望他直接print 22K給我看啊Python其他內建的class，都有做這種處理，不信你看numpy的instance:為什麼勒？因為python有兩種constructor，一個叫__str__，一個叫__repr__\n定義在__str__內的東西，是要給end user看的，是informal的資訊，可以藉由print()和str()看到這些較親民的訊息\n定義在__repr__內的東西，是要給developer看的，是formal的資訊，他會告訴你type, 記憶體位置等資訊，可以藉由直接key object name，或是repr()來取得。不信你直接call numpy的object看看，他就會送你array訊息\n為什麼勒？因為python有兩種constructor，一個叫__str__，一個叫__repr__定義在__str__內的東西，是要給end user看的，是informal的資訊，可以藉由print()和str()看到這些較親民的訊息定義在__repr__內的東西，是要給developer看的，是formal的資訊，他會告訴你type, 記憶體位置等資訊，可以藉由直接key object name，或是repr()來取得。不信你直接call numpy的object看看，他就會送你array訊息那現在回頭寫我剛剛的salary class:","code":"class salary:\n  def __init__(self, number):\n    self.number = number\n\nmy_salary = salary(22000)\nprint(my_salary)\n#> <__main__.salary object at 0x10f0f8520>import numpy as np\na = np.array([1,2,3])\nprint(a)\n#> [1 2 3]a\n#> array([1, 2, 3])class salary:\n  def __init__(self, number):\n    self.number = number\n  \n  def __str__(self):\n    return str(self.number)\n  \n  def __repr__(self):\n    return f\"Salary({self.number})\"\n\nmy_salary = salary(22000)\nprint(my_salary)\n#> 22000\nmy_salary\n#> Salary(22000)"},{"path":"encapsulation-inheritacne-and-polymorphism.html","id":"encapsulation-inheritacne-and-polymorphism","chapter":"34 Encapsulation, Inheritacne, and Polymorphism","heading":"34 Encapsulation, Inheritacne, and Polymorphism","text":"這一章要介紹","code":""},{"path":"encapsulation-inheritacne-and-polymorphism.html","id":"封裝","chapter":"34 Encapsulation, Inheritacne, and Polymorphism","heading":"34.1 封裝","text":"把資料(attribute)和使用資料的方法(methods)全包在一起的作法，就叫封裝","code":""},{"path":"encapsulation-inheritacne-and-polymorphism.html","id":"繼承inheritance","chapter":"34 Encapsulation, Inheritacne, and Polymorphism","heading":"34.2 繼承(inheritance)","text":"繼承的意思是，我們在define一個class的時候，可以繼承另一個class的所有attribue和methodsparent class指的是給別人繼承的class，又稱為base classchild class指的是繼承別人的class，又稱為deived class","code":""},{"path":"encapsulation-inheritacne-and-polymorphism.html","id":"simple-inheritance","chapter":"34 Encapsulation, Inheritacne, and Polymorphism","heading":"34.2.1 simple inheritance","text":"例如，我先寫一個class叫Employee_parent，如下：這個class有兩個attribute，和一個method那如果今天我想寫一個WNC_Employee，他想繼承Employee_parent的這些attribute & methods，那就這樣寫：現在我們可以照往常輸入name和salary來initialize一個WNC_Employee的instance:檢查一下之前的attribute都繼承下來了：檢查一下method也繼承下來了：","code":"class Employee_parent:\n  # class-level attribute\n  MIN_SALARY = 30000\n  # instance-level attribute\n  def __init__(self, name, salary):\n    self.name = name\n    self.salary = salary\n  # instance-level method\n  def give_raise(self, amount):\n    self.salary += amountclass WNC_Employee(Employee_parent): #把要繼承的Class name塞入\n  passHank_wnc = WNC_Employee(\"Hank\", 22000)print(Hank_wnc.name)\n#> Hank\nprint(Hank_wnc.salary)\n#> 22000Hank_wnc.give_raise(10000)\nprint(Hank_wnc.salary)\n#> 32000"},{"path":"encapsulation-inheritacne-and-polymorphism.html","id":"增加instance-level-attribute-method","chapter":"34 Encapsulation, Inheritacne, and Polymorphism","heading":"34.2.2 增加instance-level attribute & method","text":"那接下來，就來講如何加入我想新寫的attribute和method例如，對WNC_Employee來說，attribute除了name, salary外，還要新增一個職等(level); method除了原本的give_raise()外，還要新增一個promote()來更新職等的變化:看一下__init__那邊，一開始的init是為了initialize這個新的class的instance用的，而因為他繼承了Employee，所以原本描述Employee的所有attribute都要放入，所以一樣填入”name”和”salary”，而這個新的Class還要有新的attribute，叫”level”，用來描述職等。而這邊的self指的是WNC_Employee的instance的代名詞。那第二行出現的Employee_parent.__init__(self, name, salary)，指的是我要套用之前Employee這個class的__init__函數，第一個self指的還是WNC_Employee的instance，但因為前面講過，他同時也是Employee的instance，所以可以這樣套進來。然後後面的name和salary就是用第一點傳入的name和salary。那這樣套用function後，他就會執行self.name = name, self.salary = salary 這兩行，所以，我只剩下self.level = level這行自己寫下來就好這邊提醒一下，沒有規定一定要用Employee_parent.__init__()，你想要累累的寫self.name = name; self.salary = salary也可以。上面的寫法只是讓你省力，所以大家都這樣寫而已。我們現在initialize一個instance看看：用新的function看看看起來很不錯，但如果我原本parent class的attribute就一大堆的話，我不就又要copy一堆attribute到我的__init__()裡面？其實不用，我們可以用*args和**kwargs直接代稱掉原本的arguments，例如以下這種寫法","code":"class Employee_parent:\n  MIN_SALARY = 30000\n  def __init__(self, name, salary):\n    self.name = name\n    self.salary = salary\n  \n  def give_raise(self, amount):\n    self.salary += amount\n\nclass WNC_Employee(Employee_parent): #把要繼承的Class name塞入\n  # 到目前為止，原本Employee有的東西，WNC_Employee都有了\n  def __init__(self, name, salary, level = 3): # 要多加的level寫在這\n    # call之前Emplolyee的init來用，所以寫了這步，\n    # 等於是少寫self.name, self.salary = name, salary 這一行\n    Employee_parent.__init__(self, name, salary)  \n    self.level = level\n    \n  def promote(self, num_level):\n    self.level = self.level + num_levelHank_wnc2 = WNC_Employee(\"Hank\", 22000, 3)\nprint(Hank_wnc2.name)\n#> Hank\nprint(Hank_wnc2.salary)\n#> 22000\nprint(Hank_wnc2.level)\n#> 3Hank_wnc2.promote(1)\nprint(Hank_wnc2.level)\n#> 4class WNC_Employee2(Employee_parent): #把要繼承的Class name塞入\n  # 到目前為止，原本Employee有的東西，WNC_Employee都有了\n  def __init__(self, level, *args, **kwargs): # 要多加的level寫在這\n    Employee_parent.__init__(self, *args, **kwargs) \n    self.level = level\n    \n  def promote(self, num_level):\n    self.level = self.level + num_level\n\nwnc_hank2 = WNC_Employee2(name = \"Hank\", salary = 22000, level = 3)\nprint(wnc_hank2.level)\n#> 3\nwnc_hank2.promote(1)\nprint(wnc_hank2.level)\n#> 4"},{"path":"encapsulation-inheritacne-and-polymorphism.html","id":"增加class-level-attribute","chapter":"34 Encapsulation, Inheritacne, and Polymorphism","heading":"34.2.3 增加class-level attribute","text":"這其實很好理解，你都繼承原本的class了，所以包括原本的class level attribute, instance attribute, methods全都繼承下來所以，可以看一下剛剛的WNC_Employee的class level attribute: MIN_SALARY在不在在嘛，合理。那這一節的重點，是放在我如果修改child class的class-level attribute，parent class的class-level attribute會不會跟著變？直接講結論：class level attribute可以繼承，而child class的class level attribute可以overwritten掉原本parent class的class level attribute，但不會改變parent class的class level attribute","code":"WNC_Employee.MIN_SALARY\n#> 30000class WNC_Employee_trial(Employee_parent):\n  MIN_SALARY = 0\n  pass\n\nchild = WNC_Employee_trial(\"Hank\", 22000)\nparent = Employee_parent(\"Hank\", 22000)\n\nprint(child.MIN_SALARY)\n#> 0\nprint(parent.MIN_SALARY)\n#> 30000print(WNC_Employee_trial.MIN_SALARY)\n#> 0\nprint(Employee_parent.MIN_SALARY)\n#> 30000"},{"path":"encapsulation-inheritacne-and-polymorphism.html","id":"多形","chapter":"34 Encapsulation, Inheritacne, and Polymorphism","heading":"34.3 多形","text":"多形的意思是，子類別雖然繼承父類別的methods，但我可以命名一個名稱一模一樣的method，讓他over-ride原先的method，這樣就達到名稱一樣，但功能不一樣的現象，我們叫”多形”以WNC_Employee這個class為例，他繼承Employee_parent，所以也繼承了give_raise()這個method那如果WNC這間公司是個佛心公司，他的加薪方式，跟一般公司不同(你輸入要加的薪水後，我還會給你額外的加成福利)，那我們有兩種做法：\n寫一個新的method叫give_raise_new()\n維持舊名稱give_raise()，但內容被我置換成wnc版本 -> 建議這麼做，而這麼做的結果就是”多形”\n寫一個新的method叫give_raise_new()維持舊名稱give_raise()，但內容被我置換成wnc版本 -> 建議這麼做，而這麼做的結果就是”多形”直接看例子：","code":"class Employee_parent:\n  MIN_SALARY = 30000\n  def __init__(self, name, salary):\n    self.name = name\n    self.salary = salary\n  \n  def give_raise(self, amount):\n    self.salary += amount\n    \nclass WNC_Employee3(Employee_parent):\n  def __init__(self, level, *args, **kwargs):\n    Employee_parent.__init__(self, *args, **kwargs) \n    self.level = level\n      \n  # 這邊開始修改新method\n  def give_raise(self, amount, bonus=1): #method名稱同，但多個參數\n    new_amount = amount * bonus\n    Employee_parent.give_raise(self, new_amount) #使用parent class的method\n\nHank_in_parent = Employee_parent(name = \"Hank\", salary = 22000)\nHank_in_wnc = WNC_Employee3(name = \"Hank\", salary = 22000, level = 3)\n\nHank_in_parent.give_raise(amount=10000)\nHank_in_wnc.give_raise(amount=10000, bonus=2)\n\nprint(Hank_in_parent.salary)\n#> 32000\nprint(Hank_in_wnc.salary)\n#> 42000class Animal:\n  def eat(self):\n    return(\"Animal is eating\")\n  \nclass Dog:\n  def eat(self):\n    return(\"Dog is eating\")\n  \nclass Pig:\n  def eat(self):\n    return(\"Pig is eating\")\n\nd = Dog()\np = Pig()\n\nprint(d.eat())\n#> Dog is eating\nprint(p.eat())\n#> Pig is eating"},{"path":"encapsulation-inheritacne-and-polymorphism.html","id":"多形的使用時機","chapter":"34 Encapsulation, Inheritacne, and Polymorphism","heading":"34.3.1 多形的使用時機","text":"課堂上有舉個使用時機，但我現在還看不太懂好處在哪。","code":""}]
