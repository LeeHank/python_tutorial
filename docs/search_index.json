[["index.html", "Python Tutorial Introduction", " Python Tutorial Hank Lee 2021-02-17 Introduction 這邊是總結Udemy上的python內容 "],["python-environmental-setting.html", "Chapter 1 Python Environmental Setting", " Chapter 1 Python Environmental Setting 這邊應該要整理一下，怎麼安裝python，怎麼控制不同版本的python，怎麼確定自己正在用哪個版本的python等等 "],["-python-code.html", "Chapter 2 執行Python的code 2.1 在command line執行 2.2 寫成.py檔後執行 2.3 在VS code中執行 2.4 在 RStudio 中執行", " Chapter 2 執行Python的code 2.1 在command line執行 去command line，然後打python3，就會進入互動視窗，然後就可以互動的執行了 要結束時，再按quit()，就會退出視窗 python3 print(&quot;Hello, World&quot;) quit() 2.2 寫成.py檔後執行 我們可以開一個script，在裡面寫code，然後存成.py檔，例如hello.py 然後，在command line，用python3 /path/to/this/file/hello.py，就可以執行這個.py檔了 2.3 在VS code中執行 在VS code中，較常用的方法，就是寫成script，然後在下面的console，用python3 /path/to/this/file/hello.py這種方法執行寫好的東西 逐行執行的部分，要再查一下，目前就只會在jupyter中逐行執行，但很笨 2.4 在 RStudio 中執行 應該要用Reticulate的架構來整理，等有空再說吧 2.4.1 新增檔案/python script 只要新增一個.py的檔案，就可以像寫R一樣逐行執行 2.4.2 用RMarkdown 開RMarkdown檔案，然後用command + option + p，開啟python的chunk，就可以執行了 "],["-indention.html", "Chapter 3 註解與indention 3.1 插入註解 3.2 indention", " Chapter 3 註解與indention 3.1 插入註解 python的註解和R一樣，都是用井字號，只要記得加空格來維持PEP8代碼風格即可： # 有空一格就是好註解 #沒有空格是爛註解 print(&quot;Hello, World!&quot;) 另外，在Python中，如果字串沒有被assign到一個變數，那會自動被忽略。所以，需要多行註解時，可以善用字串寫法: &quot;&quot;&quot; This is a comment written in more than just one line &quot;&quot;&quot; print(&quot;Hello, World!&quot;) 3.2 indention 在R或其他語言，經常是用大括號來包住function body，例如： my_func = function(x){ # 有大括號就是放心 a = x + 1 return(a) } 但在Python都是靠indent: def my_func(x): # 靠indent來營造出coding block a = x + 1 return(a) my_func(4) #&gt; 5 "],["print.html", "Chapter 4 print 4.1 print可以放多個element進去 4.2 用sep=來改間隔", " Chapter 4 print print()雖然很簡單，但有一些我原本不清楚的東西，所以整理一下 4.1 print可以放多個element進去 例如： a = &quot;number&quot; b = 123 print(a, b, &quot;cool&quot;) #&gt; number 123 cool 可以發現，他不同的element間，用空格幫你隔開。這個空格是預設的，可以改。 4.2 用sep=來改間隔 看一下help文件(?print)，可以發現有sep = ' '這個argument，預設值是空格。所以改一下就可以換了 a = &quot;number&quot; b = 123 print(a, b, &quot;cool&quot;, sep = &quot;++&quot;) #&gt; number++123++cool "],["variables.html", "Chapter 5 Variables 5.1 overview 5.2 variable names 5.3 一次assign多個variables 5.4 Assignment Operators 5.5 variable scope", " Chapter 5 Variables 5.1 overview 5.1.1 建立variable python和R一樣，都不用宣告資料類型，就可以assign variable了： x = 4 # x is of type int x = &quot;Sally&quot; # x is now of type str print(x) #&gt; Sally 如果想要和C/Java一樣，assign variable時同時宣告資料類型，那要用casting x = str(3) # x will be &#39;3&#39; y = int(3) # y will be 3 z = float(3) # z will be 3.0 5.1.2 用type()來確認variable資料類型 x = 5 y = &quot;John&quot; print(type(x)) #&gt; &lt;class &#39;int&#39;&gt; print(type(y)) #&gt; &lt;class &#39;str&#39;&gt; 5.2 variable names 5.2.1 規則 python中對variable name的要求是： 只能是由alpha-numeric + underscores所組成(A-z, 0-9, _) 開頭不能是數字，只能英文或底線 case-sensitive，大小寫有差拉 # 合法的variable name myvar = &quot;John&quot; my_var = &quot;John&quot; _my_var = &quot;John&quot; myVar = &quot;John&quot; MYVAR = &quot;John&quot; myvar2 = &quot;John&quot; # 不合法的variable name 2myvar = &quot;John&quot; my-var = &quot;John&quot; my var = &quot;John&quot; 5.2.2 多個字的variable name 如果variable name想由多個字組成，哪有三種習慣性寫法： Snake Case: 像蛇一樣一節一節的，用底線隔開，例如 my_variable_name Pascal Case: 每個字的開頭都給他大寫，例如 MyVariableName Camel Case: 像駱駝一樣，頭低低，後面駝峰都高起，所以首字小寫，之後都大寫，例如 myVariableName 5.3 一次assign多個variables 5.3.1 多個value，assign給多個variable x, y, z = &quot;Orange&quot;, &quot;Banana&quot;, &quot;Cherry&quot; print(x) #&gt; Orange print(y) #&gt; Banana print(z) #&gt; Cherry 5.3.2 同一個value，assign給多個variable x = y = z = &quot;Orange&quot; print(x) #&gt; Orange print(y) #&gt; Orange print(z) #&gt; Orange 5.3.3 unpack a collection 在python中，collection包含list, tuple, dictionary, set 那我可以把這些collection中的各個element，assign給各個variable，例如： fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] x, y, z = fruits print(x) #&gt; apple print(y) #&gt; banana print(z) #&gt; cherry 而這招最常用的還是用在tuple上： fruits = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) x, y, z = fruits print(x) #&gt; apple print(y) #&gt; banana print(z) #&gt; cherry 5.4 Assignment Operators Python有許多assignment operators，整理如下： Operator Example Same As = x = 5 x = 5 += x += 3 x = x + 3 -= x -= 3 x = x - 3 *= x *= 3 x = x * 3 /= x /= 3 x = x / 3 %= x %= 3 x = x % 3 // x //= 3 x = x // 3 **= x **= 3 x = x ** 3 備註： x % 3的意思是，我要取餘數 x // 3的意思是，我要取商 x ** 3的意思是，x的3次方 5.5 variable scope 5.5.1 Global Variables 想把function中的variable(e.g. x這個variable)，拉到global environment，就先用global x來宣告我的x是屬於global的，之後在這個function內把value給assign到x，就會放在global environment裡： 來看看沒宣告的例子： x = &quot;awesome&quot; def myfunc(): x = &quot;fantastic&quot; print(&quot;Python is &quot; + x) myfunc() #&gt; Python is fantastic print(&quot;Python is &quot; + x) #&gt; Python is awesome 再看看有宣告的例子： x = &quot;awesome&quot; def myfunc(): global x x = &quot;fantastic&quot; print(&quot;Python is &quot; + x) myfunc() #&gt; Python is fantastic print(&quot;Python is &quot; + x) #&gt; Python is fantastic "],["python-data-types.html", "Chapter 6 Python Data Types 6.1 Built-in Data Types 6.2 Getting the data type 6.3 Setting the specific data type", " Chapter 6 Python Data Types 6.1 Built-in Data Types python內建的data type，我喜歡把他分成三大類： 基本款 collections binary 6.1.1 基本款 基本款： Text: str Numeric: int, float, complex Boolean: bool 6.1.2 collections collections(array): Sequence: list, tuple, range mapping: dict set: set, frozenset 6.1.3 binary binary types: bytes, bytearray 6.2 Getting the data type 用type()，可以獲取此variable的類型 6.3 Setting the specific data type 我們只要在value的前面，加上想宣告的資料類型，就可明確的定義出這種type的value # 基本款 x = str(&quot;Hello World&quot;) x = int(20) x = float(20.5) x = complex(1j) x = bool(True) # collections x = list((&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)) x = tuple((&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)) x = range(6) x = dict(name = &quot;john&quot;, age = 36) x = set((&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)) x = frozenset((&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)) # binary x = bytes(5) x = bytearray(5) x = memoryview(bytes(5)) "],["int-float-.html", "Chapter 7 int &amp; float 整理與實戰 7.1 建立int/float變數 7.2 宣告int/float變數 7.3 型別轉換", " Chapter 7 int &amp; float 整理與實戰 7.1 建立int/float變數 int是整數，float是浮點數，當你assign variable時，python基本上就是看你有沒有小數點來做type的判定： x = 1 print(type(x)) #&gt; &lt;class &#39;int&#39;&gt; y = 1.0 print(type(y)) #&gt; &lt;class &#39;float&#39;&gt; 7.2 宣告int/float變數 我們可以用casting的方式，來直接標明我的變數類型 x = int(1) print(type(x)) #&gt; &lt;class &#39;int&#39;&gt; y = float(1.0) print(type(y)) #&gt; &lt;class &#39;float&#39;&gt; 7.3 型別轉換 如果把int轉成float，就幫你加小數點：e.g. 1 -&gt; 1.0 如果把float轉成int，會無條件捨去 x = 1 print(float(x)) #&gt; 1.0 y = 1.6 print(int(y)) #&gt; 1 "],["string-.html", "Chapter 8 string整理與實戰 8.1 字串的定義 8.2 字串的基本操作 8.3 字串的format (i.e. R的paste()功能) 8.4 字串的join (i.e. R的collapse)", " Chapter 8 string整理與實戰 8.1 字串的定義 可以用單引號、雙引號做定義 a = &#39;hank&#39; print(a) #&gt; hank print(type(a)) #&gt; &lt;class &#39;str&#39;&gt; b = &quot;tom&quot; print(b) #&gt; tom print(type(b)) #&gt; &lt;class &#39;str&#39;&gt; 如果字串中含有單引號，那就用雙引號定義，反之亦然 a = &#39;tom is &quot;good&quot;&#39; print(a) #&gt; tom is &quot;good&quot; b = &quot;hank is &#39;bad&#39;&quot; print(b) #&gt; hank is &#39;bad&#39; 如果字串中又有單引號，雙引號，那就用三個單引號做定義 c = &#39;&#39;&#39; tom is &quot;good&quot;, and hank is &#39;bad&#39; &#39;&#39;&#39; print(c) #&gt; #&gt; tom is &quot;good&quot;, and hank is &#39;bad&#39; 8.2 字串的基本操作 8.2.1 利用\"\"來定義逃脫字元 例如換行是“” a = &quot;abc\\nabc&quot; a #&gt; &#39;abc\\nabc&#39; 直接打a時，他給你看原始樣貌 但用print時，就會給你看顯示時的樣子 print(a) #&gt; abc #&gt; abc 8.2.2 把字串看成list，index時從0開始 a = &quot;hank&quot; a[2] #&gt; &#39;n&#39; 8.2.3 字串常用功能：去空白、改小寫、取代 假設現在我有一個字串 s = &#39; Last Checkpoint: a few seconds ago (unsaved change) &#39; s #&gt; &#39; Last Checkpoint: a few seconds ago (unsaved change) &#39; 可以發現，這個字串的最前面和最後面都有空白，蠻討厭的，可以用.strip()來去掉 a = s.strip() a #&gt; &#39;Last Checkpoint: a few seconds ago (unsaved change)&#39; 然後大小寫交錯，在NLP中也很擾人，所以全改成小寫 a = a.lower() a #&gt; &#39;last checkpoint: a few seconds ago (unsaved change)&#39; 最後，如果我想把“(”和“)”都取代成“#”，就用replace a = a.replace(&quot;(&quot;, &quot;#&quot;) a #&gt; &#39;last checkpoint: a few seconds ago #unsaved change)&#39; a = a.replace(&quot;)&quot;, &quot;#&quot;) a #&gt; &#39;last checkpoint: a few seconds ago #unsaved change#&#39; 大功告成 而實務上在做時，喜歡一條龍做下去，比較好讀： s2 = a.strip().lower().replace(&quot;(&quot;, &quot;#&quot;).replace(&quot;(&quot;, &quot;#&quot;) s2 #&gt; &#39;last checkpoint: a few seconds ago #unsaved change#&#39; 8.3 字串的format (i.e. R的paste()功能) 假設我現在有兩個字串 name = &#39;python&#39; age = 27 那如果我想format出一個句子是： “我是python, 我今年27歲了”，那我可以怎麼做？ 在R裡面就是用paste，那現在在python裡面，就有特定的format方法 8.3.1 直接一路加號到底 new_str = &quot;我是&quot; + name + &quot;，我今年&quot; + str(age) + &quot;歲了&quot; print(new_str) #&gt; 我是python，我今年27歲了 恩，可以work，但這樣寫別人會把你當北七 8.3.2 用%s, %d 來做 直接看例子： new_str_1 = &quot;我是%s, 我今年%d歲了&quot; % (name, age) print(new_str_1) #&gt; 我是python, 我今年27歲了 裡面的%s的s是指string，`%d``的d是指double，所以他會宣告對應的type，然後最後再丟對應的object 介紹這個只是為了知道有這種寫法而已，這是python 2時代的寫法，現在python3也沒人這樣寫了 8.3.3 用{}和.format 第一種寫法，照著位子順序定義 new_str_2 = &quot;我是{}, 我今年{}歲了&quot;.format(name, age) print(new_str_2) #&gt; 我是python, 我今年27歲了 第二種寫法，括號內定義variable再對應 new_str_3 = &quot;我是{var1}, 我今年{var2}歲了&quot;.format( var1 = name, var2 = age ) print(new_str_3) #&gt; 我是python, 我今年27歲了 這兩種寫法，是python2 ~ python 3.6的時代的寫法，的確比python2的寫法清楚多了 但一樣的，也漸漸沒人這樣寫了，因為python 3.6以後，大家就都改用以下更直覺的寫法了 8.3.4 用f吧! new_str_4 = f&quot;我是{name}, 我今年{age}歲了&quot; print(new_str_4) #&gt; 我是python, 我今年27歲了 太舒服了，f放在字串外面，就等於宣告他要做format，然後中括號內直接放variable，直覺阿!!! 8.4 字串的join (i.e. R的collapse) 剛剛介紹的format，其實就是對應到R中的paste，但R的paste還有一個很好用的功能是collapse，可以把多個字串給join在一起，例如： a = c(&quot;I&quot;, &quot;am&quot;, &quot;hank&quot;) paste(a, collapse = &quot; &quot;) #&gt; [1] &quot;I am hank&quot; paste(a, collapse = &quot;_&quot;) #&gt; [1] &quot;I_am_hank&quot; 那用python可以怎麼做呢？先示範最笨的，用for迴圈做 a = [&quot;I&quot;, &quot;am&quot;, &quot;hank&quot;] new = &quot;&quot; sep = &quot; &quot; for i in a: new = new + i + sep new #&gt; &#39;I am hank &#39; 那實際在做時，是用 .join這個method print(&quot; &quot;.join(a)) #&gt; I am hank print(&quot;_&quot;.join(a)) #&gt; I_am_hank "],["collections-overview.html", "Chapter 9 collections overview", " Chapter 9 collections overview 在Python中，有四種collection data types (i.e. arrays) list: ordered, changeable, allow duplicate members tuple: ordered, unchangeable, allow duplicate members set: unordered, changeable, no duplicated members dictionary: unordered, changeable, no duplicated members "],["list-.html", "Chapter 10 list整理與實戰 10.1 list定義 10.2 [建] 建立list 10.3 [查] 取用list裡面的item 10.4 [改] 修改list裡面的item 10.5 [增] 增加list裡面的item 10.6 [增] join兩個list 10.7 [刪] 刪除list裡面的item 10.8 [mutable] copy list 10.9 [loop] for 10.10 [loop] list comprehension 10.11 排序(.sort()) 10.12 順序倒過來(.reverse()) 10.13 list.count(‘a’) = 計算’a’在list中出現幾次 10.14 Practice", " Chapter 10 list整理與實戰 list是python內建的一種collection 既然是collection，我們就可以把它當資料庫看，所以會依序介紹作為資料庫最基礎的幾個part： 如何建立？ 如何增、刪、查、改？ 這些基礎會了後，就確認一下是否為mutable物件，來決定如何做copy 接著就開始介紹如何loop他(用for, comprehension) 最後就是補齊這個object還沒介紹到的methods 實戰的部分，就會以“How to…”的方式整理常見的需求 10.1 list定義 list用中括號來建立，裡面的每個元素我們叫item，item可以是不同的type，例如： a_list = [12, 3, 67, 7, 82] #同一種type的list another_list = [&quot;happy&quot;, 3, True, 7] #不同type的list print(type(a_list)) #&gt; &lt;class &#39;list&#39;&gt; print(type(another_list)) #&gt; &lt;class &#39;list&#39;&gt; list的特性有三個，ordered, changeable, allow duplicate values： ordered: 他是有順序的，裡面的items就像排隊取號碼牌一樣，都有自己的序號(index)，此序號由0開始排起。所以如果有新成員要加入list，只能排到隊伍的最後面，用append的方式加入。要取用某個item時，也是用叫號碼牌的方式取用 changeable: list裡面的item是可改變的，意思是，當我建立好一個list後，我可以改變號碼牌為x的那個item的值，我也可以新增或刪除item allow duplicates: item是可以重複的 10.2 [建] 建立list 10.2.1 建立單維list 剛剛講過了，就用個中括號包起來就好 10.2.2 建立多維list list裡面還有list，就叫多維list a = [1,2,3,4,5] # 1*5 list multi_dim_a = [[1,2,3], [2,3,4], [3,4,5]] print(multi_dim_a) #&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5]] 10.3 [查] 取用list裡面的item list因為只有item，沒有name(簡單來講，就是只有value，沒有key)，所以subset時，都是用index來取 index就擬人化為座號，而python的編號由左至右是從0開始，由右至左是從-1開始 所以我要取list中左邊數來第n個人，他的座號是n-1，那就要取n-1的index 如果我要取list中右邊數來第n個人，他的座號是-n，那就要取-n的index 10.3.1 用index = 0取第一個item 單維list的例子： my_list = [&quot;my&quot;, &quot;list&quot;, &quot;is&quot;, &quot;nice&quot;] my_list[3] # 取index=3, 那就是取element = 4 #&gt; &#39;nice&#39; 學會單維list的subset了，那多維list的subset邏輯一模一樣 multi_dim_a = [[1,2,3], [2,3,4],[3,4,5]] multi_dim_a[1] # 取index = 1，即左邊數來第2個 #&gt; [2, 3, 4] multi_dim_a[1][0] # 先取左邊數來第2個element，再取裡面的第1個element #&gt; 2 10.3.2 用index = -2取由右數來第2個 my_list = [&quot;my&quot;, &quot;list&quot;, &quot;is&quot;, &quot;nice&quot;] my_list[-2] # 取index -2, 即又邊數來第二個 #&gt; &#39;is&#39; 10.3.3 3:8表示從index3取到index7 剛剛是取“某一個”element，那如果我想取“某一串”element呢？那就是指slice 語法是[start_index:stop_index]，所以[1:5]是指從index=1取到index=4，那就是取第2個element到第5個 所以為了方便記憶，就把stop_index當作stop_element來看，然後start_index還是start_index 簡單練習，[5:9]，就是指取element = 6 ~ 9 然後，如果你跳過start_index不寫，就是從頭開始；跳過stop_index不寫，就是取到最後；兩個都不寫，就是全取 例如： [:9]，那就是從第一個element一路取到第9個element 例如: [3:]，那就是第4個element一路取到最後一個element 例如: [:]，那就是整串全取(等於複製一個) my_list = [&quot;my&quot;, &quot;list&quot;, &quot;is&quot;, &quot;nice&quot;] my_list[1:3] # 取 element = 2~3 #&gt; [&#39;list&#39;, &#39;is&#39;] my_list = [&quot;my&quot;, &quot;list&quot;, &quot;is&quot;, &quot;nice&quot;] my_list[:3] # 取element = 1~3 #&gt; [&#39;my&#39;, &#39;list&#39;, &#39;is&#39;] my_list = [&quot;my&quot;, &quot;list&quot;, &quot;is&quot;, &quot;nice&quot;] my_list[1:] # 取element = 2~最後 #&gt; [&#39;list&#39;, &#39;is&#39;, &#39;nice&#39;] slice一律只能由左至右取，但編號系統可以用正的編號(由左至右的編號系統)或負的編號(由右至左的編號系統) [1:3]是指由左至右，取element= 2~3 [-2:-3]是指由右至左，取element = 右邊數來第2個 ~ 第3個? NO! 他只能由左至右取，所以應該寫成[-3:-2]? NO! 這樣他指會取右邊數來的第3個element，到右邊數來的第2個element的“前1個”! 所以如果要取右邊數來第3個element到右邊數來第2個element，那要寫成[-3:-1] my_list = [&quot;my&quot;, &quot;list&quot;, &quot;is&quot;, &quot;nice&quot;] my_list[-3:-1] #&gt; [&#39;list&#39;, &#39;is&#39;] 10.3.4 用.index('a')找出’a’所屬的index 在R中，我們用 which(list1 == 'a')來找index，那在python就是用list1.index(\"a\") 看例子： a_list = [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;] my_index = a_list.index(&quot;banana&quot;) print(my_index) #&gt; 2 10.3.5 用in來確認item在不在list裡 這邊的in，就是R的%in% thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] if &quot;apple&quot; in thislist: print(&quot;Yes, &#39;apple&#39; is in the fruits list&quot;) #&gt; Yes, &#39;apple&#39; is in the fruits list 10.4 [改] 修改list裡面的item 剛剛已經學會如何取出list中的特定一個element，或是一串element，那我們就可以利用這個技巧，把新值assign到指定位置： my_list = [&quot;my&quot;, &quot;list&quot;, &quot;is&quot;, &quot;nice&quot;] my_list[3] = &quot;bad&quot; my_list #&gt; [&#39;my&#39;, &#39;list&#39;, &#39;is&#39;, &#39;bad&#39;] 同樣的，可以一次改動多個位子的值 my_list[1:] = [&quot;lists&quot;, &quot;are&quot;, &quot;awsome&quot;] my_list #&gt; [&#39;my&#39;, &#39;lists&#39;, &#39;are&#39;, &#39;awsome&#39;] 10.5 [增] 增加list裡面的item 10.5.1 加到最後面，用.append() 例如下例： thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] thislist.append(&quot;orange&quot;) print(thislist) #&gt; [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;, &#39;orange&#39;] 不要傻傻的，用[old_list, \"new_item\"]，這樣會變多維list old_list = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] new_list = [old_list, &quot;orange&quot;] print(new_list) #&gt; [[&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;], &#39;orange&#39;] 10.5.2 加到指定的位置，用.insert() thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] thislist.insert(1, &quot;orange&quot;) print(thislist) #&gt; [&#39;apple&#39;, &#39;orange&#39;, &#39;banana&#39;, &#39;cherry&#39;] 10.6 [增] join兩個list 拜託，不要用[list1, list2]，這不是R(用c(vec1, vec2))，這樣寫會造出多維list list1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] list2 = [1, 2, 3] [list1, list2] #&gt; [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [1, 2, 3]] 用+是最簡單的做法： list1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] list2 = [1, 2, 3] list3 = list1 + list2 print(list3) #&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3] 用.extend也ok list1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] list2 = [1, 2, 3] list1.extend(list2) print(list1) #&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3] 而.extend其實是去loop後面的iterable，依序將後面的每個element加入到前面的list中，所以後面只要放iterable即可，不一定要放list。舉例來說，我放tuple也ok: thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] thistuple = (&quot;kiwi&quot;, &quot;orange&quot;) thislist.extend(thistuple) print(thislist) #&gt; [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;, &#39;kiwi&#39;, &#39;orange&#39;] 如果你要用.append，那就得自己寫回圈： list1 = [&quot;a&quot;, &quot;b&quot; , &quot;c&quot;] list2 = [1, 2, 3] for x in list2: list1.append(x) print(list1) #&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3] 10.7 [刪] 刪除list裡面的item 10.7.1 .remove(item) 刪除該item thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] thislist.remove(&quot;banana&quot;) print(thislist) #&gt; [&#39;apple&#39;, &#39;cherry&#39;] 10.7.2 .pop() 刪除最後一筆 thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] thislist.pop() #&gt; &#39;cherry&#39; print(thislist) #&gt; [&#39;apple&#39;, &#39;banana&#39;] 10.7.3 .pop(index) 刪除該index thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] thislist.pop(1) #&gt; &#39;banana&#39; print(thislist) #&gt; [&#39;apple&#39;, &#39;cherry&#39;] 10.7.4 del list[index] 刪除該list中的此index thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] del thislist[0] print(thislist) #&gt; [&#39;banana&#39;, &#39;cherry&#39;] 10.7.5 .clear() 清空此list內所有item thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] thislist.clear() print(thislist) #&gt; [] 10.8 [mutable] copy list 在討論mutable或inmuatable的問題時，都是在討論當你把原物件copy一次後，對新copy的物件做事，會不會影響到舊物件(i.e. list1_copy = list1，那對list1_copy做修改時，list1會不會跟著動？) 而對list來說，就是會，因為variable name只是一個reference，指到記憶體位置，所以原物件和copy後的物件，其實都指到同一個位置，那你一改他，兩個variable就都會跟著動 old_list = [1, 2, 3] bad_new_list = old_list old_list.pop() #&gt; 3 print(old_list) #&gt; [1, 2] print(bad_new_list) #&gt; [1, 2] 所以對mutable object，請愛用list1_copy = list1.copy()，或是用list1_copy = list(list1)來做copy，不要用list1_copy = list1來做copy： old_list = [1, 2, 3] new_list = old_list.copy() new_list.pop() #&gt; 3 print(new_list) #&gt; [1, 2] print(old_list) #&gt; [1, 2, 3] 10.9 [loop] for 10.9.1 loop index R的觀點來做迭代，習慣取index，那就會寫成下面這樣： a_list = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] for index in range(len(a_list)): print(index) len(a_list)得到他的長度=3，而range(3)表示由0開始stop在3，所以就得到0,1,2這3個index 10.9.2 loop items 但python的觀點，都是直接取裡面的items做迭代，那就會寫成這樣： for item in a_list: print(item) 10.9.3 enumerate() 最後，python才有的，又取index，又取item，語法是： enumerate for index, item in enumerate(a_list): print(&quot;index = &quot;, index, &quot;, number in list = &quot;, item) 10.10 [loop] list comprehension 10.10.1 simple example 簡單講，就是把for loop簡化成一行的版本 例如以下的例子，我已有一個字串list，然後我想取出每個item的第一個字母，變成新的list，那用for回圈寫會長這樣： doctor = [&#39;house&#39;, &#39;cuddy&#39;, &#39;chase&#39;, &#39;thirteen&#39;, &#39;wilson&#39;] # 目標：抓出每個element中的第一個字 first = [] for doc in doctor: first.append(doc[0]) print(first) #&gt; [&#39;h&#39;, &#39;c&#39;, &#39;c&#39;, &#39;t&#39;, &#39;w&#39;] 那如果用list comprehension，就寫成以下這樣： list_comp = [doc[0] for doc in doctor] print(list_comp) #&gt; [&#39;h&#39;, &#39;c&#39;, &#39;c&#39;, &#39;t&#39;, &#39;w&#39;] 帥…還真的一行幹掉，我們首先來教要怎麼閱讀這種code。 在閱讀上，我們要先辨認出三個結構： 要output出來的data structure，寫在最外面，也就是我們看到的中括號，告訴我們他要output成一個list for loop要iterate的part，也就是在最後面看到的for doc in doctor。其中doctor叫做iterable，doc叫iterator variable(代表iterable中的member) 每iterate完一個，要output出什麼，也就是最前面看到的doc[0]，這部分我們叫“output expression” 了解一個list comprehension是由這三個組成後，閱讀的順序就會變成： 先讀要for loop的地方，所以知道他要做的是for doc in doctor 再讀每iterate完一次，要output什麼東西出來，所以從doc[0]可知，要丟第一個字母出來 最後，看到最外面是中括號，就知道要把這些結果，搜集成list 所以，總結起來，list comprehension是由以下的pattern組合而成：[\"output expression\" for \"iterator variable\" in \"iterable\" ] 有了這個概念後，就可以開始練習把傳統的for loop轉成list comprehension了 10.10.2 nested for loop pairs_1 = [] for num1 in range(0, 2): for num2 in range(6, 8): pairs_1.append((num1, num2)) print(pairs_1) #&gt; [(0, 6), (0, 7), (1, 6), (1, 7)] 像這種兩個for回圈，寫成list comprehension時，可以這樣寫： pairs_2 = [(num1,num2) for num1 in range(0,2) for num2 in range(6,8)] print(pairs_2) #&gt; [(0, 6), (0, 7), (1, 6), (1, 7)] 10.10.3 conditional for loop 如果for回圈裡面，有if, if-else, if-elif-else的話，可以寫成list comprehension嗎？ 答案是，if和if-else可以，但if-elif-else不行。而且if和if-else的寫法有特定pattern，兩者寫法不同，吞下去就對了 10.10.3.1 if fellowship = [&#39;frodo&#39;, &#39;samwise&#39;, &#39;merry&#39;, &#39;aragorn&#39;, &#39;legolas&#39;, &#39;boromir&#39;, &#39;gimli&#39;] #我現在想重新建立一個list，裡面的element，都要是字數&gt;=7的我才收進來，那就用for loop 加上 if吧！ fellowship_for_if = [] for member in fellowship: if len(member) &gt;= 7: fellowship_for_if.append(member) print(fellowship_for_if) #&gt; [&#39;samwise&#39;, &#39;aragorn&#39;, &#39;legolas&#39;, &#39;boromir&#39;] 那同樣的結構，當然可以用list comprehension來寫了，就是先for，再if fellowship_list_comprehension = [member for member in fellowship if len(member)&gt;=7] # 2. output expression為member 1.iteration part # Print the new list print(fellowship_list_comprehension) #&gt; [&#39;samwise&#39;, &#39;aragorn&#39;, &#39;legolas&#39;, &#39;boromir&#39;] 之前有說過第一塊要放output expression，所以，比較正確的做法，應該是寫member if len(member)&gt;=7 for member in fellowship才對，但…就不能這樣寫。反而，在if-else時，一定要這樣寫。 10.10.3.2 if-else new_fellowship = [member if len(member) &gt;= 7 else &#39;&#39; for member in fellowship] # |----expression part想呈現成這樣----| |---iteration part-------| # Print the new list print(new_fellowship) #&gt; [&#39;&#39;, &#39;samwise&#39;, &#39;&#39;, &#39;aragorn&#39;, &#39;legolas&#39;, &#39;boromir&#39;, &#39;&#39;] 10.11 排序(.sort()) 10.11.1 .sort() 字串型的list，就是照字母順序由小到大 thislist = [&quot;orange&quot;, &quot;mango&quot;, &quot;kiwi&quot;, &quot;pineapple&quot;, &quot;banana&quot;] thislist.sort() print(thislist) #&gt; [&#39;banana&#39;, &#39;kiwi&#39;, &#39;mango&#39;, &#39;orange&#39;, &#39;pineapple&#39;] 數值型就照大小，由小到大 thislist = [100, 50, 65, 82, 23] thislist.sort() print(thislist) #&gt; [23, 50, 65, 82, 100] 10.11.2 .sort(reverse = True) 倒過來牌，用reverse = True (不是descending = TRUE) thislist = [100, 50, 65, 82, 23] thislist.sort(reverse = True) print(thislist) #&gt; [100, 82, 65, 50, 23] 10.11.3 .sort(key = my_func) 我們可以自己定義一個function，讓list裡面的每個item，都先做完這個運算後，再排序 例如，我想讓我的list items，依照距離50這個數值的遠近排列： def myfunc(n): return abs(n - 50) thislist = [100, 50, 65, 82, 23] thislist.sort(key = myfunc) print(thislist) #&gt; [50, 65, 23, 82, 100] 10.12 順序倒過來(.reverse()) 如果我想把一個list，左右顛倒，就可以用.reverse my_list = [1, 2, 3, 4, 5] my_list.reverse() print(my_list) #&gt; [5, 4, 3, 2, 1] 10.13 list.count(‘a’) = 計算’a’在list中出現幾次 a_list = [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;, &quot;banana&quot;] new = a_list.count(&quot;banana&quot;) print(new) #&gt; 2 10.14 Practice 現在來做個簡單的練習，在tweets.csv中，有一個欄位是created_at，是說這個訊息在幾點幾分建立的，我們看一下： import pandas as pd df = pd.read_csv(&quot;./data/tweets.csv&quot;) tweet_time = df[&quot;created_at&quot;] 現在，假如我想抓出“時間”的資訊就好，也就是第12~19個element，我可以怎麼做呢？ 先建一個空list，然後用for回圈，對每個element都抓12~19的字元，append回這個空list？ sure，當然可以，但好遜，我們用list comprehension不就好了？ result = [entry[11:19] for entry in tweet_time] print(result[0:10]) #&gt; [&#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:18&#39;, &#39;23:40:17&#39;, &#39;23:40:18&#39;, &#39;23:40:18&#39;] nice，那如果我現在龜毛一點，我想抓hh:mm:ss中的ss=17的就好，怎麼做？ result2 = [entry[11:19] for entry in tweet_time if entry[17:19]==&#39;17&#39;] print(result2) #&gt; [&#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:17&#39;, &#39;23:40:17&#39;] "],["tuple-.html", "Chapter 11 tuple整理與實戰 11.1 [建] tuple定義與創建 11.2 主要用在保護數據和unpack 11.3 [查] 取用tuple中的item 11.4 [改, 增, 刪] tuple不可修改 11.5 immutable 11.6 [loop] for回圈 11.7 [loop] comprehension 11.8 join兩個tuple用加號", " Chapter 11 tuple整理與實戰 tuple是python內建的一種collection 既然是collection，我們就可以把它當資料庫看，所以會依序介紹作為資料庫最基礎的幾個part： 如何建立？ 如何增、刪、查、改？ 這些基礎會了後，就確認一下是否為mutable物件，來決定如何做copy 接著就開始介紹如何loop他(用for, comprehension) 最後就是補齊這個object還沒介紹到的methods 實戰的部分，就會以“How to…”的方式整理常見的需求 11.1 [建] tuple定義與創建 tuple用小括號來創建，例如： my_tuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) print(my_tuple) #&gt; (&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;) print(type(my_tuple)) #&gt; &lt;class &#39;tuple&#39;&gt; 特別提醒，如果只有一個元素，那必須加上逗號才會是tuple thistuple = (&quot;apple&quot;,) print(type(thistuple)) #NOT a tuple #&gt; &lt;class &#39;tuple&#39;&gt; thistuple = (&quot;apple&quot;) print(type(thistuple)) #&gt; &lt;class &#39;str&#39;&gt; tuple的特色是 ordered: 所以他也是用index來取裡面的items unchangeable: 這是他最大的特色，不可修改。所以你要改裡面的item，或是要新增/刪除item，都是不允許的 allow duplicate: tuple裡面的item可以重複 11.2 主要用在保護數據和unpack 已經有了list，為何還要tuple？有以下三個時機用tuple比list好 tuple比list快，所以element爆多時，可以選tuple: tuple會比較快的原因是，他不可修改，所以建立tuple時，會開“一個”大小固定的記憶體空間給他。但如果是建立list，會開“兩個”記憶體空間，一個是給實際的list數據，另一個是拿來當擴展使用的。所以tuple較快，但list較彈性 tuple不可修改，所以比較安全：如果我們寫程式時，有一段資料要重複使用(e.g. 已經設定好的一組黃金參數)，那就傾向用tuple，因為沒有人可以修改他。但如果用list，就很怕出亂子 寫function時，tuple有unpack的特性，可以unpack a tuple into several variables!先看例子： fruits = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) green, yellow, red = fruits print(green) #&gt; apple print(yellow) #&gt; banana print(red) #&gt; cherry 這個的好處是，寫function時，要return的東西如果是多個variable，在R就會寫成list，然後之後就要用錢字號去取裡面的每個element。但在python，就喜歡return一個tuple，然後之後用unpack的特性去接這些結果： def raise_both(value1, value2): &quot;&quot;&quot; Raise value1 to the power of value2 and vice versa. &quot;&quot;&quot; new_value1 = value1 ** value2 new_value2 = value2 ** value1 new_tuple = (new_value1, new_value2) return new_tuple 那實際使用這個function時，就會這樣做： result1, result2 = raise_both(2,3) print(result1) #&gt; 8 print(result2) #&gt; 9 最後講一個小trick，如果要assign的variable個數，小於吐出來的value的個數怎辦？ 可以把星號加在某個variable前面，就會把剩餘的value全包給那個變數: fruits = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;strawberry&quot;, &quot;raspberry&quot;) (green, yellow, *red) = fruits print(green) #&gt; apple print(yellow) #&gt; banana print(red) #&gt; [&#39;cherry&#39;, &#39;strawberry&#39;, &#39;raspberry&#39;] 11.3 [查] 取用tuple中的item tuple在查的部分，和list是一模一樣的 11.3.1 用list1[index]取數據 thistuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) print(thistuple[1]) #&gt; banana 11.3.2 用負號往回取 thistuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) print(thistuple[-1]) #&gt; cherry 11.3.3 2:5是指取index=2到index=4 thistuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;orange&quot;, &quot;kiwi&quot;, &quot;melon&quot;, &quot;mango&quot;) print(thistuple[2:5]) #&gt; (&#39;cherry&#39;, &#39;orange&#39;, &#39;kiwi&#39;) 11.3.4 找index用.index('a') thistuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;orange&quot;, &quot;kiwi&quot;, &quot;melon&quot;, &quot;mango&quot;) thistuple.index(&quot;banana&quot;) #&gt; 1 11.3.5 確認每個item有沒有在tuple內也是用in thistuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) if &quot;apple&quot; in thistuple: print(&quot;Yes, &#39;apple&#39; is in the fruits tuple&quot;) #&gt; Yes, &#39;apple&#39; is in the fruits tuple 11.4 [改, 增, 刪] tuple不可修改 tuple是unchangable，所以不能改，不能增，也不能刪 x = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) x[0] = &quot;orange&quot; #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: &#39;tuple&#39; object does not support item assignment #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 如果真的要改，就要先轉成list，再轉回tuple，但有點脫褲子放屁拉 x = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) y = list(x) y[0] = &quot;orange&quot; x = tuple(y) print(x) #&gt; (&#39;orange&#39;, &#39;banana&#39;, &#39;cherry&#39;) 11.5 immutable tuple根本不能改，所以其實不太需要去討論tuple1_copy = tuple1之後，改動tuple1_copy會不會影響到tuple1的問題 11.6 [loop] for回圈 loop index a_tuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) for index in range(len(a_tuple)): print(index) #&gt; 0 #&gt; 1 #&gt; 2 loop items a_tuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) for item in a_tuple: print(item) #&gt; apple #&gt; banana #&gt; cherry loop index &amp; items a_tuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) for index, item in enumerate(a_tuple): print(&quot;index = &quot;, index, &quot;, number in tuple = &quot;, item) #&gt; index = 0 , number in tuple = apple #&gt; index = 1 , number in tuple = banana #&gt; index = 2 , number in tuple = cherry 11.7 [loop] comprehension tuple可以做list comprehension嗎？ 之後再釐清，依樣畫葫蘆的結果，竟然是吐一個generator給我！？ doctor = [&#39;house&#39;, &#39;cuddy&#39;, &#39;chase&#39;, &#39;thirteen&#39;, &#39;wilson&#39;] # 目標：抓出每個element中的第一個字 doc_tuple = (doc[0] for doc in doctor) print(doc_tuple) #&gt; &lt;generator object &lt;genexpr&gt; at 0x13b07cf90&gt; 11.8 join兩個tuple用加號 tuple1 = (&quot;a&quot;, &quot;b&quot; , &quot;c&quot;) tuple2 = (1, 2, 3) tuple3 = tuple1 + tuple2 print(tuple3) #&gt; (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3) "],["dictionary-.html", "Chapter 12 dictionary整理與實戰 12.1 dict的定義 12.2 [建] dict的創建 12.3 [查] 用d.keys(), d.values(), d.items()查詢 12.4 [查] 用d.get(\"key\")來取用dict裡面的item 12.5 [改] 修改dict裡面的item 12.6 [增] 增加dict的item 12.7 [刪] 刪除dict的item 12.8 [mutable] copy 12.9 [loop] for迴圈 12.10 [loop] dictionary comprehension 12.11 如何安全的訪問字典 12.12 How to…", " Chapter 12 dictionary整理與實戰 dictionary是python內建的一種collection 既然是collection，我們就可以把它當資料庫看，所以會依序介紹作為資料庫最基礎的幾個part： 如何建立？ 如何增、刪、查、改？ 這些基礎會了後，就確認一下是否為mutable物件，來決定如何做copy 接著就開始介紹如何loop他(用for, comprehension) 最後就是補齊這個object還沒介紹到的methods 實戰的部分，就會以“How to…”的方式整理常見的需求 12.1 dict的定義 dictionary就是JSON的key-value pair資料表示法(也可想成R的list) dictionary裡面的每個element，我們仍然叫他“item”。所以一個item，就是一組key-value pair my_dict = { &quot;name&quot;: &quot;Hank&quot;, &quot;id&quot;: 19002329, &quot;dept&quot;: &quot;AW0010&quot;, &quot;dog&quot;: True } print(my_dict) #&gt; {&#39;name&#39;: &#39;Hank&#39;, &#39;id&#39;: 19002329, &#39;dept&#39;: &#39;AW0010&#39;, &#39;dog&#39;: True} print(type(my_dict)) #&gt; &lt;class &#39;dict&#39;&gt; dictionary的特性: ordered: 在python 3.7以後，dictionary是ordered; 在python 3.6以前，dictionary是unordered。事實上，我還是傾向將dict看成無順序的，因為我們取用裡面的資料還是用key，不是用座號(index) changeable: 可以改裡面的內容，可以增加，可以刪除 does not allow duplicates dictionary和list的差別在於： dictionary用 {}表示，list用[]表示 dictionary沒有順序性，list有 dictionary一定是key-value的pair，他是index by key(所以你要select他的element，是輸入key); list是index by number(所以你要select他的element，是輸入index number) dictionary的key是immutable，value是mutable，而list全都是mutable 12.2 [建] dict的創建 12.2.1 直接用 創建dictionary時，key必須是immutable，所以key可以是int, string, tupple，但key不可以是list這種mutable a = { 1: &#39;a&#39;, 2: &#39;b&#39;, &#39;3&#39;: &#39;c&#39;, (2,3,4): &#39;haha&#39; } a #&gt; {1: &#39;a&#39;, 2: &#39;b&#39;, &#39;3&#39;: &#39;c&#39;, (2, 3, 4): &#39;haha&#39;} b = { [2,3,4]: &#39;haha&#39;, &#39;two&#39;: 2 } #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: unhashable type: &#39;list&#39; #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; b #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name &#39;b&#39; is not defined #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 12.2.2 用dict(a=2, b=\"haha\")來建立 此外，我們可以用dict()來創建空字典(初始化字典) d = dict() print(d) #&gt; {} d = dict(a=2, b=3, c=&quot;0&quot;) d #&gt; {&#39;a&#39;: 2, &#39;b&#39;: 3, &#39;c&#39;: &#39;0&#39;} 可以看到，這種寫法就和R的 list(a=2, b=3, c=\"0\")一模一樣了 12.2.3 用dict(iterable_pair)來創建 我們可以給dict()一個iterable物件，然後這個物件裡都是一個一個pair 舉例來說這樣： x = [[&#39;a&#39;, 1],[&#39;b&#39;,2]] #x是list，為iterable，裡面的每個element，都是個pair c2 = dict(x) print(c2) #&gt; {&#39;a&#39;: 1, &#39;b&#39;: 2} 那除了用list這種iterable，我們其實更喜歡用tuple，例如這樣： y = ((&#39;a&#39;, 1),(&#39;b&#39;,2)) #x是tuple，為iterable，且裡面的每個element，都是個pair c3 = dict(y) print(c3) #&gt; {&#39;a&#39;: 1, &#39;b&#39;: 2} 有了這兩個基礎後，就可以來學用zip來建立字典了 先來看看zip是什麼 x = [1, 2, 3, 4] y = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] for i in zip(y,x): print(i) #&gt; (&#39;a&#39;, 1) #&gt; (&#39;b&#39;, 2) #&gt; (&#39;c&#39;, 3) #&gt; (&#39;d&#39;, 4) 水喔，所以可以猜測，zip(y,x)的結果，應該就是[(‘a’, 1), (‘b’, 2), (‘c’, 3), (‘d’, 4)]這種iterable object 那所以，我如果想要建立dictionary，就可以： dict(zip(y,x)) #&gt; {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4} 其實，最重要的重點倒不是zip，而是要學會將pair資料轉成dictionary(用dict()) 例如，以後看到下面這種資料結構就不要怕，一秒轉成dictionary tup = ( (&quot;li&quot;, 90), (&quot;wang&quot;, 100), (&quot;cheng&quot;, 73), (&quot;chen&quot;, 44) ) dict(tup) #&gt; {&#39;li&#39;: 90, &#39;wang&#39;: 100, &#39;cheng&#39;: 73, &#39;chen&#39;: 44} 12.3 [查] 用d.keys(), d.values(), d.items()查詢 12.3.1 .keys()可以得到最外層的所有key值 只有一層的dictionary，不易外的就是給我他的key值 d = dict(a=2, b=3, c=&quot;0&quot;) print(d.keys()) #&gt; dict_keys([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) 但像這種nested dictionary，他只會給我最外層的key值 tt = { 1: { 2: {}, 3: {} }, 4: { 5:{ 6:{}, 7:{} } } } tt #&gt; {1: {2: {}, 3: {}}, 4: {5: {6: {}, 7: {}}}} print(tt.keys()) #&gt; dict_keys([1, 4]) 12.3.2 .values()可以得到所有value 對於一層的dictionary，不意外的得到所有values d = dict(a=2, b=3, c=&quot;0&quot;) print(d.values()) #&gt; dict_values([2, 3, &#39;0&#39;]) 對於nested dictionary，他就是print出第二層的東西而已(因為第二層就是第一層的value) print(tt.values()) #&gt; dict_values([{2: {}, 3: {}}, {5: {6: {}, 7: {}}}]) 12.3.3 .items()可以得到(key,value)的tupple dictionary裡面的每個element，我們叫他item。一個item，就是一個key-value pair 所以，不意外的，用.items()可以得到這組pair d = dict(a=2, b=3, c=&quot;0&quot;) print(d.items()) #&gt; dict_items([(&#39;a&#39;, 2), (&#39;b&#39;, 3), (&#39;c&#39;, &#39;0&#39;)]) 12.4 [查] 用d.get(\"key\")來取用dict裡面的item 通常我們在取用dictionary裡面的item時，我們都是給key，求value (因為key是唯一值)，不太會，給value，求key(因為value不唯一) 那通常都是先學到用d['key']來獲取value，用 d['new_key'] = new_value來修改值 但這邊衍伸兩個重點 實務上，不會用d['key']來獲取value，而是用d.get('key')來獲取value，理由等下說明 既然可用d['new_key'] = new_value來更改dictionary，表示dictionary也是mutable，所以他不能當另一個字典的key。例如，你不可寫e = {d: 'haha'}，因為d現在是mutable object了 現在先來講第一個重點，.get的運用 假設我們現在創建一個dictionary d = { &quot;name&quot;: &quot;Hank&quot;, &quot;ok&quot;: &quot;no problem&quot; } d #&gt; {&#39;name&#39;: &#39;Hank&#39;, &#39;ok&#39;: &#39;no problem&#39;} 那我想獲取name所對應的value，傳統上就會這樣寫 d[&#39;name&#39;] #&gt; &#39;Hank&#39; 看起來沒問題。但如果今天我手殘，打成’Name\"，那就會報error d[&#39;Name&#39;] #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: &#39;Name&#39; #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 這在運行程式時，是一個困擾，因為有時候我們不確定有哪些key，但我就都想try try看，那一error程式就停了 所以，用.get('key')時，有抓到的，他會回傳value，沒抓到的，他會回傳None(注意，None是python一個特殊的type，可以想成R的NA這種特殊type) print(d.get(&#39;name&#39;)) #&gt; Hank print(d.get(&#39;Name&#39;)) #&gt; None 12.5 [改] 修改dict裡面的item 要改dictionary裡面的值，可以指定key來改： thisdict = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } thisdict[&quot;year&quot;] = 2018 print(thisdict) #&gt; {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 2018} 也可以用.update()的方法，覆蓋過去 thisdict = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } thisdict.update({&quot;year&quot;: 2020}) print(thisdict) #&gt; {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 2020} 12.6 [增] 增加dict的item 12.6.1 d[\"new_key\"] = new_value 就像剛剛的修改一樣，我們可以指定“新的key”，來做到新增 thisdict = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } thisdict[&quot;color&quot;] = &quot;red&quot; print(thisdict) #&gt; {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 1964, &#39;color&#39;: &#39;red&#39;} 12.6.2 .update()可以合併2個字典 或是，用.update()，直接合併新的資料進來 a = { 1: 1, 2: 2 } b = { 3: 3, 4: 4 } a.update(b) print(a) #&gt; {1: 1, 2: 2, 3: 3, 4: 4} 如果update中的字典，和之前的字典有重複的key，那會直接覆蓋過去(所以，就是做到修改) a = { 1: 1, 2: 2 } b = { 1: 3, 4: 4 } a.update(b) print(a) #&gt; {1: 3, 2: 2, 4: 4} 12.6.3 {**d1, **d2, **d3}合併多個字典 當我們有多個字典時，當然還是可用.update()來兩倆合併，但有點笨： d1 = {&#39;name&#39;: &#39;Python&#39;, &#39;age&#39;: 27} d2 = {&#39;version&#39;: 3.6, &#39;platform&#39;: &#39;Mac&#39;} d3 = {&#39;size&#39;: &#39;59MB&#39;} d1.update(d2) d1.update(d3) print(d1) #&gt; {&#39;name&#39;: &#39;Python&#39;, &#39;age&#39;: 27, &#39;version&#39;: 3.6, &#39;platform&#39;: &#39;Mac&#39;, &#39;size&#39;: &#39;59MB&#39;} 比較好的作法是這樣： d1 = {&#39;name&#39;: &#39;Python&#39;, &#39;age&#39;: 27} d2 = {&#39;version&#39;: 3.6, &#39;platform&#39;: &#39;Mac&#39;} d3 = {&#39;size&#39;: &#39;59MB&#39;} {**d1, **d2, **d3} #&gt; {&#39;name&#39;: &#39;Python&#39;, &#39;age&#39;: 27, &#39;version&#39;: 3.6, &#39;platform&#39;: &#39;Mac&#39;, &#39;size&#39;: &#39;59MB&#39;} 12.7 [刪] 刪除dict的item 12.7.1 .pop('key')會把選定的key整個砍掉，並把對應的value丟出來 b = { 1: 1, 2: 2, 3: 3 } c = b.pop(3) print(c) #&gt; 3 print(b) #&gt; {1: 1, 2: 2} 12.7.2 del d['key']會刪到這組item thisdict = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } del thisdict[&quot;model&quot;] print(thisdict) #&gt; {&#39;brand&#39;: &#39;Ford&#39;, &#39;year&#39;: 1964} 12.8 [mutable] copy 字典也是mutable，所以不能用dict_copy = dict這種方式做複製，因為這樣又會出現改一邊，另一邊跟著改的窘境 所以，作法一樣，用dict_copy = dict.copy()這種方法來做 thisdict = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } mydict = thisdict.copy() print(mydict) #&gt; {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 1964} 12.9 [loop] for迴圈 剛剛已經學過，如果一個字典的object叫d，那 d.keys(): 可以得到所有的key d.values(): 可以得到所有的value d.items(): 可以得到所有的(key, value)所成的tuple 那迴圈時，就可以善用這三招 d = { &#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;, &#39;key3&#39;: &#39;value3&#39; } print(d) #&gt; {&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;, &#39;key3&#39;: &#39;value3&#39;} 12.9.1 loop over keys for key in d.keys(): print(key) #&gt; key1 #&gt; key2 #&gt; key3 12.9.2 loop over values for value in d.values(): print(value) #&gt; value1 #&gt; value2 #&gt; value3 12.9.3 loop over (key, value) for key, value in d.items(): print(key + &quot; -- &quot; + str(value)) #&gt; key1 -- value1 #&gt; key2 -- value2 #&gt; key3 -- value3 12.10 [loop] dictionary comprehension 假設，我今天想用for迴圈來做出一個字典，做法如下 a = [1, 2, 3, 4, 5] b = {} for item in a: b[str(item)] = item print(b) #&gt; {&#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5} 那dictionary comprehension，就是較簡潔的寫法： c = {str(item): item for item in a} print(c) #&gt; {&#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5} 事實上，除了寫法簡潔，performance也快很多 12.11 如何安全的訪問字典 這邊文長，重點也不多(就是推廣用.get()而已)，所以要不要讀都沒差 在python中，如果我們想獲取某個key的value，但key又不小心key錯，或此key不在這個dictionary裡面時，會報error: d = { &#39;name&#39;: &#39;python&#39;, &#39;age&#39;: 27, &#39;version&#39;: 3.7 } print(d[&#39;name&#39;]) #&gt; python print(d[&#39;nam&#39;]) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: &#39;nam&#39; #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 那處理這種問題的方法，有三種： 12.11.1 自己寫條件判斷 這是最hardcore的寫法，很常出現在非python族群的人會寫的內容： def safe_get(my_key, my_dic): if my_key in my_dic: return(my_dic[my_key]) else: return(&#39;error for key&#39;) print(safe_get(&#39;name&#39;, d)) #&gt; python print(safe_get(&#39;nam&#39;, d)) #&gt; error for key 12.11.2 愛用.get() 其實你用.get()，就是幫你做到上面這件事 當key值不在原本的dictionary裡面，預設是return None，那你也可以改 res = d.get(&quot;nam&quot;) print(res is None) #&gt; True res = d.get(&quot;nam&quot;, &quot;error for key&quot;) print(res) #&gt; error for key 12.11.3 改用defaultdict這種type 我們可以改用這種type並事先定義好，找不到key的處理方式: from collections import defaultdict d_new = defaultdict(lambda: &quot;error for key&quot;, d) d_new[&#39;nam&#39;] #&gt; &#39;error for key&#39; defaultdict的第一個argument，就是告訴他，key不在此dictionary時，要return什麼出來 12.12 How to… 12.12.1 如何將字典按照key/value大小排序 假設現在有一個字典如下： d = { &#39;zhao&#39;: 68, &#39;qian&#39;: 80, &#39;sun&#39;: 72, &#39;li&#39;: 90, &#39;zhou&#39;: 83 } 可以把這個字典，想成人名和考試成績的對應 然後，我想照value(考試成績)由高到低排序 那做法上，會先用.items()來做出(key,value) pair，然後再做排序 先看一下d.items()長怎樣： print(d.items()) #&gt; dict_items([(&#39;zhao&#39;, 68), (&#39;qian&#39;, 80), (&#39;sun&#39;, 72), (&#39;li&#39;, 90), (&#39;zhou&#39;, 83)]) print(type(d.items())) #&gt; &lt;class &#39;dict_items&#39;&gt; 可以得知，這是一個iterable object，外觀看起來像list，裡面每個element是key-value pair tuple 但他真實的type不是list，是dict_items 我們可以選擇用sorted(iterable, key)這種方式做排序，或把它轉成list後，用.sort(key)來做排序 12.12.1.1 用通用版的function: sorted() sorted( d.items(), # 我要將此iterable做排序 key = lambda x: x[1] # 怎麼排？令這個iterable的一個element叫x， # 我要對他的第二個元素: x[1]做排序 ) #&gt; [(&#39;zhao&#39;, 68), (&#39;sun&#39;, 72), (&#39;qian&#39;, 80), (&#39;zhou&#39;, 83), (&#39;li&#39;, 90)] 從結果來看，可知道已順利依照value由小排到大 如果要由大到小，就加上reverse = True這個argument就好 sorted(d.items(), key = lambda x: x[1], reverse = True) #&gt; [(&#39;li&#39;, 90), (&#39;zhou&#39;, 83), (&#39;qian&#39;, 80), (&#39;sun&#39;, 72), (&#39;zhao&#39;, 68)] 舉一反三，如果要對key的大小做排序(依姓氏排序)，那就是： sorted(d.items(), key = lambda x: x[0]) #&gt; [(&#39;li&#39;, 90), (&#39;qian&#39;, 80), (&#39;sun&#39;, 72), (&#39;zhao&#39;, 68), (&#39;zhou&#39;, 83)] ok，那回到原來的目的，依照value由大到小排序，且轉回dictionary dict(sorted(d.items(), key = lambda x: x[1], reverse = True)) #&gt; {&#39;li&#39;: 90, &#39;zhou&#39;: 83, &#39;qian&#39;: 80, &#39;sun&#39;: 72, &#39;zhao&#39;: 68} 12.12.1.2 用list專用的method: .sort(key) 剛剛知道，d.items()的結果很像list，但不是list，所以我先轉成list後，再排序 item_list = list(d.items()) print(item_list) #&gt; [(&#39;zhao&#39;, 68), (&#39;qian&#39;, 80), (&#39;sun&#39;, 72), (&#39;li&#39;, 90), (&#39;zhou&#39;, 83)] print(type(item_list)) #&gt; &lt;class &#39;list&#39;&gt; 接著就很簡單了，用學過的.sort(key = ..., reverse = True)來處理 item_list.sort( key = lambda x: x[1], #key就是function的意思，我先用這function算出結果，才用結果做排序 reverse = True ) print(item_list) #&gt; [(&#39;li&#39;, 90), (&#39;zhou&#39;, 83), (&#39;qian&#39;, 80), (&#39;sun&#39;, 72), (&#39;zhao&#39;, 68)] "],["set-.html", "Chapter 13 set應用實戰 13.1 定義set 13.2 [查] 只能用for loop與in 13.3 [改] set無法做修改 13.4 [刪] .remove()與.discard() 13.5 [增] .add()與.update() 13.6 [mutable] 請愛用.copy() 13.7 [loop] for 13.8 [loop] comprehension 13.9 [特殊技] 集合運算 13.10 [特殊技] 對list取unique 13.11 [特殊技] 將字串中unique character轉成list", " Chapter 13 set應用實戰 set是python內建的一種collection 既然是collection，我們就可以把它當資料庫看，所以會依序介紹作為資料庫最基礎的幾個part： 如何建立？ 如何增、刪、查、改？ 這些基礎會了後，就確認一下是否為mutable物件，來決定如何做copy 接著就開始介紹如何loop他(用for, comprehension) 最後就是補齊這個object還沒介紹到的methods 實戰的部分，就會以“How to…”的方式整理常見的需求 13.1 定義set 集合就是只有key，沒有value的dictionary 例如，以下是dictionary my_dict = { &#39;a&#39;: 1, &#39;b&#39;: 5 } print(my_dict) #&gt; {&#39;a&#39;: 1, &#39;b&#39;: 5} 而，以下就是set my_set = {&#39;a&#39;, &#39;b&#39;} print(my_set) #&gt; {&#39;b&#39;, &#39;a&#39;} set的特點，其實和dictionary的key的特點一樣(也和數學上的集合的特點一樣)，就是’唯一’和’無序’。 唯一就是key值唯一，你多給他重複的key，他也幫你刪掉。無序就是你每次print的時候，他順序都會亂跳，所以你有不能用index的方法來獲取set裡面的element 13.2 [查] 只能用for loop與in 因為set又沒有list/tuple的index，也沒有dictionary的key，所以你既不能用set1[index]來取資料，也不能用set1['key']來取資料 所以，只能做兩件事： 用for迴圈來loop看看總共有哪些item 用in來確認，你指定的item有沒有在這個set裡面 thisset = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} for x in thisset: print(x) #&gt; apple #&gt; cherry #&gt; banana check “banana”是否在這個set中 thisset = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} print(&quot;banana&quot; in thisset) #&gt; True 13.3 [改] set無法做修改 set無法做修改的原因，是因為他無法取出你指定的那個item，所以他無法像list那樣，用list1[index] = new_value，也無法像dictionary那樣，用dic1['key'] = new_value來做修改 但set可以做刪除和新增。所以如果一個set是{\"apple\", \"banana\", \"orange\"}，那我想把“banana”改成“kiwi”，那就是刪除“banana”，再新增“kiwi”就好 13.4 [刪] .remove()與.discard() .remove()和.discard()的差別，是在remove一個不存在的值時，他會跳error，但discard一個不存在的值時，他就裝沒事而已 thisset = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} thisset.remove(&quot;banana&quot;) print(thisset) #&gt; {&#39;apple&#39;, &#39;cherry&#39;} thisset = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} thisset.remove(&quot;kiwi&quot;) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: &#39;kiwi&#39; #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; thisset = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} thisset.discard(&quot;banana&quot;) print(thisset) #&gt; {&#39;apple&#39;, &#39;cherry&#39;} thisset = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} thisset.discard(&quot;kiwi&quot;) print(thisset) #&gt; {&#39;apple&#39;, &#39;cherry&#39;, &#39;banana&#39;} 13.5 [增] .add()與.update() 13.5.1 增加一個item用.add() thisset = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} thisset.add(&quot;orange&quot;) print(thisset) #&gt; {&#39;apple&#39;, &#39;cherry&#39;, &#39;orange&#39;, &#39;banana&#39;} 13.5.2 增加多個item用.update() thisset = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} tropical = {&quot;pineapple&quot;, &quot;mango&quot;, &quot;papaya&quot;} thisset.update(tropical) print(thisset) #&gt; {&#39;mango&#39;, &#39;cherry&#39;, &#39;banana&#39;, &#39;pineapple&#39;, &#39;apple&#39;, &#39;papaya&#39;} 如果update的東西，裡面有和原本重複的值，那就只會留一個，因為set就是unique thisset = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} tropical = {&quot;apple&quot;, &quot;banana&quot;, &quot;papaya&quot;} thisset.update(tropical) print(thisset) #&gt; {&#39;cherry&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;papaya&#39;} 13.6 [mutable] 請愛用.copy() set也是mutable，所以以下慘劇會重現： set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;} set1_copy = set1 set1_copy.remove(&quot;apple&quot;) print(set1_copy) #&gt; {&#39;orange&#39;, &#39;banana&#39;} print(set1) #&gt; {&#39;orange&#39;, &#39;banana&#39;} 記得用.copy()來解決問題 set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;} set1_copy = set1.copy() set1_copy.remove(&quot;apple&quot;) print(set1_copy) #&gt; {&#39;orange&#39;, &#39;banana&#39;} print(set1) #&gt; {&#39;apple&#39;, &#39;orange&#39;, &#39;banana&#39;} 13.7 [loop] for 這邊就沒什麼，你只能loop他的item: set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;} for item in set1: print(item) #&gt; apple #&gt; orange #&gt; banana 13.8 [loop] comprehension set可以看成簡化版的dictionary，那既然可以做dictionary comprehension，就應該可以做set comprehension set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;} set2 = {item for item in set1} print(set2) #&gt; {&#39;apple&#39;, &#39;orange&#39;, &#39;banana&#39;} 13.9 [特殊技] 集合運算 set可以做數學上的交集(&amp;)、聯集(|)、差集(-)、補集(^) s1 = {1,2,3,4} s2 = {3,4,5,6} print(s1 &amp; s2) #&gt; {3, 4} print(s1 | s2) #&gt; {1, 2, 3, 4, 5, 6} print(s1 - s2) #是s1，但不是s2 #&gt; {1, 2} print(s1 ^ s2) #&gt; {1, 2, 5, 6} 13.10 [特殊技] 對list取unique 例如我有一個list，我想取出unique的值： l = [1,2,3,2,4,5,2] l_unique = list(set(l)) print(l_unique) #&gt; [1, 2, 3, 4, 5] 13.11 [特殊技] 將字串中unique character轉成list 這招蠻牛的，看一下例子就會了 my_string = &quot;aabbcdefg&quot; string_to_set = set(my_string) print(string_to_set) #&gt; {&#39;d&#39;, &#39;a&#39;, &#39;e&#39;, &#39;f&#39;, &#39;c&#39;, &#39;b&#39;, &#39;g&#39;} "],["none.html", "Chapter 14 None 14.1 定義 14.2 is None 14.3 使用時機", " Chapter 14 None 14.1 定義 沒有value的變數，我們叫他沒有值(None)，我們可以把它想成excel中的空白，或是R中的NULL 與他對比的叫空值，空值還是有值，只是他的值是空白 a = None，這個a是沒有值，因為他沒有value a = ''，這個a是空值，因為他還是有value，他的value是空的string a = []，這個a也是空值，他的值是空的list a = 0，這個a就不是空值了，因為他的值是0 14.2 is None 要確認一個變數，是None還是空值，就用is None做確認(就像R得is.null()一樣) a = None print(a is None) #&gt; True b = &#39;&#39; print(b is None) #&gt; False 或是，你用print()也可以發現差別： a = None a # 他啥都不會顯示 b = &#39;&#39; b # 會顯示 &#39;&#39; #&gt; &#39;&#39; 14.3 使用時機 這邊我覺得還要再補充，目前先寫下udemy舉到的應用(但我覺得不是很滿意) 14.3.1 與資料庫互動 假設我們今天在和資料庫互動時，想把query後的結果存在result這個變數，那有可能我query後的結果，是個空值(e.g. 我查過年期間，工廠有在生產的model名稱，可能查出空集合，所以回傳給我一個空值)，也有可能我query的時候，資料庫根本沒連線成功，所以回我error 那為了讓程式繼續跑下去，不要因為error而停下，那我們就會在error的時候，把query的結果定為None，那我就知道： “result = 空值”表示沒資料，“result = None”表示連線失敗 見以下的程式範例： def test_connection(): # 寫些條件判斷，來確認有沒有順利和DB連接上 # 有的話，回傳True # 現在先假設判斷完的結果是True return True def get(): # 寫個statement，去DB中抓取我要的user名單 # 例如這兩天有登入我們網站的人員名單 # 那假設抓完的結果，就很不巧，沒有條件符合，所以是： [] return [] def get_user_list(): # 完整的抓user名單的function # 會先判斷DB有沒有連線成功，有的話，才抓 if not test_connection(): return None else: return get() 接下來，開始使用這個function了，我們想回傳給user訊息： 如果連線成功，回傳query到的結果 如果連線失敗，回傳“connection error” query_result = get_user_list() if query_result is None: print(&quot;connection error&quot;) else: print(&quot;user list: &quot;, query_result) #&gt; user list: [] "],["boolean-.html", "Chapter 15 boolean整理與實戰 15.1 大部分的value，轉成boolean都是True 15.2 少部分value，轉成boolean會是False 15.3 搭配if statement", " Chapter 15 boolean整理與實戰 boolean就True/False兩種，主要用在條件判斷時使用 雖然只有True/False兩種，聽起來很簡單，但還是蠻多細節可以講的 15.1 大部分的value，轉成boolean都是True str轉成boolean會是True，除非是空的string int, float轉成boolean會是True，除非是0 list, tuple, set, dic轉成boolean都是True，除非是空值 bool(&quot;abc&quot;) #&gt; True bool(123) #&gt; True bool(123.123) #&gt; True bool([&quot;apple&quot;, &quot;cherry&quot;, &quot;banana&quot;]) #&gt; True 15.2 少部分value，轉成boolean會是False 就如同上面的舉例，你是以下三種狀況，那轉成boolean，會是False 沒有值(None) 空值(e.g. \"\", [], {},…) 0 example = [ None, &quot;&quot;, [], (), {}, 0 ] for i in example: res = bool(i) print(f&quot;{i} transform to boolean will be {res}&quot;) #&gt; None transform to boolean will be False #&gt; transform to boolean will be False #&gt; [] transform to boolean will be False #&gt; () transform to boolean will be False #&gt; {} transform to boolean will be False #&gt; 0 transform to boolean will be False 15.3 搭配if statement 如果要做： “if 一個list是空值，我就…”，那可以這樣寫： a = [] if not a: # a 是[]時，轉成 boolean 會是False，所以加個not就變True了 print(&quot;a is empty&quot;) #&gt; a is empty 當然，你還是可以用土法煉鋼的寫法，但在Python社群就很少人這樣寫了： a = [] if a == []: print(&quot;a is empty&quot;) #&gt; a is empty "],["conditional-operators.html", "Chapter 16 Conditional Operators", " Chapter 16 Conditional Operators 可以製作出True/False結果的operations有很多，這邊整理一下： 16.0.1 ==, !=, &gt;=, &lt;= 這些operator，我們稱為comparison operators，適用於數值型資料： 比大小： a == b, a != b, a &lt; b, a &lt;= b, a &gt; b, a &gt;=b 餘數類： a % 3 == 0 只想看商： a // 3 == 1 a = 33 b = 200 if b &gt; a: print(&quot;b is greater than a&quot;) #&gt; b is greater than a 16.0.2 and, or, not 這種operator，我們稱為logical operators，適用於連接多個condition logical operators就是 and, or, not，對應到R的&amp;, |, ! a = 200 b = 33 c = 500 if a &gt; b and c &gt; a: print(&quot;Both conditions are True&quot;) #&gt; Both conditions are True if a &gt; b or a &gt; c: print(&quot;At least one of the conditions is True&quot;) #&gt; At least one of the conditions is True if not(b &gt; a): print(&quot;a is greater or equal to b&quot;) #&gt; a is greater or equal to b 16.0.3 in, not in 這種operator稱為membership operator，適用於判斷某個item是否是別人的子集 x in y, x not in y 16.0.4 is, is not 這種operator，我們稱為identity operator，適用於判斷資料是不是某種資料類型，或是兩個object是否相同 看x和y是否為相同的object，可以用 x is y "],["if-statement.html", "Chapter 17 If statement 17.1 if… 17.2 if…else… 17.3 if…elif…else… 17.4 一行的if 17.5 一行的if…else… 17.6 善用pass 17.7 if 條件太多時，怎麼優化", " Chapter 17 If statement if在python中有三種寫法 if… if…else… if…elif…else… 一行的if 一行的if…else… 17.1 if… a = 88 if a &gt; 8: print(&#39;yeah&#39;) #&gt; yeah 17.2 if…else… a = 7 if a &gt; 8: print(&#39;yeah&#39;) else: print(&#39;no&#39;) #&gt; no 17.3 if…elif…else… a = 200 b = 33 if b &gt; a: print(&quot;b is greater than a&quot;) elif a == b: print(&quot;a and b are equal&quot;) else: print(&quot;a is greater than b&quot;) #&gt; a is greater than b 17.4 一行的if a = 200 b = 33 if a &gt; b: print(&quot;a is greater than b&quot;) # 就是不要換行就好，其他不變 #&gt; a is greater than b 17.5 一行的if…else… 這招在list comprehension時又會用到，訣竅就是要倒裝： 做這個 if這樣，不然(else)就做那個… a = 2 b = 330 print(&quot;A&quot;) if a &gt; b else print(&quot;B&quot;) #&gt; B 17.6 善用pass 這個技巧也可以學一下，if裡面不可以是空的，但如果因為some reason，你就是需要寫if，那你就塞一個pass在裡面，就不會報error了 a = 33 b = 200 if b &gt; a: pass 17.7 if 條件太多時，怎麼優化 我覺得這邊可以補充“地表最簡單Python”那門課的練習，有講到寫多個if時比較好的做法 "],["for-loop.html", "Chapter 18 for loop 18.1 寫法 18.2 善用break終止迴圈 18.3 善用continue跳入下一個迴圈", " Chapter 18 for loop 18.1 寫法 for i in range(10): print(i) #&gt; 0 #&gt; 1 #&gt; 2 #&gt; 3 #&gt; 4 #&gt; 5 #&gt; 6 #&gt; 7 #&gt; 8 #&gt; 9 18.2 善用break終止迴圈 直接看例子： for i in range(10): if i &lt; 5: print(i) else: print(f&quot;i = {i}, value &gt;=5, stop!!&quot;) break #&gt; 0 #&gt; 1 #&gt; 2 #&gt; 3 #&gt; 4 #&gt; i = 5, value &gt;=5, stop!! 18.3 善用continue跳入下一個迴圈 有時候我們不希望直接跳出迴圈，而是ignore這一圈，直接進入下一圈，例如下例： for i in range(10): if i % 2 == 0: # 除以2的餘數==0 continue print(i) #&gt; 1 #&gt; 3 #&gt; 5 #&gt; 7 #&gt; 9 "],["while-loop.html", "Chapter 19 while loop 19.1 while 寫法 19.2 確認每次都有更新內容 19.3 善用break", " Chapter 19 while loop 19.1 while 寫法 a = 10 while a &gt; 5: print(f&quot;&#39;a&#39; is {a} currently&quot;) a -= 1 #&gt; &#39;a&#39; is 10 currently #&gt; &#39;a&#39; is 9 currently #&gt; &#39;a&#39; is 8 currently #&gt; &#39;a&#39; is 7 currently #&gt; &#39;a&#39; is 6 currently print(&#39;end&#39;) #&gt; end 19.2 確認每次都有更新內容 while最怕的就是無限迴圈，所以寫while時，條件中的內容，在每次的循環中，通常都會更新，例如以下： a = 10 while a &gt; 5: print(a) a = a - 1 # 若沒做這個更新，那就會陷入無限迴圈 #&gt; 10 #&gt; 9 #&gt; 8 #&gt; 7 #&gt; 6 print(&#39;end&#39;) #&gt; end 19.3 善用break 為了避免進入無限迴圈，while裡面也常常加入break，來強制停止它 例如做參數更新時，可能可以寫成以下這樣： i = 0 est_value = 10 true_value = 10000 while true_value - est_value &gt; 0.01: est_value +=1 i +=1 if i == 100: break print(est_value) #&gt; 110 print(i) #&gt; 100 "],["function101.html", "Chapter 20 function101 20.1 function的結構 20.2 Docstring的標準格式 20.3 先檢驗argument的合法性 20.4 記得return 20.5 default argument", " Chapter 20 function101 20.1 function的結構 function的 3+1 個part function header: 這個function的名稱 Docstrings: 開頭註解，用三引號夾起來，並照PEP8格式，寫下Purpose, Args, Returns, Raises這四個component (其中的Raises是指，什麼狀況下要給error) function body: 這個function的內容 output出什麼: 這是optional，你可以只做side-effect(e.g. 寫入資料庫)，但不output出東西。若要output出東西，可以output一個object(e.g. tuple)或ouptut出一個新的function(i.e. clousure，見nested function那章) 以下是一個簡單但完整的function def square(value): # &lt;- Function header # &lt;- Docstrings are below &quot;&quot;&quot; Purpose: Return the square of a value Args: value (int/float): the number to be squared Returns: int/float Raises: ValueError: If `value` is not int/float &quot;&quot;&quot; # Function body if (not type(value) is int) and (not type(value) is float): raise TypeError(&quot;`value` must be the type of int/float&quot;) new_value = value**2 # output return new_value 20.2 Docstring的標準格式 從上例可以看到docstring的標準格式 對開發者來說，他看到你的source code，就可以很清楚的知道function的目的, 參數, output, 以及什麼時候會給error 對user來說，他雖然看不到你寫的註解，但他只要下help，就可以輕易看到這些內容： help(square) #&gt; Help on function square in module __main__: #&gt; #&gt; square(value) #&gt; Purpose: #&gt; Return the square of a value #&gt; Args: #&gt; value (int/float): the number to be squared #&gt; Returns: #&gt; int/float #&gt; Raises: #&gt; ValueError: If `value` is not int/float 20.3 先檢驗argument的合法性 此外，也可以看到比較professional的function寫法，會在一開始就檢驗你丟進來的arguments是否符合要求，不符合就報錯，來避免不必要的bug 所以，我們測試一下就知道了： print(square(3)) #&gt; 9 print(square(1.4)) #&gt; 1.9599999999999997 print(square(&#39;haha&#39;)) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: `value` must be the type of int/float #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; #&gt; File &quot;&lt;string&gt;&quot;, line 16, in square 詳細的error handling寫法，會在下一個章節介紹 20.4 記得return 特別注意，如果要return value出來，最後一定要加return，不能像R偷懶，以為最後一行就會自己return出來 20.5 default argument 這很easy拉，就簡單給個例子就好 def power(number, pow = 1): &quot;&quot;&quot;Raise number to the power of pow.&quot;&quot;&quot; new_value = number ** pow return new_value print(power(9, 2)) #&gt; 81 print(power(9)) #&gt; 9 要特別注意的是，default argument一定要放到最後面，不可以放到前面 "],["exception-handling.html", "Chapter 21 Exception Handling 21.1 各種異常介紹 21.2 raise XXXError(\"error message herer\") 21.3 try...except...", " Chapter 21 Exception Handling 在python中，我們看到的Error，就叫異常(exception) 異常分兩種： 系統內建的異常： 例如ValueError(), TypeError(),… 自己定義的異常 那總結一下這章要講的重點： [異常] 先介紹各種異常 [處理] function在運行時，我想主動卡控東西，若違反我的規則，我要主動丟error出去 -&gt; raise XXXError(\"error message here\") [處理] function在運行時，若出現不可預知的error，我們該怎麼處理？ -&gt; try: ..., except: ... 21.1 各種異常介紹 21.1.1 AttributeError 在python中，所有東西都是object，都有自己的屬性(attribute)。 那如果你今天call某個object一個不屬於他的屬性，那就會丟AttributeError 例如下例，os裡面沒有.test這個屬性，所以你call他就會報錯： import os os.test #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): AttributeError: module &#39;os&#39; has no attribute &#39;test&#39; #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 21.1.2 ModuleNotFoundError 如果我們在import一個module時，沒有這個module，那就會報ModuleNotFoundError import hank_module #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): ModuleNotFoundError: No module named &#39;hank_module&#39; #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; #&gt; File &quot;/Users/hanklee/Library/Application Support/renv/cache/v5/R-4.0/x86_64-apple-darwin17.0/reticulate/1.18/fbd35cac6ae7554d0e4f440bca1adf3a/reticulate/python/rpytools/loader.py&quot;, line 19, in _import_hook #&gt; module = _import( 21.1.3 IndexError 如果某個list的長度只有1，你卻要取用他index=2，那就會報IndexError a = [&quot;hank&quot;] a[2] #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): IndexError: list index out of range #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 21.1.4 KeyError 訪問字典時，key寫錯了，沒有這個key a = {&quot;name&quot;: &quot;hank&quot;} a[&#39;salary&#39;] #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: &#39;salary&#39; #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 21.1.5 NameError call一個沒有被定義過的變數 a = hank * 2 #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name &#39;hank&#39; is not defined #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 21.1.6 ZeroDivisionError 把0當除數時，會報的error 3/0 #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): ZeroDivisionError: division by zero #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 21.1.7 自定義的error 其實剛剛介紹的各種Error，都是繼承自Exception這個class，簡單驗證一下： a = TypeError(&quot;type is wrong&quot;) print(isinstance(a, TypeError)) #&gt; True print(isinstance(a, Exception)) #&gt; True 如果我們在pycharm裡，按ctrl/command，再把滑鼠點到程式碼中的TypeError，他會開啟TypeError的source code，就可以看到第一行他就在做繼承 class TypeError(Exception): # ... 所以，要寫我自己定義的error，就依樣畫葫蘆就好： class MyException(Exception): pass raise MyException(&quot;這是我定義的異常&quot;) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): MyException: 這是我定義的異常 #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 21.2 raise XXXError(\"error message herer\") 上一章講function時，有建議養成習慣，在function的一開始，都先確認input argument是否合法，若不合法，直接報error，不用再繼續做下去 那這在R裡面，就是寫個條件判斷，若不合法，就做stop(\"error message\") 而在Python裡面，我們已經知道Error都要加上error type才完整，所以大概會寫成這樣： raise XXXError(\"error message\") 可以看到，和R的差別，就是多個raise，以及XXX 來看例子： def square(value): if (not type(value) is int) and (not type(value) is float): raise TypeError(&quot;`value` must be the type of int/float&quot;) new_value = value**2 # output return new_value 可以看到上例，如果輸入的value，不是數值型資料(i.e. int/float)，那就報錯 這邊可以注意，你要報什麼類型的錯，其實隨你高興，你要寫raise ValueError(\"error message\")，python也不會管你，這只是你要寫給user看得東西而已。 來試試看管不管用： print(square(3)) #&gt; 9 print(square(1.4)) #&gt; 1.9599999999999997 print(square(&#39;haha&#39;)) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: `value` must be the type of int/float #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; #&gt; File &quot;&lt;string&gt;&quot;, line 4, in square 21.3 try...except... 就像if…else…有多種寫法一樣，try…except也是，以下寫出最複雜的例子，記得除了try和except一定要以外，其他都是可有可無 try: # 執行一段可能報error的code except: # 如果發生error，執行此處的code else: # 如果沒發生error，執行此處的code finally: # 不管有沒有發生error，最後都得執行此處的code 21.3.1 基本款：只寫except try...except...其實就是R裡面的tryCatch，通常是碰到我們不想停下來的錯誤時，而做的處理(如果是嚴重錯誤，必須直接跳出的話，就會用raise XXError(\"error message\")) 舉個例子，我如果沿用剛剛square function，去算大量的數據時： input_list = [2, 3.5, 7, &#39;4&#39;, 8, 10] res = [] for item in input_list: temp_res = square(item) res.append(temp_res) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: `value` must be the type of int/float #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 2, in &lt;module&gt; #&gt; File &quot;&lt;string&gt;&quot;, line 4, in square 會發現報了error之後，後面的東西全都停掉了 但我更傾向，不要報error，而是隨便塞個東西進去，然後print個message讓我知道哪裡出錯就好，那我就可以改成這樣寫： input_list = [2, 3.5, 7, &#39;4&#39;, 8, 10] res = [] for item in input_list: try: temp_res = square(item) res.append(temp_res) except: res.append(None) print(f&quot;input = {item} occurs error!!&quot;) #&gt; input = 4 occurs error!! print(&quot;The result is: &quot;, res) #&gt; The result is: [4, 12.25, 49, None, 64, 100] 那我的程序就可以順利跑完，得到result，並把發生錯誤的項目print在log裡讓我們知道。 再舉個例子，我有個function，想要input一串數字，然後output出哪些數是100的因數： def factor_100(my_list): res = [] for item in my_list: if 100 % item == 0: res.append(item) return(res) print(factor_100([2, 5, 7])) #&gt; [2, 5] print(factor_100([2, 5, 7, 0])) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): ZeroDivisionError: integer division or modulo by zero #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; #&gt; File &quot;&lt;string&gt;&quot;, line 4, in factor_100 從上面的例子可以看到，第二次嘗試時，因為丟了0進去，所以誘發了ZeroDivisionError，表示0不可以放分母。 但…，我們其實不希望丟這個error出來，因為對於0這種數，他就不會是因數，所以我希望碰到error就跳過 def factor_100(my_list): res = [] for item in my_list: try: # 可能發生error的那句statement放這 if 100 % item == 0: res.append(item) except: # 碰到error時，run這裡 print(&quot;0不能當除數拉！！&quot;) return(res) print(factor_100([2, 5, 7])) #&gt; [2, 5] print(factor_100([2, 5, 7, 0])) #&gt; 0不能當除數拉！！ #&gt; [2, 5] 21.3.2 進階款： except XXerror 剛剛這樣寫好像很棒了，但如果你試試run以下的code: print(factor_100([2, 5, 7, &#39;hank&#39;])) #&gt; 0不能當除數拉！！ #&gt; [2, 5] 會發現…wtf，我input的東西哪裡有0？問題是出在我丟一個字串(“hank”)進去了 所以，except後面其實還可以接：碰到哪種error時，執行我。那我就可以寫“碰到ZeroDivisionError時，怎樣怎樣”; “碰到TypeError時，怎樣怎樣” def factor_100(my_list): res = [] for item in my_list: try: # 可能發生error的那句statement放這 if 100 % item == 0: res.append(item) except ZeroDivisionError: # 碰到error時，run這裡 print(&quot;0不能當除數拉！！&quot;) except TypeError: # 碰到error時，run這裡 print(&quot;請你輸入int/float的資料類型&quot;) except: print(&quot;我實在不知道哪裡出錯了，但反正跳過&quot;) return(res) print(factor_100([2, 5, 7])) #&gt; [2, 5] print(factor_100([2, 5, 7, 0])) #&gt; 0不能當除數拉！！ #&gt; [2, 5] print(factor_100([2, 5, 7, &quot;hank&quot;])) #&gt; 請你輸入int/float的資料類型 #&gt; [2, 5] 21.3.3 懶人款: except Exception as e 剛剛的except，把各種type的error都考慮進去了，很棒棒沒錯，但實務上，我們常常也不知道會碰到什麼error 所以，我們可以改成這樣寫：except Exception as e，意思是，我要except掉所有的Exception object，也就是所有type的Error，並且，as e表示我還把這個object給存起來，那我後續搭配print(e)，就可以看到所屬的type和所屬的error message了： def factor_100(my_list): res = [] for item in my_list: try: # 可能發生error的那句statement放這 if 100 % item == 0: res.append(item) except Exception as e: print(e) return(res) print(factor_100([2, 5, 7])) #&gt; [2, 5] print(factor_100([2, 5, 7, 0])) #&gt; integer division or modulo by zero #&gt; [2, 5] print(factor_100([2, 5, 7, &quot;hank&quot;])) #&gt; unsupported operand type(s) for %: &#39;int&#39; and &#39;str&#39; #&gt; [2, 5] 但我現在想要給user更多資訊，讓user知道，到底我遇到哪種type的error "],["flexible-arguments.html", "Chapter 22 flexible arguments 22.1 *args 22.2 **kwargs", " Chapter 22 flexible arguments 22.1 *args *args是flexible arguments的縮寫，星號就把它翻譯成flexible就對了 他的意思是，你可以很彈性的，要丟幾個argument進來，就丟幾個進來。 舉例來說，我想寫一個加總的function，user丟3個數字進來，我就幫他加總3個，user丟9個數字進來，我就幫他加總9個，所以其實一開始我沒辦法訂好我的function要幾個參數，那我就把參數名稱定義成*args，來代表user想丟幾個進來都可以(事實上，只要星號開頭即可，星號後你要寫啥都沒關係，例如*a, *abcd都可以，因為星號就代表flexible，只是習慣上大家喜歡寫*args，因為照字面意義就知道他是flexible arguments) 一旦你把參數定成*args，它吃進function後，就會先把這堆args串成list，並命名為args，所以在你的function內，可以調用args這個object 直接看例子： def add_all(*args): &quot;&quot;&quot;Sum all values in *args together.&quot;&quot;&quot; ### Initialize sum sum_all = 0 # Accumulate the sum for num in args: # args就是把user丟的所有arguments串成一個list，讓你使用 sum_all = sum_all + num return sum_all print(add_all(1,2,3)) #&gt; 6 print(add_all(1,2,3,4,5)) #&gt; 15 22.2 **kwargs **kwargs是flexible keyword arguments 的縮寫 剛剛的*args，都是直接丟argument進來，沒有寫明他是哪個參數，而**kwargs，就會寫成key-value pair的輸入 也因為現在的input都是key-value pair了，所以python會把user丟進來的東西，先存成kwargs這個dictionary，然後我們再用這個dictionary來工作： def print_all(**kwargs): &quot;&quot;&quot;Print out key-value pairs in **kwargs.&quot;&quot;&quot; # Print out the key-value pairs for key, value in kwargs.items(): print(key + &quot;: &quot; + value) print_all( name = &quot;Hank Lee&quot;, job = &quot;Data Scientist&quot;, height = &quot;184&quot;, weight = &quot;80&quot; ) #&gt; name: Hank Lee #&gt; job: Data Scientist #&gt; height: 184 #&gt; weight: 80 如果今天定義的是：**haha，那dictionary就會存在haha裡 22.2.1 使用時機 **kwargs其實就類比於R的...參數，他特別適用在，你的function中要去call別的function，但不想逐一寫下別的function的arguments 例如，我先定義一個function叫my_sum def my_sum(a, b): return(a+b) 那我如果現在定義一個新的function，叫conditional_sum，要給他一個參數x，如果x是True，我才要做sum: def conditional_sum(x, **kwargs): if x: return(my_sum(**kwargs)) else: return(&quot;do not calculate&quot;) print(conditional_sum(x = True, a = 3, b = 5)) #&gt; 8 print(conditional_sum(x = False, a = 3, b = 5)) #&gt; do not calculate 特別注意的是，**kwargs一定要放在arguments的最後面，如果寫：def conditional_sum(**kwargs, x)，那會直接error給你看 "],["recursion.html", "Chapter 23 recursion 23.1 n! 計算 23.2 費氏數列", " Chapter 23 recursion recursion(遞迴)在programming中的意思是：在函數中，呼叫函數自己，比如這樣： def my_func(num): 3 + my_func(num) 寫recursion時要很小心，因為他是個雙面刃： 寫的好：code很簡潔，執行效率又高 寫不好：無限迴圈無法停止(如上例)，耗費所有電腦資源 recursion有兩個經典例子，一個是n!的計算，另一個是費氏數列，我們來看看： 23.1 n! 計算 如果今天想做個n!的function，我們可以用for來做 def test(n): result = 1 for item in range(1, n+1): result = result * item return result test(3) #&gt; 6 但如果你用recursion，就會很簡單 def test2(n): if n == 1: return n else: return n * test2(n-1) print(test2(3)) #&gt; 6 我們先看recursion的第一個重點，也就是n * test2(n-1)這一行 所以當我輸入n=3時，他會做3 * test2(2) = 3 * 2 * test2(1) = 3*2*1*test2(0) = 3*2*1*0*test2(-1) = … 看起來，前面都做對了，但等到test2(0)時就錯了 所以，recursion會需要加上何時跳出這個條件。所以前面加了if n == 1: return n，那上面的遞迴式，就變成: 3 * test2(2) = 3 * 2 * test2(1) = 3*2*1 ，沒辦法再遞迴了，結束在這 23.2 費氏數列 費氏數列的定義是: \\(a_1 = 0, \\ a_2 = 1\\) \\(a_n = a_{n-1} + a_{n-2}\\)，for n &gt;3 也就是前兩項是0,1，之後各項的值，是前兩項的和。 比如說： 0, 1, 1, 2, 3, 5, 8, … 那我想寫一個function，告訴我第k項的值是多少： def fibo(k): if k == 1: return 0 elif k == 2: return 1 else: return fibo(k-1) + fibo(k-2) print(fibo(5)) #&gt; 3 "],["nested-function-and-closure.html", "Chapter 24 Nested Function and closure 24.1 Nested function 24.2 Closure", " Chapter 24 Nested Function and closure nested function蠻簡單的，就是一個function中，又定義了另一個function closure的意思則是，一個function要return的東西，不是一個值，而是另一個function 24.1 Nested function 就像我們在main script上，同一種pattern的code，複製貼上三次，就會想寫一個function一樣，如果我今天在自己定義的function中，同一種pattern的code，也複製貼上三次，那我就會想寫一個inner function 這個inner function，就叫nested function 先來看醜醜的例子： def mult2plus5(x1, x2, x3): &quot;&quot;&quot;multiply 2 thenplus 5 for input three values.&quot;&quot;&quot; new_x1 = x1 * 2 + 5 new_x2 = x2 * 2 + 5 new_x3 = x3 * 2 + 5 return (new_x1, new_x2, new_x3) print(mult2plus5(2,3,4)) #&gt; (9, 11, 13) 改寫成nested function的例子 def mult2plus5_nested(x1, x2, x3): def inner(x): value = x*2 + 5 return value return (inner(x1), inner(x2), inner(x3)) print(mult2plus5_nested(2,3,4)) #&gt; (9, 11, 13) 所以nested function的主要用途，就是節省力氣拉，沒什麼特別的 24.2 Closure 剛剛示範了nested function，他被用來簡化原function內部的計算。但原function所output的東西，還是一般的value(在上例中，是tuple) 但很酷的是，你也可以output出這個nested function。 這種output也是function的function，在CS中，被稱為closure 例如這樣： def raise_val(n): &quot;&quot;&quot;Return the inner function.&quot;&quot;&quot; def inner(x): &quot;&quot;&quot;Raise x to the power of n.&quot;&quot;&quot; raised = x ** n return raised return inner square = raise_val(2) cube = raise_val(3) print(square(2), cube(4)) #&gt; 4 64 酷…我input東西後，可以製作出各式各樣的function 那，為啥要這麼做呢？ 其實很簡單啊，還是在偷懶啊。想想看，如果今天你要寫個2次方的function，3次方的function，4次方的function…，你要一直重複定義這些一樣pattern的寫法(def function(x) x**2)，你不累嗎？所以我就寫個general function，然後你只要輸入n，我就給你n次方的function 此外，Closure的更重要的好處是，一般的funciton，你定義完，執行後，他在local scope的資訊都無法調用了; 但是，如果今天是closure，他還可以“記得”enclosing function scope中的定義過的東西。 "],["variable-scope-1.html", "Chapter 25 Variable Scope 25.1 Intro 25.2 LEGB scope 25.3 用global這個keyword，把local scope的object給推到global scope 25.4 Enclosing function scope的例子 25.5 用nonlocal這個keyword…", " Chapter 25 Variable Scope 25.1 Intro 在我們寫python script時，每個variable都有自己所屬的scope(i.e. 我是在哪個scope中被定義的)。那我們在呼叫這個變數時，系統就會先看你是在哪個scope做呼叫的，然後去找這個scope中有沒有你要的這個變數。 例如下例： num = 4 # 在global scope中被定義 print(num) # 在global scope中呼叫num #&gt; 4 def func1(): num = 3 # 在local scope中被定義 return num # 在local scope中呼叫num print(func1()) # 在global scope中呼叫func1 #&gt; 3 print(num) # 在global scope中呼叫num #&gt; 4 num = 4是在global scope中被定義的; num = 3是在local scope被定義的。 所以在function中，你要他retun num，他就會先看他目前在哪個scope? -&gt; local scope。所以他先去local scope中找找看有沒有num，結果找到num = 3，那他就會用num = 3 但你在外面call print(num) 時，因為你是在global scope去call的，所以他會在global scope中有沒有num，結果找到num = 4，所以他會print 4出來 25.2 LEGB scope 那接下來講更細一點，variable這個詞，可以把它一般化成object。而python的scope其實有四種，由低至高分別為LEGB。搜尋object時，先從呼叫的scope開始做搜尋，如果搜尋不到，就往上一個階層做搜尋。所以如果你從local scope呼叫一個變數的話，他就會這樣搜： 先搜Local scope: 就是你define一個function時，他的body就是個local scope 再搜Enclosing function scope: 晚點再定義 再搜Global scope: 就是寫main script的地方 最後Built-in scope: 一些pre-define好的functions，例如sum。 所以，如果更改一下剛剛的例子： num = 4 # 在global scope中被定義 print(num) # 在global scope中呼叫num #&gt; 4 def func1(): return num # 在local scope中呼叫num print(func1()) # 在global scope中呼叫func1 #&gt; 4 print(num) # 在global scope中呼叫num #&gt; 4 會發現在local scope中呼叫num時，因為local scope裡沒有num，所以他往上一層找(global scope)，找到num = 4，所以就用了這個4 那再看個例子： def func1(): val = 3 # 在local scope中被定義 return val # 在local scope中呼叫num print(func1()) # 在global scope中呼叫func1 #&gt; 3 print(val) # 在global scope中呼叫num #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name &#39;val&#39; is not defined #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 看到出現error了，因為我們在global scope中呼叫val時，他會先從global scope中找有沒有val，沒有的話，他會往built-in scope找val，當然也是沒找到val，所以最後就給你error 25.3 用global這個keyword，把local scope的object給推到global scope def func1(): global num num = 3 print(num) print(func1()) #&gt; 3 #&gt; None print(num) #&gt; 3 25.4 Enclosing function scope的例子 剛剛講到python的scope分為LEGB四種，現在來講E這個Enclosing function scope 首先，我們來看看以下的nested function。他的目的是，給我一串數字，我幫你把每個數字都乘上2再加5，然後吐出來。以下是demo: def mult2plus5_nested(x1, x2, x3): def inner(x): value = x*2 + 5 return value return (inner(x1), inner(x2), inner(x3)) print(mult2plus5_nested(2,3,4)) #&gt; (9, 11, 13) 那剛剛講過，function內的scope，我們叫local，那現在function內還有function，該怎麼叫？ 答案是，最內層的function的scope，我們叫local，他外面的scope，我們叫enclosing function scope 所以，標上註解後如下： def mult2plus5_nested(x1, x2, x3): # 這邊是enclosing function scope def inner(x): # 這邊是local value = x*2 + 5 return value # 這邊又回到enclosing function scope return (inner(x1), inner(x2), inner(x3)) 那所以，維持剛剛搜尋時依照LEGB的順序，應該猜得出以下範例的答案： def outer1(): n = 1 def inner(): n = 2 print(n) inner() print(n) outer1() #&gt; 2 #&gt; 1 可以看到，先print出的inner()，用的n是local scope的n，所以是n=2 後print出的n，用的n是enclosing function的n，所以是n=1 25.5 用nonlocal這個keyword… 如同我們想把local的variable，推到global時，會用global，那現在，要把local的variable，推到enclosing function scope，會加入nonlocal： def outer2(): n = 1 def inner(): nonlocal n n = 2 print(n) inner() print(n) outer2() #&gt; 2 #&gt; 2 cool~ 最後要print出的n，他在enclosing function scope中找，他不是找到一開始定義的n=1，而是找到在local端定義好，然後被推到enclosing function scope的n=2 "],["oop-fundamentals.html", "Chapter 26 OOP Fundamentals 26.1 What is OOP? 26.2 OOP in Python 26.3 My first class 26.4 the __init__ constructor 26.5 寫Class的SOP", " Chapter 26 OOP Fundamentals 26.1 What is OOP? OOP是一種programming的設計思維，他以object為coding的最小單位。 那到底什麼是object？要回答這個問題，我們要先學會什麼是class。 之前在寫code的時候，我們都會命名出很多variable，那現在，我們用分類問題的角度去想，是不是某一群variable，可以一起被歸為一類？如果可以的話，那我要要定義的，就不會是一個variable，而是要定義出一種類別(class)！ 舉例來說，今天我想定義出顧客(Customer)這個class，那我該怎麼定義呢？我們會用state和behavior這兩個方向來定義一個class。 state指的是這個class所具備的特徵，behavior是指這個class所能施展的行為。 所以，回到顧客這個class的例子，state我就可以定義成email和phone這兩個特徵(因為每個顧客，應該都具備這兩個特徵)，behavior我就定義成“跟我下單”和“跟我取消訂單”這兩種行為。那做到這邊，我就算完成了Customer class的定義。 接下來，我只要填入state特定的value，就可以realize出各式各樣的客戶。例如我想realize出A客戶，那我就把A客戶的email和phone填入就好。而這樣realize完後，我們就稱這個A客戶是一個object。此時，我們知道他的states(email和phone都有)，也知道他有可能對我們施展的behavior(下訂單 &amp; 取消訂單) 所以，我可以realize各式各樣的object with specific state value(在此例，就是realize各式各樣的客戶) 以圖來描述，可以畫成下面這張圖： 所以總結一下，Class和Object可以這樣定義： Class 就是一個object製造機，他是一個抽象的概念。這個製造機像個藍圖一樣，告訴我們怎麼具體化一個實例(instance)出來。而藍圖裡面寫的東西，就是有關這個class該有的states以及behavior. Object 就是instance，他是該class所建造出來的一個具體實例。 與OOP對比的另一種設計思維，是R的procedural programming。R code的寫法，就像一步又一步的步驟，把結果給做出來。 但OOP不是這樣，OOP的寫法強調的不是步驟，而是object間的互動(e.g. 繼承/多形)。兩者的比較如下表： Procedural programming Object-oriented programming Code as a sequence of steps Code as interactions of objects Great for data analysis and scripts Great for building frameworks and tools Maintainable and reusable code 26.2 OOP in Python 在python裡面，所有東西，都是object!! 例如，你隨便key個6，6就是一個object，你只要把它存成變數，就可以看到他所屬的class a = 6 print(type(a)) #class #&gt; &lt;class &#39;int&#39;&gt; 隨便整理python裡面的各式各樣object，以及他所屬的class: Object Class remark 5 int “Hello” str pd.DataFrame() DataFrame np.mean function … … 既然所有東西都是object，那我應該有他的state和behavior訊息吧？在python中，state的訊息，被存在attribute中，behavior的訊息，被存在method中。 Attributes encode the state of an object and are represented by variables. 例如，.shape就是numpy.ndarray object的一個attribute，注意到他是用variable的形式存在的，所以shape後面沒有括號。 Methods encode behavior of an object and are represented by functions. 例如，.reshape()就是numpy.ndarray的method。注意到他是用function的形式存在的，所以會看到括號，括號內也可能要輸入argument 來看個numpy object例子： import numpy as np a = np.array([1,2,3,4]) # 看a是哪種class print(type(a)) #&gt; &lt;class &#39;numpy.ndarray&#39;&gt; # shape attribute a.shape #&gt; (4,) # reshape method a.reshape(2,2) #&gt; array([[1, 2], #&gt; [3, 4]]) 最後，提醒一下，一個程式語言可以是OOP，或是procedural，或是both。例如Python就是both，我們可以用procedural的寫法，一步一步的做完data analysis，但也可以用OOP的寫法來做。R也是如此，只是R的OOP要借助第三方套件R6 26.3 My first class 開始來寫我的第一個class，就用剛剛customer的例子 class Customer_old: # attribute # mehod: function definition within class # use &#39;self&#39; as the first argument def identify(self, name): print(&quot;I am Customer &quot; + name) 上面這個例子，我們最一開始就宣告他是個class 接著，分別定義attribute和method 我們先看method的部分就好。這個method，其實就是我們寫過的function，只是第一個參數要幫他寫`self`，這是規定的，原因等等會談。 這樣就算定義完Customer這個class了。我要realize他的話，我就直接call他，並assign到一個variable上，也就是cust1 = Customer()。此時，cust1被我們稱為instance。然後，我就可以使用他的method了。例如： cust1 = Customer_old() cust1.identify(&quot;Laura&quot;) #&gt; I am Customer Laura 那現在回過頭來看，self到底是啥 我們知道class只是一個template，他需要refer data of a particular object。而這個self，就是這個particular object的代名詞。 以剛剛的例子來說，這個particular object就是我的cust1，而self就會是cust1的代名詞，所以當我們寫cust1.identify(\"Laura\")的時候，其實python在內部的翻譯是Customer.identify(cust1, \"Laura\")，也就是說，我要用Customer這個class裡的identify method，然後第一個argument是指我要refer to cust1這個particular object。 nice，現在我們把attribute捕進去，並且稍微改寫method的地方，變成以下這樣： class Customer_new: # attribute # set the name attribute of an object to new_name def set_name(self, new_name): # create an attribute by assigning a value self.name = new_name # &lt;- will create .name when set_name is called # mehod: function definition within class # use &#39;self&#39; as the first argument def identify(self): print(&quot;I am Customer &quot; + self.name) 可以看到在attribute的地方，也是用定義funciton的方式去寫，但function body是直接用assign變數的方式，把他assign到self下面。實際使用時，變成以下這樣： cust2 = Customer_new() # &lt;- .name doesn&#39;t exist here yet cust2.set_name(&quot;Lara de Silva&quot;) # &lt;- .name is created and set to &quot;Lara de Silva&quot; print(cust2.name) #&gt; Lara de Silva print(cust2.identify()) #&gt; I am Customer Lara de Silva #&gt; None 快速的來個類似的練習，我現在想定義Employee這個class，然後這個class的state包括name和salary(合理嘛，描述一個employee的狀態，就用名字和薪水這樣)。接著，我要realize出第一位員工，他的名字叫“Korel Rossi”，他的薪水是50000 第一步，定義出此class，以及所屬attribute class Employee: # attribute def set_name(self, new_name): self.name = new_name def set_salary(self, new_salary): self.salary = new_salary 第二步，realize出這位員工 emp = Employee() emp.set_name(&#39;Korel Rossi&#39;) emp.set_salary(50000) 第三步，看看這員工的attribute是不是設對了 print(emp.name) #&gt; Korel Rossi print(emp.salary) #&gt; 50000 so far so good. 對現在這個Employee來說，state已經有了，但behavior還沒。一個員工可能可以做哪些行為？我先幫他定義一個：被加薪！所以，現在我們來寫一個method叫get_raise(amount)，然後他的結果可以去更新原本state中的salary class Employee: # attribute def set_name(self, new_name): self.name = new_name def set_salary(self, new_salary): self.salary = new_salary # method def give_raise(self, amount): self.salary = self.salary + amount emp = Employee() emp.set_name(&#39;Korel Rossi&#39;) emp.set_salary(50000) emp.give_raise(10000) print(emp.salary) #&gt; 60000 good，現在多寫一個method，是幫我們算他的月薪是多少 class Employee: # attribute def set_name(self, new_name): self.name = new_name def set_salary(self, new_salary): self.salary = new_salary # method def give_raise(self, amount): self.salary = self.salary + amount def monthly_salary(self): return self.salary/12 emp = Employee() emp.set_name(&#39;Korel Rossi&#39;) emp.set_salary(50000) emp.give_raise(22000) mon_sal = emp.monthly_salary() print(mon_sal) #&gt; 6000.0 You might be wondering: why did we write these methods when all the same operations could have been performed on object attributes directly? Our code was very simple, but methods that deal only with attribute values often have pre-processing and checks built in: for example, maybe the company has a maximal allowable raise amount. Then it would be prudent to add a clause to the give_raise() method that checks whether the raise amount is within limits. 26.4 the __init__ constructor 剛剛學了這幾招： 在class內定義function，就叫method，且第一個argument要設self attribute也是用define function的方式做定義，只是最終都是assignment的方式，塞到self.___的變數中 在class內，要用到attribute時，都是用self.___的方式來call realize一個object時，先call class name，再用attribute的function來做設定(例如設定Employee的name和salary) 關於最後一點，其實有更好的作法，就是我們幹麻先realize完，又再用attribute的function去設定？何不在realize一個object的時候，就直接把這些attribute設定進去呢？這其實是可以的，就是使用__init__這個constructor，看個例子就懂了： class Customer: # attribute def __init__(self, name): self.name = name # &lt;- Create the .name attribute and set it to name parameter print(&quot;The __init__ method was called&quot;) 現在，只要我用這個class去create一個object時，他就會自動啟動__init__()這個function，而這個function要用的argument，也是在你create object時就要傳入了： cust_lara = Customer(name = &quot;Lara de Silvia&quot;) #&gt; The __init__ method was called print(cust_lara.name) #&gt; Lara de Silvia nice! 這其實才是最常用的作法。之前的作法，被稱為“Attributes in methods”，也就是我在class裡面，用定義method的方式(也就是定義function的方式)，來定義一個設定attribute的function。然後create object後，再去call這些function來一一設定attribute。而現在的方式，叫做“Attribute in the constructor”，就是我直接寫一個initialize的function在最前面：__init__(self, all_attribute_list_here)，然後逼迫我們在create object的時候，就要把這些設定值填進去，那你其實就是在一一create出各個獨特的object。這種作法更可讀(在class內，找init，就可以一次全覽所有attribute), 更快速(create object時同步搞定), 也更容維護。 26.5 寫Class的SOP 最後，講一下寫class的best practices: Initialize attributes in __init__() 命名時，class的命名都用CamelCase，就是單字在組合時，都是字首大寫，例如class EmployeeWistron:，class內定義function時，function name都是全小寫用底線串，例如def employee_wistron(): Keep self as self。在class內定義function時，第一個argument都是留給self用的，如果你不寫self，要寫別的，例如kitty，也是可以work，你在class內要call這些attribute時，就記得用kitty.___就ok，但這樣別人看你的code時會很容易亂，所以還是建議，你就乖乖寫self就好。 最後，就像寫function一樣，寫class的時候，第一行也都會寫docstrings(功能註解)，幫助自己也幫助別人了解這個class的主要功能在幹麻 接下來，我們就用學到的這些技巧，來重寫Employee的class。我們要用__init__()來設定name和salary這兩個attribute，而且，因為__init__就是寫function，所以，我們也可以給salary一個default值，例如GG的45000： class Employee: # Create __init__() method def __init__(self, name, salary=45000): # Create the name and salary attributes self.name = name self.salary = salary # From the previous lesson def give_raise(self, amount): self.salary += amount def monthly_salary(self): return self.salary/12 emp = Employee(&quot;Korel Rossi&quot;) print(emp.name) #&gt; Korel Rossi print(emp.salary) #&gt; 45000 nice，這邊又提醒，__init__()很適合拿來做data preprocessing。例如，這邊的薪水一定要&gt;=0，所以，如果在create object的時候，輸入負的薪水，我想要print出你key錯了，薪水要正的，並主動先幫他把薪水設成0 class Employee: def __init__(self, name, salary=0): self.name = name # Modify code below to check if salary is positive if salary&gt;=0: self.salary = salary else: self.salary = 0 print(&quot;Invalid salary&quot;) # From the previous lesson def give_raise(self, amount): self.salary += amount def monthly_salary(self): return self.salary/12 emp = Employee(&quot;Korel Rossi&quot;, -1000) #&gt; Invalid salary print(emp.name) #&gt; Korel Rossi print(emp.salary) #&gt; 0 最後，如果我想使用其他package的function時怎麼辦？我要import在class外面還是裡面？答案是：外面！！以下舉個例子，我想要多加一個attribute叫hire_date，他可以在我建立這個employee的object時，直接assign當天日期進去。所以，我需要用到datetime這個package裡面的function，叫today()。請見以下範例： # Import datetime from datetime from datetime import datetime class Employee: def __init__(self, name, salary=0): self.name = name if salary &gt; 0: self.salary = salary else: self.salary = 0 print(&quot;Invalid salary!&quot;) # Add the hire_date attribute and set it to today&#39;s date self.hire_date = datetime.today() # From the previous lesson def give_raise(self, amount): self.salary += amount def monthly_salary(self): return self.salary/12 emp = Employee(&quot;Korel Rossi&quot;, -1000) #&gt; Invalid salary! print(emp.name) #&gt; Korel Rossi print(emp.salary) #&gt; 0 print(emp.hire_date) #&gt; 2021-02-17 01:58:16.631733 "],["class-level-vs-instance-level.html", "Chapter 27 Class-level vs Instance-level 27.1 Instance-level attribute vs Class-level attribute 27.2 Instance-level method vs Class-level method 27.3 小結", " Chapter 27 Class-level vs Instance-level 27.1 Instance-level attribute vs Class-level attribute 27.1.1 簡介實例屬性與類屬性 首先我們看一下這個例子： class Student: count = 0 # class-level attribute def __init__(self, name): self.name = name # instance-level attribute 在這個例子中，self.name叫做instance-level attribute(實例屬性)，因為他有一個instance的代名詞self放在前面，我們在調用這個attribute時，都是先寫instance name，才寫此屬性，例如： hank = Student(name = &quot;hank&quot;) print(hank.name) #&gt; hank 而count叫做class-level attribute，他前面沒有擺self，所以他是屬於Class下面的屬性，而不是屬於self下面的屬性。在調用這個attribute時，要先寫class name，才寫此屬性，例如： print(Student.count) #&gt; 0 27.1.2 實例屬性可以繼承類屬性 那由於階層上是class為第一層，instance為第二層，所以instance會繼承class的屬性，但class不會有instance的屬性： # class下，沒有name這個屬性，要instance下才會有 print(Student.name) # instance會繼承class的屬性，所以還是看得到count #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): AttributeError: type object &#39;Student&#39; has no attribute &#39;name&#39; #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; print(hank.count) #&gt; 0 27.1.3 實例屬性與類屬性的修改 剛剛講到，instance會繼承class的attribute: print(Student.count) #&gt; 0 print(hank.count) #&gt; 0 Student.count是在講Student這個抽象的類別，他所屬的count。我們覺得，不管是哪個學生(hank or aaron or sunny…)，只要是學生，一開始的count應該都是0 所以，我們realize一個instance叫做hank時，hank.count就繼承了這個student的class給他的count，現在hank.count已經是hank專屬的count了。 那可以想像，如果我去修改instance中的count(e.g. 這邊的hank.count)，那就只是修改instance中的count，不會影響到class的count: print(Student.count) #&gt; 0 print(hank.count) #&gt; 0 hank.count = 1 print(Student.count) #&gt; 0 print(hank.count) #&gt; 1 我也可以想像，如果我去改class中的count，並不會影響到instance中的count。因為改class中的count，等於只是改模板，他只會影響到“之後”我創建出來的instance而已： print(Student.count) #&gt; 0 print(hank.count) #&gt; 1 Student.count = 100 print(Student.count) #&gt; 100 print(hank.count) #&gt; 1 sunny = Student(name = &#39;sunny&#39;) print(sunny.count) #&gt; 100 27.1.4 類屬性用在哪 對於instance-level attribute(實例屬性)我們蠻熟了，他主要就是給method做使用。那class-level attribute是用在哪呢？這邊舉兩個實例： 27.1.4.1 統計這個class被用過幾次 有時候我們會想統計一下，某個class被實體化過幾次，那就可以像下面這樣寫： class Student: count = 0 def __init__(self, name): Student.count = Student.count + 1 self.name = name 從上面這段code，可以看到我們把Student.count = Student.count + 1放在__init__的下面。那每次在實體化一個instance時，count數就會增加： s1 = Student(&quot;A&quot;) s2 = Student(&quot;B&quot;) s3 = Student(&quot;C&quot;) print(Student.count) #&gt; 3 27.1.4.2 跨instance都應該一樣的特徵 舉例來說，今天我要做一個Employee的class，裡面有個attribute叫MIN_SALARY。那這個最低薪資，其實是法律規範的22k，只要你是員工，不管你叫阿貓還是阿狗，最低薪資都應該一樣。那這種attribute我們就會寫在class下面。 這樣做的一個優點是省力，另一個優點是可以幫我們做卡控: 以下舉個例子，當我們實體化一個employee時，要輸入該員工的name與salary。但只要這個salary小於MIN_SALARY，我就要用MIN_SALARY做取代： class Employee: MIN_SALARY = 22000 def __init__(self, name, salary): self.name = name if salary &lt; Employee.MIN_SALARY: print(&quot;Please respect people. The salary you give is lower than 22K !!&quot;) self.salary = Employee.MIN_SALARY else: self.salary = salary 來做個實驗吧： sunny = Employee(name = &quot;sunny&quot;, salary = 10000) #&gt; Please respect people. The salary you give is lower than 22K !! print(sunny.salary) #&gt; 22000 hank = Employee(name = &quot;sunny&quot;, salary = 60000) print(hank.salary) #&gt; 60000 27.2 Instance-level method vs Class-level method 27.2.1 簡介類方法和實例方法 首先我們複習一下實例方法(instance-level method) class People: def __init__(self, name, age): self.name = name self.age = age def sayhi(self, v1): return(f&quot;Hi, my name is {self.name}, and I&#39;m {self.age} year&#39;s old. {v1} is here&quot;) def sayhi2(self, v1): res = self.sayhi(v1) return(res) 裡面的sayhi(self, v1)就是一實例方法，因為他需要傳入self這個參數，好讓他在method裡面可以呼叫self.name, self.age這兩個instance-level attribute 而sayhi2(self, v1)同樣是個實例方法，這邊就顯示我們要呼叫實例方法時，也得用self，如同這邊用到self.sayhi這個method 那舉一反三，class-level method，傳入的參數就該從self改成class? 答案很接近了，用的參數名稱叫cls而不是class。而且，還要在定義method的前面，加個decorator: @classmethod 看例子： class People: def __init__(self, name, age): self.name = name self.age = age def sayhi(self, v1): return(f&quot;Hi, my name is {self.name}, and I&#39;m {self.age} year&#39;s old. {v1} is here&quot;) def sayhi2(self, v1): res = self.sayhi(v1) return(res) @classmethod def test1(cls): return(&quot;這是一個類方法&quot;) 那定義好這個類方法後，我們從外部就不需要先realize一個instance，就可以用這個方法了: print(People.test1()) #&gt; 這是一個類方法 而且，如同實例屬性會繼承類屬性一樣，實例方法也會繼承類方法，所以當我realize一個instance後，我還是可以調用這個method: p1 = People(name = &quot;hank&quot;, age = 28) print(p1.test1()) #&gt; 這是一個類方法 那最後講一下，instance-level method時，你傳入self參數，是為了用self.name, self.age這些instance-level attribute，或是用self.sayhi()這種instance-level method。那class-level method時，你傳入cls參數，是為了調用cls.XXX的class-level attribute嗎？ 顯然不是，因為class-level attribute的調用，是用{class名稱}.{attribute名稱}。所以，cls參數要調用的，是其他class method!! 例如下例： class People: def __init__(self, name, age): self.name = name self.age = age def sayhi(self, v1): return(f&quot;Hi, my name is {self.name}, and I&#39;m {self.age} year&#39;s old. {v1} is here&quot;) def sayhi2(self, v1): res = self.sayhi(v1) return(res) @classmethod def test1(cls): return(&quot;這是一個類方法&quot;) @classmethod def test2(cls): res = cls.test1() return(res) 從這個例子可以看到，我的test2，調用了cls.test1這個class-level method。來看看結果對不對： print(People.test2()) #&gt; 這是一個類方法 最後，我們無法在類方法中，去調用實例方法。例如我現在寫個test3，裡面想要調用self.sayhi class People: def __init__(self, name, age): self.name = name self.age = age def sayhi(self, v1): return(f&quot;Hi, my name is {self.name}, and I&#39;m {self.age} year&#39;s old. {v1} is here&quot;) def sayhi2(self, v1): res = self.sayhi(v1) return(res) @classmethod def test1(cls): return(&quot;這是一個類方法&quot;) @classmethod def test2(cls): res = cls.test1() return(res) @classmethod def test3(cls, v1): res = self.sayhi(v1) return(res) 實驗一下： print(People.test3(v1 = &quot;hahaha&quot;)) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name &#39;self&#39; is not defined #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; #&gt; File &quot;&lt;string&gt;&quot;, line 24, in test3 如同預期，報error了，而且error message也很合理：沒找到self拉！啊廢話，你這是class-level method，給的參數是cls又不是self，當然無法去吃self.sayhi()這個instance-level method 而且，就算你實體化這個class，還是不能調用self.sayhi()，因為你的self從頭到尾都沒被當作參數丟入test3裡面： p2 = People(name = &quot;hank&quot;, age = 28) p2.test3(v1 = &quot;hahaha&quot;) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name &#39;self&#39; is not defined #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; #&gt; File &quot;&lt;string&gt;&quot;, line 24, in test3 27.2.2 實例屬性的使用時機 那到底class method可以拿來幹麻？其實最常是拿來作為initialize instance的另一種方式，例如，我的class如果本來要initialize一個instance時，要輸入year, month, day這三個參數，但我現在希望提供另一種initialize的方式，是直接給字串(e.g. “2020-10-20”)就好，我該怎麼做？只有一個__init__可以用，又不能寫兩個，這時候，就會用class method 直接看例子。今天我想寫一個class叫BetterDate，有year, month, day三個attribute。那我現在想寫一個class method，只要給字串，我一樣initialize instance給你： class BetterDate: # Constructor def __init__(self, year, month, day): # Recall that Python allows multiple variable assignments in one line self.year, self.month, self.day = year, month, day # Define a class method from_str @classmethod def from_str(cls, datestr): # Split the string at &quot;-&quot; and convert each part to integer parts = datestr.split(&quot;-&quot;) year, month, day = int(parts[0]), int(parts[1]), int(parts[2]) # Return the class instance return cls(year, month, day) 注意到最後的cls(year, month, day)，他的意思就是會把這三個參數傳回__init__來initialize instance的意思。所以，現在試試看結果： bd = BetterDate.from_str(&#39;2020-04-30&#39;) print(bd.year) #&gt; 2020 print(bd.month) #&gt; 4 print(bd.day) #&gt; 30 27.3 小結 剛剛講了類屬性和實例屬性，我們學到類屬性在實體化之前就可以調用，調用的方式是{class名稱}.{attribute名稱} 類屬性當然也可以在class的內部去調用它，一樣是用{class名稱}.{attribute名稱} 實例屬性，在內部的調用是用self.{attribute名稱}，因為在內部時還不知道實體化後的名稱，所以都用self來當代名詞 實例屬性，在外部的調用是用{instance名稱}.{attribute名稱} 類方法和實例方法概念也都一樣： 實例方法：內部的調用是用self.{method名稱}(參數)，外部的調用是{instance名稱}.{method名稱}(參數) 類方法：內部的調用適用cls.{method名稱}(參數)，外部調用是{class名稱}.{method名稱}(參數) "],["attribute-protection.html", "Chapter 28 Attribute Protection 28.1 Naming Convention 28.2 [放任型] 不保護 28.3 [信任型] 用單底線提醒 28.4 [嚴父型] 用雙底線不給動 28.5 [中庸型] 雙底線 + @property + .setter", " Chapter 28 Attribute Protection 這節要來講如何保護我們的attribute，更精確的說，是保護instance-level attribute 要做到實例屬性的保護，由淺至深可分為以下四種： [放任型] 開發者啥都不做，user想做啥都可以。 [信任型] 我希望initialize後，提醒你這些屬性小心使用，盡量不要修改 [中庸型] 我希望initialize後，你要改屬性，要先經過我的審核機制才能改： 用decorator(@property, setter) [嚴父型] 我希望initialize後，你不准修改和查詢屬性：那就用私有屬性的做法，我也不給你set和get method。 28.1 Naming Convention 在python中，instance-level attribute的命名是有慣例的(naming convention)： 一般的變數型態，表不保護，user想做啥都可以。這被我歸類在[放任型] 單底線開頭，表受保護屬性，用來提醒user，不要調用和修改。但只有提醒功能，user還是可用可改。這被我歸類在[信任型] 雙底線開頭，表私有屬性(private variable)，這種命名規則會告訴系統，這個attribute只給class在內部使用，不讓user從外部去找到和使用這個屬性。這被我歸類在[嚴父型]。那如果再搭配可用來修改的decorator(e.g. @property, .setter)，就被我歸類為[中庸型] 28.2 [放任型] 不保護 28.3 [信任型] 用單底線提醒 以下我們舉個例子，此例我要在__init__()裡面，加上一個受保護的屬性，叫做._protect_var class People: def __init__(self, name, age): self.name = name self.age = age # 受保護屬性，用單底線開頭，提醒user不要用不要改 self._protect_var = 10 這樣的做法，用意只是提醒user，這個屬性你不要用，也不要改。但他只有提醒功能，如果user要用要改，都還是可以做到： someone = People(name = &quot;hank&quot;, age = &quot;28&quot;) # user還是可以調用這個屬性 print(someone._protect_var) # user還是可以修改這個屬性 #&gt; 10 someone._protect_var = 20 print(someone._protect_var) #&gt; 20 28.4 [嚴父型] 用雙底線不給動 接下來我們舉雙底線開頭的例子，下例中我們新增一個.__private_var的私有屬性： class People: def __init__(self, name, age): self.name = name self.age = age self._protect_var = 10 # 私有屬性用雙底線開頭，只能在class內部使用 self.__private_var = 10 def show_private(self): return(self.__private_var) 這樣做以後，如果user從外部要調用這個屬性，會得到error 但如果我們寫個method來調用這個屬性就ok，因為private variable就是專for class內部使用的 someone = People(name = &quot;hank&quot;, age = &quot;28&quot;) print(someone.__private_var) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): AttributeError: &#39;People&#39; object has no attribute &#39;__private_var&#39; #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; print(someone.show_private()) #&gt; 10 那為什麼我們不能用someone.__private_var這個指令？我們可以用dir()來看一下有哪些attribute/method可以用： print(dir(someone)) #&gt; [&#39;_People__private_var&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;_protect_var&#39;, &#39;age&#39;, &#39;name&#39;, &#39;show_private&#39;] 從上面可以看到，我們可以用的屬性和method中，有看到我定義的保護屬性_protect_var，但根本沒出現我定義的私有屬性__priate_var，所以，當你用someone.__private_var，python才會跟你說，沒有這個attribute或method 但，你可以看到第一個attribute的名稱叫：_People__private_var，表示，python是自動幫你把private variabe和class名稱給黏在一起，變成一個新的attribute供user調用，所以其實user還是可以藉由這個方法，取得和修改private variable print(someone._People__private_var) #&gt; 10 someone._People__private_var = 30 print(someone._People__private_var) #&gt; 30 所以講白了，python的理念，還是給user很大的自由度。即使是最嚴格的類型，user還是可以找到方法去修改。 最後，來釐清個觀念：user不能調用someone.__private_var，但卻可以藉由這種方式修改(someone.__private_var = xxx)!? print(someone.__private_var) # 會報error #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): AttributeError: &#39;People&#39; object has no attribute &#39;__private_var&#39; #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; someone.__private_var = 40 # 不會報error 看起來好像做到修改了，但其實，這樣做是在“新增”一個attribute，而不是“修改”我們舊有的私有屬性，我們看系統內部在讀self.__private是讀到誰就知道了： print(someone.show_private()) #&gt; 30 我們發現，系統讀到的還是舊的.__private_var(40)，而不是剛剛assign的這筆(30) 因為someone.__private_var = 40的意思，其實是create了一個新attribute給這個instance，只是他的名稱剛好也叫.__private_var而已。但系統在讀self.__private_var時，還是讀一開始設好的那個.__private_var 也因為剛剛這種直接assign attribute的做法，讓我們現在可以直接調用這筆新增的.__private_var了 someone.__private_var #&gt; 40 28.5 [中庸型] 雙底線 + @property + .setter 有時候，我們設private variable，並不是不讓別人修改，而是希望別人修改的時候，能符合我們設定好的遊戲規則 如果要做到這個，我們就會用以下的寫法來做 首先介紹old-school的做法(加入get和set的method)，因為比較好理解到底在做什麼。但這種寫法沒人再寫了，所以我們還是要學標準版的寫法：加decorator的寫法 28.5.1 old-school 作法 假設我們要寫一個People的class，在initialize的時候，會用到name和age兩個attribute，而我們希望user initialize後，就盡可能不要改他。那我們會寫成這樣： class People: def __init__(self, name, age): self.__name = name self.__age = age hank = People(name = &quot;hank&quot;, age = 28) print(hank.name) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): AttributeError: &#39;People&#39; object has no attribute &#39;name&#39; #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; print(hank.age) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): AttributeError: &#39;People&#39; object has no attribute &#39;age&#39; #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 可以看到，name和age現在都無法調用了 那如果，我可以允許user做修改，但必須符合我的遊戲規則，那我可以寫個get和set method來卡空： class People: def __init__(self, name, age): self.__name = name self.__age = age def get_name(self): return self.__name def set_name(self, new_name): if type(new_name) is str: self.__name = new_name else: print(&quot;new_name should be the type of string.&quot;) def get_age(self): return self.__age def set_age(self, new_age): if type(new_age) is int: self.__age = new_age else: print(&quot;new_age should be the type of integer.&quot;) 有了set這道防線後，user就不能亂設attribute了： hank = People(name = &quot;hank&quot;, age = &quot;28&quot;) print(hank.get_name()) #&gt; hank hank.set_name(12345) #&gt; new_name should be the type of string. print(hank.get_name()) #&gt; hank hank.set_name(&quot;hank lee&quot;) print(hank.get_name()) #&gt; hank lee 由此例可以發現，我們新增兩個方法讓user去調用(i.e. get_name)和修改(i.e. set_name) 藉由這種不便利性，來減少user去使用和修改這些private variable的頻率，也藉由寫method，加入一些卡空機制進去 28.5.2 正規作法 那正規作法，其實是把get_name()和get_age()這兩個method，換成@property的寫法，見下例： class People: def __init__(self, name, age): self.__name = name self.__age = age # def get_name(self): # return self.__name @property def name(self): return self.__name # def get_age(self): # return self.__age @property def age(self): return self.__age 由這種寫法可以發現，我們加@property這個decorator在method的上面，用來宣告說我要使用property的功能。然後底下用來取代get_name method的東西，要直接用private variable的名稱，所以會是name或age 那這種寫法的好處是，user現在可以用熟悉的{instance名稱}.{attribute名稱}來調用這些private variable，不用再寫get_name()或get_age() hank = People(name = &quot;hank&quot;, age = 28) print(hank.name) #&gt; hank print(hank.age) #&gt; 28 從此例也可看出，我們剛剛寫的name和age兩個method，再加上@property後，他就不再是method了(你看我是用hank.name來取得name，而不是用hank.name()來取得name，但我在class中，name()明明是以method的方式存在的，我還有return勒！) 再來，我們要改造set_name()這個method，也是用decorator(xx.setter)，見下例: class People: def __init__(self, name, age): self.__name = name self.__age = age @property def name(self): return self.__name # def set_name(self, new_name): # if type(new_name) is str: # self.__name = new_name # else: # print(&quot;new_name should be the type of string.&quot;) @name.setter def name(self, new_name): if type(new_name) is str: self.__name = new_name else: print(&quot;new_name should be the type of string.&quot;) @property def age(self): return self.__age # def set_age(self, new_age): # if type(new_age) is int: # self.__age = new_age # else: # print(&quot;new_age should be the type of integer.&quot;) @age.setter def age(self, new_age): if type(new_age) is int: self.__age = new_age else: print(&quot;new_age should be the type of integer.&quot;) 可以看到，差別就是加上name.setter和age.setter，然後method name維持原來的private variable name 來試試看能不能work hank = People(name = &quot;hank&quot;, age = &quot;28&quot;) print(hank.name) #&gt; hank hank.name = 12345 #&gt; new_name should be the type of string. print(hank.name) #&gt; hank hank.name = &quot;hank lee&quot; print(hank.name) #&gt; hank lee 可以發現，可以work 而且，藉由decorator，我們又把method變成attribute了。注意到現在是寫hank.name = 12345，就會跑我定義的method並檢查合法性，而不是寫hank.name(12345)。 所以，這樣做，可以讓user用起來更直覺的同時，又兼顧到資料的正確性 "],["isinstance-equality-string-representation.html", "Chapter 29 isinstance, equality, 與 string representation 29.1 type 與 isinstance 29.2 __eq__ (object equality) 29.3 __str__與__repr__", " Chapter 29 isinstance, equality, 與 string representation 29.1 type 與 isinstance 之前已經用過很多次type()，例如下例： a = [1,2] print(type(a)) #&gt; &lt;class &#39;list&#39;&gt; 可以看到，顯示出來的type是list 而且，我們終於看懂前面的class是什麼意思了：在python中萬物都是object，所以你去問一個object的type，就是在問他的class是誰拉！！ 那現在多教一個指令，叫isinstance()，他的用法如下： a = [1,2] print(isinstance(a, list)) #&gt; True 所以蠻好懂的，第一個argument就是放你要驗證的object(e.g. 此例的a)，第二個argument就是去看看他是不是這個class的instance 再來個練習，我自己寫的class，用type會長怎樣： class A: pass a = A() print(type(a)) #&gt; &lt;class &#39;__main__.A&#39;&gt; cool，他的type就是A。那用用看isinstance print(isinstance(a, A)) #&gt; True 29.1.1 繼承與isinstance 重點來了，如果今天有繼承的話，那子類的instance，也會是父類的instance class A: pass class B(A): pass a = A() b = B() print(type(b)) #&gt; &lt;class &#39;__main__.B&#39;&gt; print(isinstance(b, B)) #&gt; True print(isinstance(b, A)) #&gt; True print(type(a)) #&gt; &lt;class &#39;__main__.A&#39;&gt; print(isinstance(a, A)) #&gt; True print(isinstance(a, B)) #&gt; False 可以明顯看到，雖然b的type是B，但在判斷instance時，他仍是A的instance!! 因為我們要判斷b是不是A的instance時，就是看A的instance該有的attribute和method他是不是都有。而因為B繼承A，所以A有的，B都有，B做出來的instance全都繼承過去了，所以他仍是A的instance 但a就不會是B的instance了，道理很簡單，B的instance該有的attribute和method，a未必都有(因為B就是繼承A後，要加了他獨有的attribute和methods) 29.2 __eq__ (object equality) 用我們現在學到的方法來寫class的話，會碰到以下問題：兩個instance的attribute完全相同，但比較結果卻說不同： class Customer: def __init__(self, name, id): self.name = name self.id = id cust1 = Customer(&quot;Hank&quot;, 19002329) cust2 = Customer(&quot;Hank&quot;, 19002329) cust1 == cust2 #&gt; False 為什麼會這樣？因為在比相不相同時，是比記憶體位置一不一樣： print(cust1) #&gt; &lt;__main__.Customer object at 0x12c611e80&gt; print(cust2) #&gt; &lt;__main__.Customer object at 0x12c611760&gt; 很明顯的看到，兩個記憶體位置不同，所以才說不相等 聽起來很合理，但很難用啊，兩個object的attribute相同，我就希望他們比較的結果是一樣啊。 其實python內建的class，就有做這種處理了，比如說： import numpy as np a = np.array([1]) b = np.array([1]) id(a) #&gt; 5039547936 id(b) #&gt; 5039548016 print(a == b) #&gt; [ True] 可以看到，兩個object的記憶體位置不同，但比較結果是True，這怎麼辦到的？ 這其實就是要多寫一個“equality constructor”。對比於“initial constructor”是__init__(self, ...)，這個equality constructor是寫成__eq__(self, other)，其中“self”, “other”就是固定的參數，不要去換 寫法如下： class Customer: def __init__(self, name, id): self.name = name self.id = id def __eq__(self, other): print(&quot;__eq__() is called&quot;) return (self.name == other.name) &amp; (self.id == other.id) cust1 = Customer(&quot;Hank&quot;, 19002329) cust2 = Customer(&quot;Hank&quot;, 19002329) cust1 == cust2 #&gt; __eq__() is called #&gt; True 這邊就看到，我們得條件是，兩個比較的instance的name和id若完全相同，我就認定他是equal的。裡面的self和other就各指稱兩個instance，最後的return結果一定要是True/Fale。 除了equality operator外，其實還有其他的comparison，比如： Operator Method == `__eq__`: equal != `__ne__`: not equal &gt;= `__ge__`: greater or equal than &lt;= `__le__`: less or equal than &gt; `__gt__`: greater than &lt; `__lt__`: less than 接下來講兩個細節： 不同class的instance，能不能比啊？會錯亂嗎？ Parent class的instance和Child class的instance在比時，用誰的equality constructor？ 先講答案，第一點是，只要equality constructor一樣，就可以比，所以會造錯亂。解決方式是，再多比一個type(self)==type(other)就好 第二點的答案是，always用child class的equality constructor 先來看第一點的範例吧 class Buyer: def __init__(self, number): self.number = number def __eq__(self, other): return self.number == other.number class Phone: def __init__(self, number): self.number = number def __eq__(self, other): return self.number == other.number buyer1 = Buyer(19002329) phone_number = Phone(19002329) buyer1 == phone_number #&gt; True 我建了兩個class，第一個是客戶的class，他的attribute是number，指的是他的編號；第二個是電話號碼的class，他的attribute也是number，但指的是電話號碼。結果這兩個不一樣的東西，就剛好都有number，就被比成一樣了。 所以實務上在比較時，equality constructor，都會再加上type的條件： type(buyer1) #&gt; &lt;class &#39;__main__.Buyer&#39;&gt; type(phone_number) #&gt; &lt;class &#39;__main__.Phone&#39;&gt; class Buyer: def __init__(self, number): self.number = number def __eq__(self, other): return (self.number == other.number) &amp; (type(self)==type(other)) class Phone: def __init__(self, number): self.number = number def __eq__(self, other): return (self.number == other.number) &amp; (type(self)==type(other)) buyer1 = Buyer(19002329) phone_number = Phone(19002329) buyer1 == phone_number #&gt; False 接著就講到parent class和child class的比較。always用child class的equality constructor： class Parent: def __eq__(self, other): print(&quot;Parent&#39;s __eq__() called&quot;) return True class Child(Parent): def __eq__(self, other): print(&quot;Child&#39;s __eq__() called&quot;) return True p = Parent() c = Child() p == c #&gt; Child&#39;s __eq__() called #&gt; True 29.3 __str__與__repr__ 接下來的議題，是有關object的printing 我們目前對class的寫法，會讓我們每次去print一個instance的時候，他都只給我們記憶體位置，例如： class salary: def __init__(self, number): self.number = number my_salary = salary(22000) print(my_salary) #&gt; &lt;__main__.salary object at 0x12c618df0&gt; damn…這麼簡單的class，我當然希望他直接print 22K給我看啊 Python其他內建的class，都有做這種處理，不信你看numpy的instance: import numpy as np a = np.array([1,2,3]) print(a) #&gt; [1 2 3] 為什麼勒？因為python有兩種constructor，一個叫__str__，一個叫__repr__ 定義在__str__內的東西，是要給end user看的，是informal的資訊，可以藉由print()和str()看到這些較親民的訊息 定義在__repr__內的東西，是要給developer看的，是formal的資訊，他會告訴你type, 記憶體位置等資訊，可以藉由直接key object name，或是repr()來取得。不信你直接call numpy的object看看，他就會送你array訊息 a #&gt; array([1, 2, 3]) 那現在回頭寫我剛剛的salary class: class salary: def __init__(self, number): self.number = number def __str__(self): return str(self.number) def __repr__(self): return f&quot;Salary({self.number})&quot; my_salary = salary(22000) print(my_salary) #&gt; 22000 my_salary #&gt; Salary(22000) "],["encapsulation-inheritacne-and-polymorphism.html", "Chapter 30 Encapsulation, Inheritacne, and Polymorphism 30.1 封裝 30.2 繼承(inheritance) 30.3 多形", " Chapter 30 Encapsulation, Inheritacne, and Polymorphism 這一章要介紹 30.1 封裝 把資料(attribute)和使用資料的方法(methods)全包在一起的作法，就叫封裝 30.2 繼承(inheritance) 繼承的意思是，我們在define一個class的時候，可以繼承另一個class的所有attribue和methods parent class指的是給別人繼承的class，又稱為base class child class指的是繼承別人的class，又稱為deived class 30.2.1 simple inheritance 例如，我先寫一個class叫Employee_parent，如下： class Employee_parent: # class-level attribute MIN_SALARY = 30000 # instance-level attribute def __init__(self, name, salary): self.name = name self.salary = salary # instance-level method def give_raise(self, amount): self.salary += amount 這個class有兩個attribute，和一個method 那如果今天我想寫一個WNC_Employee，他想繼承Employee_parent的這些attribute &amp; methods，那就這樣寫： class WNC_Employee(Employee_parent): #把要繼承的Class name塞入 pass 現在我們可以照往常輸入name和salary來initialize一個WNC_Employee的instance: Hank_wnc = WNC_Employee(&quot;Hank&quot;, 22000) 檢查一下之前的attribute都繼承下來了： print(Hank_wnc.name) #&gt; Hank print(Hank_wnc.salary) #&gt; 22000 檢查一下method也繼承下來了： Hank_wnc.give_raise(10000) print(Hank_wnc.salary) #&gt; 32000 30.2.2 增加instance-level attribute &amp; method 那接下來，就來講如何加入我想新寫的attribute和method 例如，對WNC_Employee來說，attribute除了name, salary外，還要新增一個職等(level); method除了原本的give_raise()外，還要新增一個promote()來更新職等的變化: class Employee_parent: MIN_SALARY = 30000 def __init__(self, name, salary): self.name = name self.salary = salary def give_raise(self, amount): self.salary += amount class WNC_Employee(Employee_parent): #把要繼承的Class name塞入 # 到目前為止，原本Employee有的東西，WNC_Employee都有了 def __init__(self, name, salary, level = 3): # 要多加的level寫在這 # call之前Emplolyee的init來用，所以寫了這步， # 等於是少寫self.name, self.salary = name, salary 這一行 Employee_parent.__init__(self, name, salary) self.level = level def promote(self, num_level): self.level = self.level + num_level 看一下__init__那邊，一開始的init是為了initialize這個新的class的instance用的，而因為他繼承了Employee，所以原本描述Employee的所有attribute都要放入，所以一樣填入“name”和“salary”，而這個新的Class還要有新的attribute，叫“level”，用來描述職等。而這邊的self指的是WNC_Employee的instance的代名詞。 那第二行出現的Employee_parent.__init__(self, name, salary)，指的是我要套用之前Employee這個class的__init__函數，第一個self指的還是WNC_Employee的instance，但因為前面講過，他同時也是Employee的instance，所以可以這樣套進來。然後後面的name和salary就是用第一點傳入的name和salary。那這樣套用function後，他就會執行self.name = name, self.salary = salary 這兩行，所以，我只剩下self.level = level這行自己寫下來就好 這邊提醒一下，沒有規定一定要用Employee_parent.__init__()，你想要累累的寫self.name = name; self.salary = salary也可以。上面的寫法只是讓你省力，所以大家都這樣寫而已。 我們現在initialize一個instance看看： Hank_wnc2 = WNC_Employee(&quot;Hank&quot;, 22000, 3) print(Hank_wnc2.name) #&gt; Hank print(Hank_wnc2.salary) #&gt; 22000 print(Hank_wnc2.level) #&gt; 3 用新的function看看 Hank_wnc2.promote(1) print(Hank_wnc2.level) #&gt; 4 看起來很不錯，但如果我原本parent class的attribute就一大堆的話，我不就又要copy一堆attribute到我的__init__()裡面？其實不用，我們可以用*args和**kwargs直接代稱掉原本的arguments，例如以下這種寫法 class WNC_Employee2(Employee_parent): #把要繼承的Class name塞入 # 到目前為止，原本Employee有的東西，WNC_Employee都有了 def __init__(self, level, *args, **kwargs): # 要多加的level寫在這 Employee_parent.__init__(self, *args, **kwargs) self.level = level def promote(self, num_level): self.level = self.level + num_level wnc_hank2 = WNC_Employee2(name = &quot;Hank&quot;, salary = 22000, level = 3) print(wnc_hank2.level) #&gt; 3 wnc_hank2.promote(1) print(wnc_hank2.level) #&gt; 4 30.2.3 增加class-level attribute 這其實很好理解，你都繼承原本的class了，所以包括原本的class level attribute, instance attribute, methods全都繼承下來 所以，可以看一下剛剛的WNC_Employee的class level attribute: MIN_SALARY在不在 WNC_Employee.MIN_SALARY #&gt; 30000 在嘛，合理。那這一節的重點，是放在我如果修改child class的class-level attribute，parent class的class-level attribute會不會跟著變？ 直接講結論：class level attribute可以繼承，而child class的class level attribute可以overwritten掉原本parent class的class level attribute，但不會改變parent class的class level attribute class WNC_Employee_trial(Employee_parent): MIN_SALARY = 0 pass child = WNC_Employee_trial(&quot;Hank&quot;, 22000) parent = Employee_parent(&quot;Hank&quot;, 22000) print(child.MIN_SALARY) #&gt; 0 print(parent.MIN_SALARY) #&gt; 30000 print(WNC_Employee_trial.MIN_SALARY) #&gt; 0 print(Employee_parent.MIN_SALARY) #&gt; 30000 30.3 多形 多形的意思是，子類別雖然繼承父類別的methods，但我可以命名一個名稱一模一樣的method，讓他over-ride原先的method，這樣就達到名稱一樣，但功能不一樣的現象，我們叫“多形” 以WNC_Employee這個class為例，他繼承Employee_parent，所以也繼承了give_raise()這個method 那如果WNC這間公司是個佛心公司，他的加薪方式，跟一般公司不同(你輸入要加的薪水後，我還會給你額外的加成福利)，那我們有兩種做法： 寫一個新的method叫give_raise_new() 維持舊名稱give_raise()，但內容被我置換成wnc版本 -&gt; 建議這麼做，而這麼做的結果就是“多形” 直接看例子： class Employee_parent: MIN_SALARY = 30000 def __init__(self, name, salary): self.name = name self.salary = salary def give_raise(self, amount): self.salary += amount class WNC_Employee3(Employee_parent): def __init__(self, level, *args, **kwargs): Employee_parent.__init__(self, *args, **kwargs) self.level = level # 這邊開始修改新method def give_raise(self, amount, bonus=1): #method名稱同，但多個參數 new_amount = amount * bonus Employee_parent.give_raise(self, new_amount) #使用parent class的method Hank_in_parent = Employee_parent(name = &quot;Hank&quot;, salary = 22000) Hank_in_wnc = WNC_Employee3(name = &quot;Hank&quot;, salary = 22000, level = 3) Hank_in_parent.give_raise(amount=10000) Hank_in_wnc.give_raise(amount=10000, bonus=2) print(Hank_in_parent.salary) #&gt; 32000 print(Hank_in_wnc.salary) #&gt; 42000 class Animal: def eat(self): return(&quot;Animal is eating&quot;) class Dog: def eat(self): return(&quot;Dog is eating&quot;) class Pig: def eat(self): return(&quot;Pig is eating&quot;) d = Dog() p = Pig() print(d.eat()) #&gt; Dog is eating print(p.eat()) #&gt; Pig is eating 30.3.1 多形的使用時機 課堂上有舉個使用時機，但我現在還看不太懂好處在哪。 "]]
