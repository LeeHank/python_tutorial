[["index.html", "Python Tutorial Chapter 1 About this book", " Python Tutorial Hank Lee 2021-01-12 Chapter 1 About this book 這本書記錄我自學的過程，也可作為未來查找code的reference "],["python-basics.html", "Chapter 2 Python Basics 2.1 Variable and Types 2.2 Operations 2.3 Methods 2.4 packages:", " Chapter 2 Python Basics 這份檔案以DataCamp的第一章：Introduction to Python為主軸做整理，並補充一些後續看到的內容 2.1 Variable and Types python有以下幾種types: int: 整數 float: 就numeric str: string bool: boolean (True, False) 檢查變數的type，就用 desc = &quot;compound interest&quot; print(type(desc)) #&gt; &lt;class &#39;str&#39;&gt; 轉換型別： 轉成字串用str()： 通常是把數字轉成字串，用於製造出包含數字的字串句子 轉成整數用int(), 轉成數字用float(): 通常都是把文字轉成數字 str1 = str(1000) print(str1) #&gt; 1000 print(type(str1)) #&gt; &lt;class &#39;str&#39;&gt; str2 = &quot;5566&quot; int2 = int(str2) print(int2) #&gt; 5566 print(type(int2)) #&gt; &lt;class &#39;int&#39;&gt; 2.2 Operations 數字的型別，當然可以做加減乘除 那文字的呢？ 那Boolean的呢？ 2.2.1 字串的operations 2.2.1.1 想paste字串，直接用+ &quot;Let me&quot; + &quot; see see&quot; #&gt; &#39;Let me see see&#39; 2.3 Methods 在python裡，所有東西都是object 每個object都有所屬的method，可以想成此object的專屬技能(Methods: Functions that belong to objects) 至於是什麼method呢？depend on type! 舉例來說，a = \"hahaha\"，那a是一個object，哪種type的object? string這種type的object，所以他有string的專屬技能。例如a.upper()可以把字串轉成全大寫 2.3.1 字串的methods 試試看改這個就好 2.3.1.1 .upper() 把字串全轉成大寫 a = &quot;hahaha&quot; new = a.upper() print(new) #&gt; HAHAHA print(a) #&gt; hahaha 2.3.1.2 .capitalize() 把字首改大寫 a = &quot;hahaha&quot; new = a.capitalize() print(new) #&gt; Hahaha print(a) #&gt; hahaha 2.3.1.3 .count() 可以算某個字母出現幾次 a = &quot;hahaha&quot; new = a.count(&quot;a&quot;) print(new) #&gt; 3 print(a) #&gt; hahaha 2.4 packages: python的package就和R的package一樣，他就是一個資料夾，裡面放滿一個又一個的 .py script 每個script，就是一個module，裡面specify functions, methods, types 現在有成千上萬個python的package，例如numpy, scikit-learn… 2.4.1 Install package 在terminal裡打pip install numpy 2.4.2 Import package import numpy import numpy as np from numpy import array: 只import numpy裡面的array這個function from numpy import *: 這是最爛的寫法，他的意思是，我把numpy裡面所有的屬性和方法都load到我現在的environment裡面。爛的地方在於，他可以覆蓋掉你之前定義過的東西。例如，你之前定義過一個function叫demo，而numpy裡面也有一個function叫demo，那你一用from numpy import *，那現在的local environment就只剩numpy的demo了。 整體來說，建議多用第二點，因為這樣當你用array()這個function時，會寫成np.array()，就會非常清楚這個function來自哪個package，而不會搞亂 而對於引用自己寫好的local package，則較常使用from…import…這種寫法。詳情等module &amp; package那個章節就知道 "],["list-.html", "Chapter 3 List基本介紹 3.1 建立list 3.2 Selecting List Elements 3.3 Replace 3.4 Operation 3.5 Methods 3.6 List 是 mutable 3.7 List的功能（最常用來做for loop)", " Chapter 3 List基本介紹 3.1 建立list 3.1.1 單維list list是一連串有順序的物件，不見得要是同一種type a_list = [12, 3, 67, 7, 82] #同一種type的list another_list = [&quot;happy&quot;, 3, True, 7] #不同type的list 但習慣上，我們還是會把list裡的element，都寫成同一種type 3.1.2 多維list list 裡面還有list，就叫多維list a = [1,2,3,4,5] # 1*5 list multi_dim_a = [[1,2,3], [2,3,4], [3,4,5]] print(multi_dim_a) #&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5]] 3.2 Selecting List Elements 3.2.1 Subset list因為只有element，沒有name(簡單來講，就是只有value，沒有key)，所以subset時，都是用index來取 index就擬人化為座號，而python的編號由左至右是從0開始，由右至左是從-1開始 所以我要取list中左邊數來第n個人，他的座號是n-1，那就要取n-1的index 如果我要取list中右邊數來第n個人，他的座號是-n，那就要取-n的index 看例子： my_list = [&quot;my&quot;, &quot;list&quot;, &quot;is&quot;, &quot;nice&quot;] my_list[3] # 取index=3, 那就是取element = 4 #&gt; &#39;nice&#39; my_list[-2] # 取index -2, 即又邊數來第二個 #&gt; &#39;is&#39; 學會單維list的subset了，那多維list的subset邏輯一模一樣 multi_dim_a = [[1,2,3], [2,3,4],[3,4,5]] multi_dim_a[1] # 取index = 1，即左邊數來第2個 #&gt; [2, 3, 4] multi_dim_a[1][0] # 先取左邊數來第2個element，再取裡面的第1個element #&gt; 2 3.2.2 Slice 剛剛是取“某一個”element，那如果我想取“某一串”element呢？那就是指slice 語法是[start_index:stop_index]，所以[1:5]是指從index=1取到index=4，那就是取第2個element到第5個 所以為了方便記憶，就把stop_index當作stop_element來看，然後start_index還是start_index 簡單練習，[5:9]，就是指取element = 6 ~ 9 然後，如果你跳過start_index不寫，就是從頭開始；跳過stop_index不寫，就是取到最後；兩個都不寫，就是全取 例如： [:9]，那就是從第一個element一路取到第9個element 例如: [3:]，那就是第4個element一路取到最後一個element 例如: [:]，那就是整串全取(等於複製一個) my_list = [&quot;my&quot;, &quot;list&quot;, &quot;is&quot;, &quot;nice&quot;] my_list[1:3] # 取 element = 2~3 #&gt; [&#39;list&#39;, &#39;is&#39;] my_list[:3] # 取element = 1~3 #&gt; [&#39;my&#39;, &#39;list&#39;, &#39;is&#39;] my_list[1:] # 取element = 2~最後 #&gt; [&#39;list&#39;, &#39;is&#39;, &#39;nice&#39;] slice一律只能由左至右取，但編號系統可以用正的編號(由左至右的編號系統)或負的編號(由右至左的編號系統) [1:3]是指由左至右，取element= 2~3 [-2:-3]是指由右至左，取element = 右邊數來第2個 ~ 第3個? NO! 他只能由左至右取，所以應該寫成[-3:-2]? NO! 這樣他指會取右邊數來的第3個element，到右邊數來的第2個element的“前1個”! 所以如果要取右邊數來第3個element到右邊數來第2個element，那要寫成[-3:-1] my_list #&gt; [&#39;my&#39;, &#39;list&#39;, &#39;is&#39;, &#39;nice&#39;] my_list[-3:-1] #&gt; [&#39;list&#39;, &#39;is&#39;] 3.3 Replace 剛剛已經學會如何取出list中的特定一個element，或是一串element，那我們就可以利用這個技巧，把新值assign到指定位置： my_list #&gt; [&#39;my&#39;, &#39;list&#39;, &#39;is&#39;, &#39;nice&#39;] my_list[3] = &quot;bad&quot; my_list #&gt; [&#39;my&#39;, &#39;list&#39;, &#39;is&#39;, &#39;bad&#39;] my_list[1:] = [&quot;lists&quot;, &quot;are&quot;, &quot;awsome&quot;] my_list #&gt; [&#39;my&#39;, &#39;lists&#39;, &#39;are&#39;, &#39;awsome&#39;] 3.4 Operation 對各種資料類型，我們都會討論他的運算 例如之前教float這種type，我們就很熟悉他的運算有 +, -, *, /, **, //, % 例如之前教str這種type，也學過他有 * (就是repeat幾次) 和 + (就是paste()的概念) 那現在講list這種type，他的運算就和字串有點像，包含 * 和 + 3.4.1 list1 + list2 = c(list1, list2) list1 = [&quot;Hello!&quot;, &quot;How&quot;] list2 = [&quot;are&quot;, &quot;you&quot;] list1 + list2 #&gt; [&#39;Hello!&#39;, &#39;How&#39;, &#39;are&#39;, &#39;you&#39;] 3.4.2 list1 * 2 = rep(list1, 2) list1 * 2 #&gt; [&#39;Hello!&#39;, &#39;How&#39;, &#39;Hello!&#39;, &#39;How&#39;] 3.5 Methods 別忘了，每種type他其實都是一種class，所以除了你定義好的資料外，他還有專屬技能(method) 當我們把list的資料part，用上面教過的方法定義好後，接下來就可以用他的method，來對這個list工作 methods很容易讓人搞混的地方，是他做完事後會分成兩種狀況：1. 直接改變原object, 不吐新東西出來(吐None) 2. 不改變原object，但會吐新東西出來 直接看例子： 3.5.1 list.append(x) = R的c(list, x) fruits = [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;] new = fruits.append(&quot;grape&quot;) print(new) #&gt; None print(fruits) #&gt; [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;] 從上例可以清楚的看到，當你用list.append時，他吐出來的值是None，而原list已經被改變了，這就是上面提過的狀況1 要判斷一個method，他會是狀況1 or 狀況，有幾種方法： 先猜: 做這個method，本質上就是要去改原物件的，那通常Python就會直接幫你改，例如這邊的.append就是 做實驗驗證：總是先把結果存到一個新變數(如這邊的new)，然後看看new會不會是None，來做確認 乖乖牌：不做實驗，直接去看操作手冊如何定義，像.append的定義就是：only modify the list have no return value printed – they return the default None 接下來會介紹各種list的method，就去猜測 &amp; 實戰看看 再介紹其他list之前，想想功能性：如果我今天想要append東西到list的最後面，我有沒有別的作法？ 用R的邏輯，我就會寫c(list,x)，但在Python，我就會寫 list = list + [x] fruits + [&quot;new_fruit&quot;] #&gt; [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;, &#39;new_fruit&#39;] 所以可以想像，我的append，應該可以加多個element在後面，只要我加的類型也是list就好 fruits + [&quot;new_fruit1, new_fruit2&quot;] #&gt; [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;, &#39;new_fruit1, new_fruit2&#39;] fruits.append([&quot;new_fruit1&quot;, &quot;new_fruit2&quot;]) fruits #&gt; [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;, [&#39;new_fruit1&#39;, &#39;new_fruit2&#39;]] 實驗結果發現：不行! 他會變成多維list 所以如果要加多個element，就直接用 + 的方式來做吧 3.5.2 list.pop() = 移除最後一個element print(fruits) #&gt; [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;, [&#39;new_fruit1&#39;, &#39;new_fruit2&#39;]] new = fruits.pop() print(new) #&gt; [&#39;new_fruit1&#39;, &#39;new_fruit2&#39;] print(fruits) #&gt; [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;] 3.5.3 list.remove(a) = R的 list[which(list == a)[1]] print(fruits) #&gt; [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;] new = fruits.remove(&quot;grape&quot;) print(new) #&gt; None print(fruits) #&gt; [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;] 可以發現，remove也是直接改，return None的類型 3.5.4 list.sort() = R的sort(list) print(fruits) #&gt; [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;] new = fruits.sort() # 預設是由小排到大，若要由大排到寫，改寫成 fruits.sort(reverse=True) # 由大排到小 print(new) #&gt; None print(fruits) #&gt; [&#39;apple&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;orange&#39;, &#39;pear&#39;] 3.5.5 list.reverse() print(fruits) #&gt; [&#39;apple&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;orange&#39;, &#39;pear&#39;] new = fruits.reverse() print(new) #&gt; None print(fruits) #&gt; [&#39;pear&#39;, &#39;orange&#39;, &#39;kiwi&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;apple&#39;] 3.5.6 list.insert(index, x) = 我要把x插入到index的前面 print(fruits) #&gt; [&#39;pear&#39;, &#39;orange&#39;, &#39;kiwi&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;apple&#39;] new = fruits.insert(0, &quot;haha&quot;) print(new) #&gt; None print(fruits) #&gt; [&#39;haha&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;kiwi&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;apple&#39;] 3.5.7 list.index(a) = R的which(list1 == a)[1] print(fruits) #&gt; [&#39;haha&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;kiwi&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;apple&#39;] new = fruits.index(&#39;banana&#39;) print(new) #&gt; 4 print(fruits) #&gt; [&#39;haha&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;kiwi&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;apple&#39;] 終於看到一個method是不改舊值，吐新值了 這完全猜的到吧!? 3.5.8 list.count(x) = 計算x在list中出現幾次 print(fruits) #&gt; [&#39;haha&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;kiwi&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;apple&#39;] new = fruits.count(&quot;banana&quot;) print(new) #&gt; 2 print(fruits) #&gt; [&#39;haha&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;kiwi&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;apple&#39;] 3.6 List 是 mutable 在討論mutable或inmuatable的問題時，都是在討論當你把原物件copy一次後，對新copy的物件做事，會不會影響到舊物件 而對list來說，就是會，因為variable name只是一個reference，指到記憶體位置，所以原物建和copy後的物件，其實都指到同一個位置，那你一改他，兩個variable就都會跟著動 以下舉例： areas = [11.25, 18.0, 20.0, 10.75, 9.50] # Create areas_copy areas_copy = areas # Change areas_copy areas_copy[0] = 5.0 # Print areas print(areas) #&gt; [5.0, 18.0, 20.0, 10.75, 9.5] 那這樣豪可怕，我如果想只針對copy的做事，但不要影響到原物件，該怎麼做？ 在copy的時候，使用list()的語法，那就會新開一個記憶體位置給他，就不會同步影響到了： areas = [11.25, 18.0, 20.0] areas_copy = list(areas) areas_copy[0] = 5.0 print(areas) #&gt; [11.25, 18.0, 20.0] 3.7 List的功能（最常用來做for loop) R的觀點來做迭代，習慣取index，那就會寫成下面這樣： for index in range(len(a_list)): print(&quot;index = &quot;, index, &quot;, number in list = &quot;, a_list[index]) len(a_list)得到他的長度=5，而range(5)表示由0開始stop在5，所以就得到0,1,2,3,4這五個index 但python的觀點，都是直接取裡面的element做迭代，那就會寫成這樣： for element in a_list: print(&quot;number in list = &quot;, element) 最後，python才有的，又取index，又取element，語法是： enumerate for index, element in enumerate(a_list): print(&quot;index = &quot;, index, &quot;, number in list = &quot;, element) "],["numpy.html", "Chapter 4 NumPy 4.1 Why NumPy 4.2 Subset np.array 4.3 Statistics functions", " Chapter 4 NumPy 4.1 Why NumPy 為啥要用NumPy呢? 其實簡單的理由就是，list無法做數學運算，他只能拿來存東西… height = [1.73, 1.68, 1.71, 1.89, 1.79] weight = [65.4, 59.2, 63.6, 88.4, 68.7] weight/(height**2) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: unsupported operand type(s) for ** or pow(): &#39;list&#39; and &#39;int&#39; #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 因為list原本就是設計來存取資料的，它允許每個element可以是不同的type 所以，即使你每個element都放float這種type，list還是list，不會變成numerical list 所以你要叫list做數學運算時，他就不知道怎麼算了，畢竟他也不知道這個list是不是全都numerical的資訊 而NumPy，就是numerical python的縮寫，他的np.array，就是numerical list，所以只要啟用numpy，就可以做計算了 import numpy as np height = np.array([1.73, 1.68, 1.71, 1.89, 1.79]) weight = np.array([65.4, 59.2, 63.6, 88.4, 68.7]) weight/(height**2) #&gt; array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836]) 我們可以把np.array想成R的vector，如果你的array裡面放了不同type的東西，他會全部轉成string np.array([1.0, &quot;is&quot;, True]) #&gt; array([&#39;1.0&#39;, &#39;is&#39;, &#39;True&#39;], dtype=&#39;&lt;U32&#39;) 所以，我們可以把對np.array所做的行為，想成在R裡面對vector所做的行為，而list的行為，都要往“儲存資料”的角度去想： python_list = [1,2,3] python_list + python_list #&gt; [1, 2, 3, 1, 2, 3] numpy_array = np.array([1,2,3]) numpy_array + numpy_array #&gt; array([2, 4, 6]) 4.2 Subset np.array 也因為numpy可以做運算，所以在subset上，比list又更好用了 height_list = [1.73, 1.68, 1.71, 1.89, 1.79] height_array = np.array([1.73, 1.68, 1.71, 1.89, 1.79]) height_list[1] #&gt; 1.68 height_array[1] #&gt; 1.68 height_list[height_list&gt;1.71] #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: &#39;&gt;&#39; not supported between instances of &#39;list&#39; and &#39;float&#39; #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; height_array[height_array&gt;1.71] #&gt; array([1.73, 1.89, 1.79]) 4.3 Statistics functions 4.3.1 Generate data height = np.round(np.random.normal(1.75, 0.20, 5000), 2) weight = np.round(np.random.normal(60.32, 15, 5000), 2) np_city = np.column_stack((height, weight)) np_city #&gt; array([[ 1.46, 66.73], #&gt; [ 1.73, 58.31], #&gt; [ 1.79, 57.13], #&gt; ..., #&gt; [ 1.76, 70.53], #&gt; [ 1.34, 50.67], #&gt; [ 1.92, 51.52]]) 4.3.2 Summary statistics # Print mean height (first column) avg = np.mean(np_city[:,0]) print(&quot;Average: &quot; + str(avg)) # Print median height. Replace &#39;None&#39; #&gt; Average: 1.750686 med = np.median(np_city[:,0]) print(&quot;Median: &quot; + str(med)) # Print out the standard deviation on height. Replace &#39;None&#39; #&gt; Median: 1.75 stddev = np.std(np_city[:,0]) print(&quot;Standard Deviation: &quot; + str(stddev)) # Print out correlation between first and second column. Replace &#39;None&#39; #&gt; Standard Deviation: 0.2004507655360787 corr = np.corrcoef(np_city[:,0], np_city[:,1]) print(&quot;Correlation: &quot; + str(corr)) #&gt; Correlation: [[1. 0.00576678] #&gt; [0.00576678 1. ]] "]]
